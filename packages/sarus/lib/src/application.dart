part of '_internal.dart';

/// An abstract class that defines the contract for a Sarus application.
///
/// Every Sarus application must define how to:
/// - **Initialize** the application with necessary setup/configuration
/// - **Start** the server and begin listening for incoming requests
///
/// This pattern allows for clean separation between setup and server startup,
/// and encourages testability and scalability for larger apps.
abstract class Application {
  /// Initializes the application.
  ///
  /// This is where you should load environment variables, register services,
  /// initialize dependencies, configure databases, etc.
  ///
  /// Called **before** the server starts.
  Future<void> setup();

  /// Starts the HTTP server.
  ///
  /// This should bind the HTTP server to a specific address and port, and
  /// attach a request handler (typically using `shelf`).
  ///
  /// Returns the started [HttpServer] instance.
  Future<HttpServer> run();
}

/// The base class for all Sarus route groups.
///
/// An `Endpoints` subclass defines a collection of related HTTP handlers
/// (GET, POST, etc.), mapped to a base route path via `@Endpoint(path: ...)`.
///
/// Each subclass must provide a [RouterConfig] that is generated via codegen,
/// and may override the [handler] to attach middleware.
///
/// This abstraction encourages modular, testable route definitions,
/// and allows you to extend functionality per group.
abstract class Endpoints {
  /// The HTTP handler used by this route group.
  ///
  /// By default, delegates to the [router] method, but can be overridden
  /// to add middleware, logging, guards, etc.
  Handler get handler => router.call;

  /// The [RouterConfig] defines the routing configuration
  /// for this endpoint class.
  ///
  /// This is typically generated by the `@Endpoint()` annotation and codegen.
  RouterConfig get router;

  /// The prefix for this endpoint class.
  ///
  /// This is typically generated by the `@Endpoint()` annotation and codegen.
  static const String prefix = '';
}

abstract class Model<T> {
  Map<String, dynamic> toJson();
}
