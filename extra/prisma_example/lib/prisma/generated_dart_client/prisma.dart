// ignore_for_file: non_constant_identifier_names

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:orm/orm.dart' as _i1;

import 'prisma.dart' as _i2;

class CategoryCountOutputType {
  const CategoryCountOutputType({
    this.subcategories,
    this.products,
  });

  factory CategoryCountOutputType.fromJson(Map json) => CategoryCountOutputType(
        subcategories: json['subcategories'],
        products: json['products'],
      );

  final int? subcategories;

  final int? products;

  Map<String, dynamic> toJson() => {
        'subcategories': subcategories,
        'products': products,
      };
}

class CartCountOutputType {
  const CartCountOutputType({this.items});

  factory CartCountOutputType.fromJson(Map json) =>
      CartCountOutputType(items: json['items']);

  final int? items;

  Map<String, dynamic> toJson() => {'items': items};
}

class WishlistCountOutputType {
  const WishlistCountOutputType({this.items});

  factory WishlistCountOutputType.fromJson(Map json) =>
      WishlistCountOutputType(items: json['items']);

  final int? items;

  Map<String, dynamic> toJson() => {'items': items};
}

class DiscountCountOutputType {
  const DiscountCountOutputType({this.products});

  factory DiscountCountOutputType.fromJson(Map json) =>
      DiscountCountOutputType(products: json['products']);

  final int? products;

  Map<String, dynamic> toJson() => {'products': products};
}

class ProductCountOutputType {
  const ProductCountOutputType({
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  factory ProductCountOutputType.fromJson(Map json) => ProductCountOutputType(
        categories: json['categories'],
        images: json['images'],
        cartItems: json['cartItems'],
        orderItems: json['orderItems'],
        reviews: json['reviews'],
        wishlistItems: json['wishlistItems'],
        discounts: json['discounts'],
      );

  final int? categories;

  final int? images;

  final int? cartItems;

  final int? orderItems;

  final int? reviews;

  final int? wishlistItems;

  final int? discounts;

  Map<String, dynamic> toJson() => {
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class OrderCountOutputType {
  const OrderCountOutputType({
    this.items,
    this.payments,
  });

  factory OrderCountOutputType.fromJson(Map json) => OrderCountOutputType(
        items: json['items'],
        payments: json['payments'],
      );

  final int? items;

  final int? payments;

  Map<String, dynamic> toJson() => {
        'items': items,
        'payments': payments,
      };
}

class AddressCountOutputType {
  const AddressCountOutputType({
    this.shippingOrders,
    this.billingOrders,
  });

  factory AddressCountOutputType.fromJson(Map json) => AddressCountOutputType(
        shippingOrders: json['shippingOrders'],
        billingOrders: json['billingOrders'],
      );

  final int? shippingOrders;

  final int? billingOrders;

  Map<String, dynamic> toJson() => {
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class UserCountOutputType {
  const UserCountOutputType({
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  factory UserCountOutputType.fromJson(Map json) => UserCountOutputType(
        addresses: json['addresses'],
        carts: json['carts'],
        orders: json['orders'],
        reviews: json['reviews'],
        wishlists: json['wishlists'],
      );

  final int? addresses;

  final int? carts;

  final int? orders;

  final int? reviews;

  final int? wishlists;

  Map<String, dynamic> toJson() => {
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class NestedIntFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class IntFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedStringFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  final _i1.PrismaUnion<String, _i1.Reference<String>>? equals;

  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<String, _i2.NestedStringFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
      };
}

class StringFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  final _i1.PrismaUnion<String, _i1.Reference<String>>? equals;

  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<String, _i2.NestedStringFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
      };
}

class NestedStringNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i2.NestedStringNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
      };
}

class StringNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i2.NestedStringNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
      };
}

class NestedDateTimeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class DateTimeFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedBoolFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolFilter({
    this.equals,
    this.not,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class BoolFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolFilter({
    this.equals,
    this.not,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class UserScalarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserScalarRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.UserWhereInput? $is;

  final _i2.UserWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class NestedDecimalFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDecimalFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? equals;

  final Iterable<_i1.Decimal>? $in;

  final Iterable<_i1.Decimal>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal, _i2.NestedDecimalFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class DecimalFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DecimalFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? equals;

  final Iterable<_i1.Decimal>? $in;

  final Iterable<_i1.Decimal>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal, _i2.NestedDecimalFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class AddressScalarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressScalarRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.AddressWhereInput? $is;

  final _i2.AddressWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class OrderScalarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderScalarRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.OrderWhereInput? $is;

  final _i2.OrderWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class NestedIntNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int,
      _i1.PrismaUnion<_i2.NestedIntNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class IntNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int,
      _i1.PrismaUnion<_i2.NestedIntNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class CategoryNullableScalarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryNullableScalarRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.CategoryWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.CategoryWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class CategoryListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.CategoryWhereInput? every;

  final _i2.CategoryWhereInput? some;

  final _i2.CategoryWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class CategoryWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.subcategories,
    this.products,
  });

  final _i1
      .PrismaUnion<_i2.CategoryWhereInput, Iterable<_i2.CategoryWhereInput>>?
      AND;

  final Iterable<_i2.CategoryWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.CategoryWhereInput, Iterable<_i2.CategoryWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      parentCategoryId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.CategoryNullableScalarRelationFilter,
      _i1.PrismaUnion<_i2.CategoryWhereInput, _i1.PrismaNull>>? parentCategory;

  final _i2.CategoryListRelationFilter? subcategories;

  final _i2.ProductCategoryListRelationFilter? products;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryScalarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryScalarRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.CategoryWhereInput? $is;

  final _i2.CategoryWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ProductCategoryWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.categoryId,
    this.product,
    this.category,
  });

  final _i1.PrismaUnion<_i2.ProductCategoryWhereInput,
      Iterable<_i2.ProductCategoryWhereInput>>? AND;

  final Iterable<_i2.ProductCategoryWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereInput,
      Iterable<_i2.ProductCategoryWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? categoryId;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  final _i1
      .PrismaUnion<_i2.CategoryScalarRelationFilter, _i2.CategoryWhereInput>?
      category;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'categoryId': categoryId,
        'product': product,
        'category': category,
      };
}

class ProductCategoryListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ProductCategoryWhereInput? every;

  final _i2.ProductCategoryWhereInput? some;

  final _i2.ProductCategoryWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class ProductImageWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.product,
  });

  final _i1.PrismaUnion<_i2.ProductImageWhereInput,
      Iterable<_i2.ProductImageWhereInput>>? AND;

  final Iterable<_i2.ProductImageWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductImageWhereInput,
      Iterable<_i2.ProductImageWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? imageUrl;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isPrimary;

  final _i1.PrismaUnion<_i2.IntFilter, int>? displayOrder;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        'product': product,
      };
}

class ProductImageListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ProductImageWhereInput? every;

  final _i2.ProductImageWhereInput? some;

  final _i2.ProductImageWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class CartWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
  });

  final _i1.PrismaUnion<_i2.CartWhereInput, Iterable<_i2.CartWhereInput>>? AND;

  final Iterable<_i2.CartWhereInput>? OR;

  final _i1.PrismaUnion<_i2.CartWhereInput, Iterable<_i2.CartWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  final _i2.CartItemListRelationFilter? items;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

class CartScalarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartScalarRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.CartWhereInput? $is;

  final _i2.CartWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class CartItemWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.cart,
    this.product,
  });

  final _i1
      .PrismaUnion<_i2.CartItemWhereInput, Iterable<_i2.CartItemWhereInput>>?
      AND;

  final Iterable<_i2.CartItemWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.CartItemWhereInput, Iterable<_i2.CartItemWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? cartId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? quantity;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? priceAtAddition;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? addedAt;

  final _i1.PrismaUnion<_i2.CartScalarRelationFilter, _i2.CartWhereInput>? cart;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
        'product': product,
      };
}

class CartItemListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.CartItemWhereInput? every;

  final _i2.CartItemWhereInput? some;

  final _i2.CartItemWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class ReviewWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.product,
    this.user,
  });

  final _i1.PrismaUnion<_i2.ReviewWhereInput, Iterable<_i2.ReviewWhereInput>>?
      AND;

  final Iterable<_i2.ReviewWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ReviewWhereInput, Iterable<_i2.ReviewWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? rating;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
        'user': user,
      };
}

class ReviewListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ReviewWhereInput? every;

  final _i2.ReviewWhereInput? some;

  final _i2.ReviewWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class WishlistWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
  });

  final _i1
      .PrismaUnion<_i2.WishlistWhereInput, Iterable<_i2.WishlistWhereInput>>?
      AND;

  final Iterable<_i2.WishlistWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.WishlistWhereInput, Iterable<_i2.WishlistWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  final _i2.WishlistItemListRelationFilter? items;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

class WishlistScalarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistScalarRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.WishlistWhereInput? $is;

  final _i2.WishlistWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class WishlistItemWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.wishlist,
    this.product,
  });

  final _i1.PrismaUnion<_i2.WishlistItemWhereInput,
      Iterable<_i2.WishlistItemWhereInput>>? AND;

  final Iterable<_i2.WishlistItemWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WishlistItemWhereInput,
      Iterable<_i2.WishlistItemWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? wishlistId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? addedAt;

  final _i1
      .PrismaUnion<_i2.WishlistScalarRelationFilter, _i2.WishlistWhereInput>?
      wishlist;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        'wishlist': wishlist,
        'product': product,
      };
}

class WishlistItemListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.WishlistItemWhereInput? every;

  final _i2.WishlistItemWhereInput? some;

  final _i2.WishlistItemWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class DiscountWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.products,
  });

  final _i1
      .PrismaUnion<_i2.DiscountWhereInput, Iterable<_i2.DiscountWhereInput>>?
      AND;

  final Iterable<_i2.DiscountWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.DiscountWhereInput, Iterable<_i2.DiscountWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? amount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? discountType;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      usageLimit;

  final _i1.PrismaUnion<_i2.IntFilter, int>? timesUsed;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? validFrom;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? validTo;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isActive;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.ProductDiscountListRelationFilter? products;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
      };
}

class DiscountScalarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountScalarRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.DiscountWhereInput? $is;

  final _i2.DiscountWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ProductDiscountWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.discountId,
    this.product,
    this.discount,
  });

  final _i1.PrismaUnion<_i2.ProductDiscountWhereInput,
      Iterable<_i2.ProductDiscountWhereInput>>? AND;

  final Iterable<_i2.ProductDiscountWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereInput,
      Iterable<_i2.ProductDiscountWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? discountId;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  final _i1
      .PrismaUnion<_i2.DiscountScalarRelationFilter, _i2.DiscountWhereInput>?
      discount;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'discountId': discountId,
        'product': product,
        'discount': discount,
      };
}

class ProductDiscountListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ProductDiscountWhereInput? every;

  final _i2.ProductDiscountWhereInput? some;

  final _i2.ProductDiscountWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class ProductWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<_i2.ProductWhereInput, Iterable<_i2.ProductWhereInput>>?
      AND;

  final Iterable<_i2.ProductWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductWhereInput, Iterable<_i2.ProductWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? price;

  final _i1.PrismaUnion<_i2.IntFilter, int>? stockQuantity;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isActive;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.ProductCategoryListRelationFilter? categories;

  final _i2.ProductImageListRelationFilter? images;

  final _i2.CartItemListRelationFilter? cartItems;

  final _i2.OrderItemListRelationFilter? orderItems;

  final _i2.ReviewListRelationFilter? reviews;

  final _i2.WishlistItemListRelationFilter? wishlistItems;

  final _i2.ProductDiscountListRelationFilter? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductScalarRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductScalarRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.ProductWhereInput? $is;

  final _i2.ProductWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class OrderItemWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.order,
    this.product,
  });

  final _i1
      .PrismaUnion<_i2.OrderItemWhereInput, Iterable<_i2.OrderItemWhereInput>>?
      AND;

  final Iterable<_i2.OrderItemWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.OrderItemWhereInput, Iterable<_i2.OrderItemWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? orderId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? quantity;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? priceAtPurchase;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? subtotal;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.OrderScalarRelationFilter, _i2.OrderWhereInput>?
      order;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
        'product': product,
      };
}

class OrderItemListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.OrderItemWhereInput? every;

  final _i2.OrderItemWhereInput? some;

  final _i2.OrderItemWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class PaymentWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.order,
  });

  final _i1.PrismaUnion<_i2.PaymentWhereInput, Iterable<_i2.PaymentWhereInput>>?
      AND;

  final Iterable<_i2.PaymentWhereInput>? OR;

  final _i1.PrismaUnion<_i2.PaymentWhereInput, Iterable<_i2.PaymentWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? orderId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentMethod;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? amount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? status;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? paymentDate;

  final _i1.PrismaUnion<_i2.OrderScalarRelationFilter, _i2.OrderWhereInput>?
      order;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        'order': order,
      };
}

class PaymentListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.PaymentWhereInput? every;

  final _i2.PaymentWhereInput? some;

  final _i2.PaymentWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class OrderWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.billingAddress,
    this.items,
    this.payments,
  });

  final _i1.PrismaUnion<_i2.OrderWhereInput, Iterable<_i2.OrderWhereInput>>?
      AND;

  final Iterable<_i2.OrderWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OrderWhereInput, Iterable<_i2.OrderWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? shippingAddressId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? billingAddressId;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? subtotal;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? tax;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? shippingCost;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? totalAmount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? status;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentStatus;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  final _i1.PrismaUnion<_i2.AddressScalarRelationFilter, _i2.AddressWhereInput>?
      shippingAddress;

  final _i1.PrismaUnion<_i2.AddressScalarRelationFilter, _i2.AddressWhereInput>?
      billingAddress;

  final _i2.OrderItemListRelationFilter? items;

  final _i2.PaymentListRelationFilter? payments;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
      };
}

class OrderListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.OrderWhereInput? every;

  final _i2.OrderWhereInput? some;

  final _i2.OrderWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class AddressWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingOrders,
    this.billingOrders,
  });

  final _i1.PrismaUnion<_i2.AddressWhereInput, Iterable<_i2.AddressWhereInput>>?
      AND;

  final Iterable<_i2.AddressWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AddressWhereInput, Iterable<_i2.AddressWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? addressLine1;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<_i2.StringFilter, String>? city;

  final _i1.PrismaUnion<_i2.StringFilter, String>? state;

  final _i1.PrismaUnion<_i2.StringFilter, String>? postalCode;

  final _i1.PrismaUnion<_i2.StringFilter, String>? country;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isDefault;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  final _i2.OrderListRelationFilter? shippingOrders;

  final _i2.OrderListRelationFilter? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.AddressWhereInput? every;

  final _i2.AddressWhereInput? some;

  final _i2.AddressWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class CartListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.CartWhereInput? every;

  final _i2.CartWhereInput? some;

  final _i2.CartWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class WishlistListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.WishlistWhereInput? every;

  final _i2.WishlistWhereInput? some;

  final _i2.WishlistWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class UserWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? AND;

  final Iterable<_i2.UserWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? email;

  final _i1.PrismaUnion<_i2.StringFilter, String>? password;

  final _i1.PrismaUnion<_i2.StringFilter, String>? firstName;

  final _i1.PrismaUnion<_i2.StringFilter, String>? lastName;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.AddressListRelationFilter? addresses;

  final _i2.CartListRelationFilter? carts;

  final _i2.OrderListRelationFilter? orders;

  final _i2.ReviewListRelationFilter? reviews;

  final _i2.WishlistListRelationFilter? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserWhereUniqueInput({
    this.id,
    this.email,
    this.AND,
    this.OR,
    this.NOT,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final int? id;

  final String? email;

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? AND;

  final Iterable<_i2.UserWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? password;

  final _i1.PrismaUnion<_i2.StringFilter, String>? firstName;

  final _i1.PrismaUnion<_i2.StringFilter, String>? lastName;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.AddressListRelationFilter? addresses;

  final _i2.CartListRelationFilter? carts;

  final _i2.OrderListRelationFilter? orders;

  final _i2.ReviewListRelationFilter? reviews;

  final _i2.WishlistListRelationFilter? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class AddressUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OrderUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OrderShippingAddressArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderShippingAddressArgs({
    this.select,
    this.include,
  });

  final _i2.AddressSelect? select;

  final _i2.AddressInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OrderBillingAddressArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderBillingAddressArgs({
    this.select,
    this.include,
  });

  final _i2.AddressSelect? select;

  final _i2.AddressInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OrderItemOrderArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemOrderArgs({
    this.select,
    this.include,
  });

  final _i2.OrderSelect? select;

  final _i2.OrderInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ProductCategoryProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CategoryParentCategoryArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryParentCategoryArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.CategoryWhereInput? where;

  final _i2.CategorySelect? select;

  final _i2.CategoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

enum SortOrder implements _i1.PrismaEnum {
  asc._('asc'),
  desc._('desc');

  const SortOrder._(this.name);

  @override
  final String name;
}

enum NullsOrder implements _i1.PrismaEnum {
  first._('first'),
  last._('last');

  const NullsOrder._(this.name);

  @override
  final String name;
}

class SortOrderInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SortOrderInput({
    required this.sort,
    this.nulls,
  });

  final _i2.SortOrder sort;

  final _i2.NullsOrder? nulls;

  @override
  Map<String, dynamic> toJson() => {
        'sort': sort,
        'nulls': nulls,
      };
}

class CategoryOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ProductCategoryOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class CategoryOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryOrderByWithRelationInput({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.subcategories,
    this.products,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? parentCategoryId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.CategoryOrderByWithRelationInput? parentCategory;

  final _i2.CategoryOrderByRelationAggregateInput? subcategories;

  final _i2.ProductCategoryOrderByRelationAggregateInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.subcategories,
    this.products,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.CategoryWhereInput, Iterable<_i2.CategoryWhereInput>>?
      AND;

  final Iterable<_i2.CategoryWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.CategoryWhereInput, Iterable<_i2.CategoryWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      parentCategoryId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.CategoryNullableScalarRelationFilter,
      _i1.PrismaUnion<_i2.CategoryWhereInput, _i1.PrismaNull>>? parentCategory;

  final _i2.CategoryListRelationFilter? subcategories;

  final _i2.ProductCategoryListRelationFilter? products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'subcategories': subcategories,
        'products': products,
      };
}

enum CategoryScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Category'),
  name$<String>('name', 'Category'),
  description<String>('description', 'Category'),
  parentCategoryId<int>('parentCategoryId', 'Category'),
  createdAt<DateTime>('createdAt', 'Category'),
  updatedAt<DateTime>('updatedAt', 'Category');

  const CategoryScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class CategorySubcategoriesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategorySubcategoriesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.CategoryWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.CategoryOrderByWithRelationInput>,
      _i2.CategoryOrderByWithRelationInput>? orderBy;

  final _i2.CategoryWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.CategoryScalar, Iterable<_i2.CategoryScalar>>?
      distinct;

  final _i2.CategorySelect? select;

  final _i2.CategoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ProductImageOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class CartItemOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class OrderItemOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ReviewOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class WishlistItemOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ProductDiscountOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ProductOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductOrderByWithRelationInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? stockQuantity;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sku;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ProductCategoryOrderByRelationAggregateInput? categories;

  final _i2.ProductImageOrderByRelationAggregateInput? images;

  final _i2.CartItemOrderByRelationAggregateInput? cartItems;

  final _i2.OrderItemOrderByRelationAggregateInput? orderItems;

  final _i2.ReviewOrderByRelationAggregateInput? reviews;

  final _i2.WishlistItemOrderByRelationAggregateInput? wishlistItems;

  final _i2.ProductDiscountOrderByRelationAggregateInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductCategoryOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryOrderByWithRelationInput({
    this.productId,
    this.categoryId,
    this.product,
    this.category,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? categoryId;

  final _i2.ProductOrderByWithRelationInput? product;

  final _i2.CategoryOrderByWithRelationInput? category;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
        'product': product,
        'category': category,
      };
}

class ProductCategoryProductIdCategoryIdCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryProductIdCategoryIdCompoundUniqueInput({
    required this.productId,
    required this.categoryId,
  });

  final int productId;

  final int categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryWhereUniqueInput({
    this.productIdCategoryId,
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.categoryId,
    this.product,
    this.category,
  });

  final _i2.ProductCategoryProductIdCategoryIdCompoundUniqueInput?
      productIdCategoryId;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereInput,
      Iterable<_i2.ProductCategoryWhereInput>>? AND;

  final Iterable<_i2.ProductCategoryWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereInput,
      Iterable<_i2.ProductCategoryWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? categoryId;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  final _i1
      .PrismaUnion<_i2.CategoryScalarRelationFilter, _i2.CategoryWhereInput>?
      category;

  @override
  Map<String, dynamic> toJson() => {
        'productId_categoryId': productIdCategoryId,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'categoryId': categoryId,
        'product': product,
        'category': category,
      };
}

enum ProductCategoryScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  productId<int>('productId', 'ProductCategory'),
  categoryId<int>('categoryId', 'ProductCategory');

  const ProductCategoryScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class CategoryProductsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryProductsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ProductCategoryWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.ProductCategoryOrderByWithRelationInput>,
      _i2.ProductCategoryOrderByWithRelationInput>? orderBy;

  final _i2.ProductCategoryWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ProductCategoryScalar,
      Iterable<_i2.ProductCategoryScalar>>? distinct;

  final _i2.ProductCategorySelect? select;

  final _i2.ProductCategoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class CategoryCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCountOutputTypeSelect({
    this.subcategories,
    this.products,
  });

  final bool? subcategories;

  final bool? products;

  @override
  Map<String, dynamic> toJson() => {
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCountArgs({this.select});

  final _i2.CategoryCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategoryInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryInclude({
    this.parentCategory,
    this.subcategories,
    this.products,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.CategoryParentCategoryArgs>? parentCategory;

  final _i1.PrismaUnion<bool, _i2.CategorySubcategoriesArgs>? subcategories;

  final _i1.PrismaUnion<bool, _i2.CategoryProductsArgs>? products;

  final _i1.PrismaUnion<bool, _i2.CategoryCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'parentCategory': parentCategory,
        'subcategories': subcategories,
        'products': products,
        '_count': $count,
      };
}

class CategorySelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategorySelect({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.subcategories,
    this.products,
    this.$count,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? parentCategoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.CategoryParentCategoryArgs>? parentCategory;

  final _i1.PrismaUnion<bool, _i2.CategorySubcategoriesArgs>? subcategories;

  final _i1.PrismaUnion<bool, _i2.CategoryProductsArgs>? products;

  final _i1.PrismaUnion<bool, _i2.CategoryCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'subcategories': subcategories,
        'products': products,
        '_count': $count,
      };
}

class ProductCategoryCategoryArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCategoryArgs({
    this.select,
    this.include,
  });

  final _i2.CategorySelect? select;

  final _i2.CategoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ProductCategoryInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryInclude({
    this.product,
    this.category,
  });

  final _i1.PrismaUnion<bool, _i2.ProductCategoryProductArgs>? product;

  final _i1.PrismaUnion<bool, _i2.ProductCategoryCategoryArgs>? category;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'category': category,
      };
}

class ProductCategoriesArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoriesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ProductCategoryWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.ProductCategoryOrderByWithRelationInput>,
      _i2.ProductCategoryOrderByWithRelationInput>? orderBy;

  final _i2.ProductCategoryWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ProductCategoryScalar,
      Iterable<_i2.ProductCategoryScalar>>? distinct;

  final _i2.ProductCategorySelect? select;

  final _i2.ProductCategoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ProductImageProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ProductImageSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageSelect({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.product,
  });

  final bool? id;

  final bool? productId;

  final bool? imageUrl;

  final bool? isPrimary;

  final bool? displayOrder;

  final bool? createdAt;

  final _i1.PrismaUnion<bool, _i2.ProductImageProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        'product': product,
      };
}

class ProductImageInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageInclude({this.product});

  final _i1.PrismaUnion<bool, _i2.ProductImageProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {'product': product};
}

class ProductImageOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageOrderByWithRelationInput({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.product,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? imageUrl;

  final _i2.SortOrder? isPrimary;

  final _i2.SortOrder? displayOrder;

  final _i2.SortOrder? createdAt;

  final _i2.ProductOrderByWithRelationInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        'product': product,
      };
}

class ProductImageWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.product,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.ProductImageWhereInput,
      Iterable<_i2.ProductImageWhereInput>>? AND;

  final Iterable<_i2.ProductImageWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductImageWhereInput,
      Iterable<_i2.ProductImageWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? imageUrl;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isPrimary;

  final _i1.PrismaUnion<_i2.IntFilter, int>? displayOrder;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        'product': product,
      };
}

enum ProductImageScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'ProductImage'),
  productId<int>('productId', 'ProductImage'),
  imageUrl<String>('imageUrl', 'ProductImage'),
  isPrimary<bool>('isPrimary', 'ProductImage'),
  displayOrder<int>('displayOrder', 'ProductImage'),
  createdAt<DateTime>('createdAt', 'ProductImage');

  const ProductImageScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProductImagesArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImagesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ProductImageWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.ProductImageOrderByWithRelationInput>,
      _i2.ProductImageOrderByWithRelationInput>? orderBy;

  final _i2.ProductImageWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1
      .PrismaUnion<_i2.ProductImageScalar, Iterable<_i2.ProductImageScalar>>?
      distinct;

  final _i2.ProductImageSelect? select;

  final _i2.ProductImageInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class CartUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class AddressOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class CartOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class OrderOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class WishlistOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class UserOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserOrderByWithRelationInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? firstName;

  final _i2.SortOrder? lastName;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.AddressOrderByRelationAggregateInput? addresses;

  final _i2.CartOrderByRelationAggregateInput? carts;

  final _i2.OrderOrderByRelationAggregateInput? orders;

  final _i2.ReviewOrderByRelationAggregateInput? reviews;

  final _i2.WishlistOrderByRelationAggregateInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class CartOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartOrderByWithRelationInput({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserOrderByWithRelationInput? user;

  final _i2.CartItemOrderByRelationAggregateInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

class CartItemOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemOrderByWithRelationInput({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.cart,
    this.product,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? cartId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtAddition;

  final _i2.SortOrder? addedAt;

  final _i2.CartOrderByWithRelationInput? cart;

  final _i2.ProductOrderByWithRelationInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
        'product': product,
      };
}

class CartItemWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.cart,
    this.product,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.CartItemWhereInput, Iterable<_i2.CartItemWhereInput>>?
      AND;

  final Iterable<_i2.CartItemWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.CartItemWhereInput, Iterable<_i2.CartItemWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? cartId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? quantity;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? priceAtAddition;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? addedAt;

  final _i1.PrismaUnion<_i2.CartScalarRelationFilter, _i2.CartWhereInput>? cart;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
        'product': product,
      };
}

enum CartItemScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'CartItem'),
  cartId<int>('cartId', 'CartItem'),
  productId<int>('productId', 'CartItem'),
  quantity<int>('quantity', 'CartItem'),
  priceAtAddition<_i1.Decimal>('priceAtAddition', 'CartItem'),
  addedAt<DateTime>('addedAt', 'CartItem');

  const CartItemScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class CartItemsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.CartItemWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.CartItemOrderByWithRelationInput>,
      _i2.CartItemOrderByWithRelationInput>? orderBy;

  final _i2.CartItemWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.CartItemScalar, Iterable<_i2.CartItemScalar>>?
      distinct;

  final _i2.CartItemSelect? select;

  final _i2.CartItemInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class CartCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCountOutputTypeSelect({this.items});

  final bool? items;

  @override
  Map<String, dynamic> toJson() => {'items': items};
}

class CartCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCountArgs({this.select});

  final _i2.CartCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartInclude({
    this.user,
    this.items,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.CartUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.CartItemsArgs>? items;

  final _i1.PrismaUnion<bool, _i2.CartCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'user': user,
        'items': items,
        '_count': $count,
      };
}

class CartItemCartArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCartArgs({
    this.select,
    this.include,
  });

  final _i2.CartSelect? select;

  final _i2.CartInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CartItemProductArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CartItemInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemInclude({
    this.cart,
    this.product,
  });

  final _i1.PrismaUnion<bool, _i2.CartItemCartArgs>? cart;

  final _i1.PrismaUnion<bool, _i2.CartItemProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'cart': cart,
        'product': product,
      };
}

class CartSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartSelect({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
    this.$count,
  });

  final bool? id;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.CartUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.CartItemsArgs>? items;

  final _i1.PrismaUnion<bool, _i2.CartCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
        '_count': $count,
      };
}

class CartItemSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemSelect({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.cart,
    this.product,
  });

  final bool? id;

  final bool? cartId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtAddition;

  final bool? addedAt;

  final _i1.PrismaUnion<bool, _i2.CartItemCartArgs>? cart;

  final _i1.PrismaUnion<bool, _i2.CartItemProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
        'product': product,
      };
}

class ProductCartItemsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCartItemsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.CartItemWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.CartItemOrderByWithRelationInput>,
      _i2.CartItemOrderByWithRelationInput>? orderBy;

  final _i2.CartItemWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.CartItemScalar, Iterable<_i2.CartItemScalar>>?
      distinct;

  final _i2.CartItemSelect? select;

  final _i2.CartItemInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class AddressOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressOrderByWithRelationInput({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingOrders,
    this.billingOrders,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? addressLine1;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? addressLine2;

  final _i2.SortOrder? city;

  final _i2.SortOrder? state;

  final _i2.SortOrder? postalCode;

  final _i2.SortOrder? country;

  final _i2.SortOrder? isDefault;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserOrderByWithRelationInput? user;

  final _i2.OrderOrderByRelationAggregateInput? shippingOrders;

  final _i2.OrderOrderByRelationAggregateInput? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class PaymentOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class OrderOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderOrderByWithRelationInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.billingAddress,
    this.items,
    this.payments,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? shippingAddressId;

  final _i2.SortOrder? billingAddressId;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? shippingCost;

  final _i2.SortOrder? totalAmount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentStatus;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserOrderByWithRelationInput? user;

  final _i2.AddressOrderByWithRelationInput? shippingAddress;

  final _i2.AddressOrderByWithRelationInput? billingAddress;

  final _i2.OrderItemOrderByRelationAggregateInput? items;

  final _i2.PaymentOrderByRelationAggregateInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
      };
}

class OrderItemOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemOrderByWithRelationInput({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.order,
    this.product,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtPurchase;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? createdAt;

  final _i2.OrderOrderByWithRelationInput? order;

  final _i2.ProductOrderByWithRelationInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
        'product': product,
      };
}

class OrderItemWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.order,
    this.product,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.OrderItemWhereInput, Iterable<_i2.OrderItemWhereInput>>?
      AND;

  final Iterable<_i2.OrderItemWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.OrderItemWhereInput, Iterable<_i2.OrderItemWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? orderId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? quantity;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? priceAtPurchase;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? subtotal;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.OrderScalarRelationFilter, _i2.OrderWhereInput>?
      order;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
        'product': product,
      };
}

enum OrderItemScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'OrderItem'),
  orderId<int>('orderId', 'OrderItem'),
  productId<int>('productId', 'OrderItem'),
  quantity<int>('quantity', 'OrderItem'),
  priceAtPurchase<_i1.Decimal>('priceAtPurchase', 'OrderItem'),
  subtotal<_i1.Decimal>('subtotal', 'OrderItem'),
  createdAt<DateTime>('createdAt', 'OrderItem');

  const OrderItemScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProductOrderItemsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductOrderItemsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrderItemWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.OrderItemOrderByWithRelationInput>,
      _i2.OrderItemOrderByWithRelationInput>? orderBy;

  final _i2.OrderItemWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrderItemScalar, Iterable<_i2.OrderItemScalar>>?
      distinct;

  final _i2.OrderItemSelect? select;

  final _i2.OrderItemInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ReviewProductArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ReviewUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ReviewSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewSelect({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.product,
    this.user,
  });

  final bool? id;

  final bool? productId;

  final bool? userId;

  final bool? rating;

  final bool? comment;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ReviewProductArgs>? product;

  final _i1.PrismaUnion<bool, _i2.ReviewUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
        'user': user,
      };
}

class ReviewInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewInclude({
    this.product,
    this.user,
  });

  final _i1.PrismaUnion<bool, _i2.ReviewProductArgs>? product;

  final _i1.PrismaUnion<bool, _i2.ReviewUserArgs>? user;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'user': user,
      };
}

class ReviewOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewOrderByWithRelationInput({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.product,
    this.user,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? rating;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? comment;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ProductOrderByWithRelationInput? product;

  final _i2.UserOrderByWithRelationInput? user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
        'user': user,
      };
}

class ReviewWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.product,
    this.user,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.ReviewWhereInput, Iterable<_i2.ReviewWhereInput>>?
      AND;

  final Iterable<_i2.ReviewWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ReviewWhereInput, Iterable<_i2.ReviewWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? rating;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
        'user': user,
      };
}

enum ReviewScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Review'),
  productId<int>('productId', 'Review'),
  userId<int>('userId', 'Review'),
  rating<int>('rating', 'Review'),
  comment<String>('comment', 'Review'),
  createdAt<DateTime>('createdAt', 'Review'),
  updatedAt<DateTime>('updatedAt', 'Review');

  const ReviewScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProductReviewsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductReviewsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ReviewWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.ReviewOrderByWithRelationInput>,
      _i2.ReviewOrderByWithRelationInput>? orderBy;

  final _i2.ReviewWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ReviewScalar, Iterable<_i2.ReviewScalar>>? distinct;

  final _i2.ReviewSelect? select;

  final _i2.ReviewInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class WishlistUserArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class WishlistOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistOrderByWithRelationInput({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserOrderByWithRelationInput? user;

  final _i2.WishlistItemOrderByRelationAggregateInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

class WishlistItemOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemOrderByWithRelationInput({
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.wishlist,
    this.product,
  });

  final _i2.SortOrder? wishlistId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? addedAt;

  final _i2.WishlistOrderByWithRelationInput? wishlist;

  final _i2.ProductOrderByWithRelationInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        'wishlist': wishlist,
        'product': product,
      };
}

class WishlistItemWishlistIdProductIdCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemWishlistIdProductIdCompoundUniqueInput({
    required this.wishlistId,
    required this.productId,
  });

  final int wishlistId;

  final int productId;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
      };
}

class WishlistItemWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemWhereUniqueInput({
    this.wishlistIdProductId,
    this.AND,
    this.OR,
    this.NOT,
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.wishlist,
    this.product,
  });

  final _i2.WishlistItemWishlistIdProductIdCompoundUniqueInput?
      wishlistIdProductId;

  final _i1.PrismaUnion<_i2.WishlistItemWhereInput,
      Iterable<_i2.WishlistItemWhereInput>>? AND;

  final Iterable<_i2.WishlistItemWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WishlistItemWhereInput,
      Iterable<_i2.WishlistItemWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? wishlistId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? addedAt;

  final _i1
      .PrismaUnion<_i2.WishlistScalarRelationFilter, _i2.WishlistWhereInput>?
      wishlist;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId_productId': wishlistIdProductId,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        'wishlist': wishlist,
        'product': product,
      };
}

enum WishlistItemScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  wishlistId<int>('wishlistId', 'WishlistItem'),
  productId<int>('productId', 'WishlistItem'),
  addedAt<DateTime>('addedAt', 'WishlistItem');

  const WishlistItemScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class WishlistItemsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.WishlistItemWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.WishlistItemOrderByWithRelationInput>,
      _i2.WishlistItemOrderByWithRelationInput>? orderBy;

  final _i2.WishlistItemWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1
      .PrismaUnion<_i2.WishlistItemScalar, Iterable<_i2.WishlistItemScalar>>?
      distinct;

  final _i2.WishlistItemSelect? select;

  final _i2.WishlistItemInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class WishlistCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCountOutputTypeSelect({this.items});

  final bool? items;

  @override
  Map<String, dynamic> toJson() => {'items': items};
}

class WishlistCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCountArgs({this.select});

  final _i2.WishlistCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistInclude({
    this.user,
    this.items,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.WishlistUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.WishlistItemsArgs>? items;

  final _i1.PrismaUnion<bool, _i2.WishlistCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'user': user,
        'items': items,
        '_count': $count,
      };
}

class WishlistItemWishlistArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemWishlistArgs({
    this.select,
    this.include,
  });

  final _i2.WishlistSelect? select;

  final _i2.WishlistInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class WishlistItemProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class WishlistItemInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemInclude({
    this.wishlist,
    this.product,
  });

  final _i1.PrismaUnion<bool, _i2.WishlistItemWishlistArgs>? wishlist;

  final _i1.PrismaUnion<bool, _i2.WishlistItemProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'wishlist': wishlist,
        'product': product,
      };
}

class WishlistSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistSelect({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
    this.$count,
  });

  final bool? id;

  final bool? userId;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.WishlistUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.WishlistItemsArgs>? items;

  final _i1.PrismaUnion<bool, _i2.WishlistCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
        '_count': $count,
      };
}

class WishlistItemSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemSelect({
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.wishlist,
    this.product,
  });

  final bool? wishlistId;

  final bool? productId;

  final bool? addedAt;

  final _i1.PrismaUnion<bool, _i2.WishlistItemWishlistArgs>? wishlist;

  final _i1.PrismaUnion<bool, _i2.WishlistItemProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        'wishlist': wishlist,
        'product': product,
      };
}

class ProductWishlistItemsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductWishlistItemsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.WishlistItemWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.WishlistItemOrderByWithRelationInput>,
      _i2.WishlistItemOrderByWithRelationInput>? orderBy;

  final _i2.WishlistItemWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1
      .PrismaUnion<_i2.WishlistItemScalar, Iterable<_i2.WishlistItemScalar>>?
      distinct;

  final _i2.WishlistItemSelect? select;

  final _i2.WishlistItemInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ProductDiscountProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class DiscountOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountOrderByWithRelationInput({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.products,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? code;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? discountType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? usageLimit;

  final _i2.SortOrder? timesUsed;

  final _i2.SortOrder? validFrom;

  final _i2.SortOrder? validTo;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ProductDiscountOrderByRelationAggregateInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
      };
}

class ProductDiscountOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountOrderByWithRelationInput({
    this.productId,
    this.discountId,
    this.product,
    this.discount,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? discountId;

  final _i2.ProductOrderByWithRelationInput? product;

  final _i2.DiscountOrderByWithRelationInput? discount;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
        'product': product,
        'discount': discount,
      };
}

class ProductDiscountProductIdDiscountIdCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountProductIdDiscountIdCompoundUniqueInput({
    required this.productId,
    required this.discountId,
  });

  final int productId;

  final int discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountWhereUniqueInput({
    this.productIdDiscountId,
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.discountId,
    this.product,
    this.discount,
  });

  final _i2.ProductDiscountProductIdDiscountIdCompoundUniqueInput?
      productIdDiscountId;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereInput,
      Iterable<_i2.ProductDiscountWhereInput>>? AND;

  final Iterable<_i2.ProductDiscountWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereInput,
      Iterable<_i2.ProductDiscountWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? discountId;

  final _i1.PrismaUnion<_i2.ProductScalarRelationFilter, _i2.ProductWhereInput>?
      product;

  final _i1
      .PrismaUnion<_i2.DiscountScalarRelationFilter, _i2.DiscountWhereInput>?
      discount;

  @override
  Map<String, dynamic> toJson() => {
        'productId_discountId': productIdDiscountId,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'discountId': discountId,
        'product': product,
        'discount': discount,
      };
}

enum ProductDiscountScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  productId<int>('productId', 'ProductDiscount'),
  discountId<int>('discountId', 'ProductDiscount');

  const ProductDiscountScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class DiscountProductsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountProductsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ProductDiscountWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.ProductDiscountOrderByWithRelationInput>,
      _i2.ProductDiscountOrderByWithRelationInput>? orderBy;

  final _i2.ProductDiscountWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ProductDiscountScalar,
      Iterable<_i2.ProductDiscountScalar>>? distinct;

  final _i2.ProductDiscountSelect? select;

  final _i2.ProductDiscountInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class DiscountCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCountOutputTypeSelect({this.products});

  final bool? products;

  @override
  Map<String, dynamic> toJson() => {'products': products};
}

class DiscountCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCountArgs({this.select});

  final _i2.DiscountCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountInclude({
    this.products,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.DiscountProductsArgs>? products;

  final _i1.PrismaUnion<bool, _i2.DiscountCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'products': products,
        '_count': $count,
      };
}

class ProductDiscountDiscountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountDiscountArgs({
    this.select,
    this.include,
  });

  final _i2.DiscountSelect? select;

  final _i2.DiscountInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ProductDiscountInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountInclude({
    this.product,
    this.discount,
  });

  final _i1.PrismaUnion<bool, _i2.ProductDiscountProductArgs>? product;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountDiscountArgs>? discount;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'discount': discount,
      };
}

class DiscountSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountSelect({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.products,
    this.$count,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? amount;

  final bool? discountType;

  final bool? usageLimit;

  final bool? timesUsed;

  final bool? validFrom;

  final bool? validTo;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.DiscountProductsArgs>? products;

  final _i1.PrismaUnion<bool, _i2.DiscountCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
        '_count': $count,
      };
}

class ProductDiscountSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountSelect({
    this.productId,
    this.discountId,
    this.product,
    this.discount,
  });

  final bool? productId;

  final bool? discountId;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountProductArgs>? product;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountDiscountArgs>? discount;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
        'product': product,
        'discount': discount,
      };
}

class ProductDiscountsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ProductDiscountWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.ProductDiscountOrderByWithRelationInput>,
      _i2.ProductDiscountOrderByWithRelationInput>? orderBy;

  final _i2.ProductDiscountWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ProductDiscountScalar,
      Iterable<_i2.ProductDiscountScalar>>? distinct;

  final _i2.ProductDiscountSelect? select;

  final _i2.ProductDiscountInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ProductCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCountOutputTypeSelect({
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final bool? categories;

  final bool? images;

  final bool? cartItems;

  final bool? orderItems;

  final bool? reviews;

  final bool? wishlistItems;

  final bool? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCountArgs({this.select});

  final _i2.ProductCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductInclude({
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ProductCategoriesArgs>? categories;

  final _i1.PrismaUnion<bool, _i2.ProductImagesArgs>? images;

  final _i1.PrismaUnion<bool, _i2.ProductCartItemsArgs>? cartItems;

  final _i1.PrismaUnion<bool, _i2.ProductOrderItemsArgs>? orderItems;

  final _i1.PrismaUnion<bool, _i2.ProductReviewsArgs>? reviews;

  final _i1.PrismaUnion<bool, _i2.ProductWishlistItemsArgs>? wishlistItems;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountsArgs>? discounts;

  final _i1.PrismaUnion<bool, _i2.ProductCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
        '_count': $count,
      };
}

class ProductCategorySelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategorySelect({
    this.productId,
    this.categoryId,
    this.product,
    this.category,
  });

  final bool? productId;

  final bool? categoryId;

  final _i1.PrismaUnion<bool, _i2.ProductCategoryProductArgs>? product;

  final _i1.PrismaUnion<bool, _i2.ProductCategoryCategoryArgs>? category;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
        'product': product,
        'category': category,
      };
}

class ProductSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductSelect({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
    this.$count,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? price;

  final bool? stockQuantity;

  final bool? sku;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ProductCategoriesArgs>? categories;

  final _i1.PrismaUnion<bool, _i2.ProductImagesArgs>? images;

  final _i1.PrismaUnion<bool, _i2.ProductCartItemsArgs>? cartItems;

  final _i1.PrismaUnion<bool, _i2.ProductOrderItemsArgs>? orderItems;

  final _i1.PrismaUnion<bool, _i2.ProductReviewsArgs>? reviews;

  final _i1.PrismaUnion<bool, _i2.ProductWishlistItemsArgs>? wishlistItems;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountsArgs>? discounts;

  final _i1.PrismaUnion<bool, _i2.ProductCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
        '_count': $count,
      };
}

class OrderItemProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OrderItemInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemInclude({
    this.order,
    this.product,
  });

  final _i1.PrismaUnion<bool, _i2.OrderItemOrderArgs>? order;

  final _i1.PrismaUnion<bool, _i2.OrderItemProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'order': order,
        'product': product,
      };
}

class OrderItemsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrderItemWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.OrderItemOrderByWithRelationInput>,
      _i2.OrderItemOrderByWithRelationInput>? orderBy;

  final _i2.OrderItemWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrderItemScalar, Iterable<_i2.OrderItemScalar>>?
      distinct;

  final _i2.OrderItemSelect? select;

  final _i2.OrderItemInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class PaymentOrderArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentOrderArgs({
    this.select,
    this.include,
  });

  final _i2.OrderSelect? select;

  final _i2.OrderInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class PaymentSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentSelect({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.order,
  });

  final bool? id;

  final bool? orderId;

  final bool? paymentMethod;

  final bool? transactionId;

  final bool? amount;

  final bool? status;

  final bool? paymentDate;

  final _i1.PrismaUnion<bool, _i2.PaymentOrderArgs>? order;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        'order': order,
      };
}

class PaymentInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentInclude({this.order});

  final _i1.PrismaUnion<bool, _i2.PaymentOrderArgs>? order;

  @override
  Map<String, dynamic> toJson() => {'order': order};
}

class PaymentOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentOrderByWithRelationInput({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.order,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? paymentMethod;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? transactionId;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentDate;

  final _i2.OrderOrderByWithRelationInput? order;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        'order': order,
      };
}

class PaymentWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.order,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.PaymentWhereInput, Iterable<_i2.PaymentWhereInput>>?
      AND;

  final Iterable<_i2.PaymentWhereInput>? OR;

  final _i1.PrismaUnion<_i2.PaymentWhereInput, Iterable<_i2.PaymentWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? orderId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentMethod;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? amount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? status;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? paymentDate;

  final _i1.PrismaUnion<_i2.OrderScalarRelationFilter, _i2.OrderWhereInput>?
      order;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        'order': order,
      };
}

enum PaymentScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Payment'),
  orderId<int>('orderId', 'Payment'),
  paymentMethod<String>('paymentMethod', 'Payment'),
  transactionId<String>('transactionId', 'Payment'),
  amount<_i1.Decimal>('amount', 'Payment'),
  status<String>('status', 'Payment'),
  paymentDate<DateTime>('paymentDate', 'Payment');

  const PaymentScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class OrderPaymentsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderPaymentsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.PaymentWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.PaymentOrderByWithRelationInput>,
      _i2.PaymentOrderByWithRelationInput>? orderBy;

  final _i2.PaymentWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.PaymentScalar, Iterable<_i2.PaymentScalar>>?
      distinct;

  final _i2.PaymentSelect? select;

  final _i2.PaymentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class OrderCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCountOutputTypeSelect({
    this.items,
    this.payments,
  });

  final bool? items;

  final bool? payments;

  @override
  Map<String, dynamic> toJson() => {
        'items': items,
        'payments': payments,
      };
}

class OrderCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCountArgs({this.select});

  final _i2.OrderCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderInclude({
    this.user,
    this.shippingAddress,
    this.billingAddress,
    this.items,
    this.payments,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.OrderUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.OrderShippingAddressArgs>? shippingAddress;

  final _i1.PrismaUnion<bool, _i2.OrderBillingAddressArgs>? billingAddress;

  final _i1.PrismaUnion<bool, _i2.OrderItemsArgs>? items;

  final _i1.PrismaUnion<bool, _i2.OrderPaymentsArgs>? payments;

  final _i1.PrismaUnion<bool, _i2.OrderCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
        '_count': $count,
      };
}

class OrderItemSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemSelect({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.order,
    this.product,
  });

  final bool? id;

  final bool? orderId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtPurchase;

  final bool? subtotal;

  final bool? createdAt;

  final _i1.PrismaUnion<bool, _i2.OrderItemOrderArgs>? order;

  final _i1.PrismaUnion<bool, _i2.OrderItemProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
        'product': product,
      };
}

class OrderSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderSelect({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.billingAddress,
    this.items,
    this.payments,
    this.$count,
  });

  final bool? id;

  final bool? userId;

  final bool? shippingAddressId;

  final bool? billingAddressId;

  final bool? subtotal;

  final bool? tax;

  final bool? shippingCost;

  final bool? totalAmount;

  final bool? status;

  final bool? paymentStatus;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.OrderUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.OrderShippingAddressArgs>? shippingAddress;

  final _i1.PrismaUnion<bool, _i2.OrderBillingAddressArgs>? billingAddress;

  final _i1.PrismaUnion<bool, _i2.OrderItemsArgs>? items;

  final _i1.PrismaUnion<bool, _i2.OrderPaymentsArgs>? payments;

  final _i1.PrismaUnion<bool, _i2.OrderCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
        '_count': $count,
      };
}

class OrderWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.billingAddress,
    this.items,
    this.payments,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.OrderWhereInput, Iterable<_i2.OrderWhereInput>>?
      AND;

  final Iterable<_i2.OrderWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OrderWhereInput, Iterable<_i2.OrderWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? shippingAddressId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? billingAddressId;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? subtotal;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? tax;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? shippingCost;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? totalAmount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? status;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentStatus;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  final _i1.PrismaUnion<_i2.AddressScalarRelationFilter, _i2.AddressWhereInput>?
      shippingAddress;

  final _i1.PrismaUnion<_i2.AddressScalarRelationFilter, _i2.AddressWhereInput>?
      billingAddress;

  final _i2.OrderItemListRelationFilter? items;

  final _i2.PaymentListRelationFilter? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
      };
}

enum OrderScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Order'),
  userId<int>('userId', 'Order'),
  shippingAddressId<int>('shippingAddressId', 'Order'),
  billingAddressId<int>('billingAddressId', 'Order'),
  subtotal<_i1.Decimal>('subtotal', 'Order'),
  tax<_i1.Decimal>('tax', 'Order'),
  shippingCost<_i1.Decimal>('shippingCost', 'Order'),
  totalAmount<_i1.Decimal>('totalAmount', 'Order'),
  status<String>('status', 'Order'),
  paymentStatus<String>('paymentStatus', 'Order'),
  createdAt<DateTime>('createdAt', 'Order'),
  updatedAt<DateTime>('updatedAt', 'Order');

  const OrderScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class AddressShippingOrdersArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressShippingOrdersArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrderWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.OrderOrderByWithRelationInput>,
      _i2.OrderOrderByWithRelationInput>? orderBy;

  final _i2.OrderWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrderScalar, Iterable<_i2.OrderScalar>>? distinct;

  final _i2.OrderSelect? select;

  final _i2.OrderInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class AddressBillingOrdersArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressBillingOrdersArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrderWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.OrderOrderByWithRelationInput>,
      _i2.OrderOrderByWithRelationInput>? orderBy;

  final _i2.OrderWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrderScalar, Iterable<_i2.OrderScalar>>? distinct;

  final _i2.OrderSelect? select;

  final _i2.OrderInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class AddressCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCountOutputTypeSelect({
    this.shippingOrders,
    this.billingOrders,
  });

  final bool? shippingOrders;

  final bool? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCountArgs({this.select});

  final _i2.AddressCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AddressInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressInclude({
    this.user,
    this.shippingOrders,
    this.billingOrders,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.AddressUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.AddressShippingOrdersArgs>? shippingOrders;

  final _i1.PrismaUnion<bool, _i2.AddressBillingOrdersArgs>? billingOrders;

  final _i1.PrismaUnion<bool, _i2.AddressCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'user': user,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
        '_count': $count,
      };
}

class AddressWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingOrders,
    this.billingOrders,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.AddressWhereInput, Iterable<_i2.AddressWhereInput>>?
      AND;

  final Iterable<_i2.AddressWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AddressWhereInput, Iterable<_i2.AddressWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? addressLine1;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<_i2.StringFilter, String>? city;

  final _i1.PrismaUnion<_i2.StringFilter, String>? state;

  final _i1.PrismaUnion<_i2.StringFilter, String>? postalCode;

  final _i1.PrismaUnion<_i2.StringFilter, String>? country;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isDefault;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  final _i2.OrderListRelationFilter? shippingOrders;

  final _i2.OrderListRelationFilter? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

enum AddressScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Address'),
  userId<int>('userId', 'Address'),
  addressLine1<String>('addressLine1', 'Address'),
  addressLine2<String>('addressLine2', 'Address'),
  city<String>('city', 'Address'),
  state<String>('state', 'Address'),
  postalCode<String>('postalCode', 'Address'),
  country<String>('country', 'Address'),
  isDefault<bool>('isDefault', 'Address'),
  createdAt<DateTime>('createdAt', 'Address'),
  updatedAt<DateTime>('updatedAt', 'Address');

  const AddressScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class UserAddressesArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserAddressesArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.AddressWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.AddressOrderByWithRelationInput>,
      _i2.AddressOrderByWithRelationInput>? orderBy;

  final _i2.AddressWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.AddressScalar, Iterable<_i2.AddressScalar>>?
      distinct;

  final _i2.AddressSelect? select;

  final _i2.AddressInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class CartWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.CartWhereInput, Iterable<_i2.CartWhereInput>>? AND;

  final Iterable<_i2.CartWhereInput>? OR;

  final _i1.PrismaUnion<_i2.CartWhereInput, Iterable<_i2.CartWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  final _i2.CartItemListRelationFilter? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

enum CartScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Cart'),
  userId<int>('userId', 'Cart'),
  createdAt<DateTime>('createdAt', 'Cart'),
  updatedAt<DateTime>('updatedAt', 'Cart');

  const CartScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class UserCartsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCartsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.CartWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.CartOrderByWithRelationInput>,
      _i2.CartOrderByWithRelationInput>? orderBy;

  final _i2.CartWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.CartScalar, Iterable<_i2.CartScalar>>? distinct;

  final _i2.CartSelect? select;

  final _i2.CartInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UserOrdersArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserOrdersArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrderWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.OrderOrderByWithRelationInput>,
      _i2.OrderOrderByWithRelationInput>? orderBy;

  final _i2.OrderWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrderScalar, Iterable<_i2.OrderScalar>>? distinct;

  final _i2.OrderSelect? select;

  final _i2.OrderInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UserReviewsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserReviewsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ReviewWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.ReviewOrderByWithRelationInput>,
      _i2.ReviewOrderByWithRelationInput>? orderBy;

  final _i2.ReviewWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ReviewScalar, Iterable<_i2.ReviewScalar>>? distinct;

  final _i2.ReviewSelect? select;

  final _i2.ReviewInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class WishlistWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.WishlistWhereInput, Iterable<_i2.WishlistWhereInput>>?
      AND;

  final Iterable<_i2.WishlistWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.WishlistWhereInput, Iterable<_i2.WishlistWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i1.PrismaUnion<_i2.UserScalarRelationFilter, _i2.UserWhereInput>? user;

  final _i2.WishlistItemListRelationFilter? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

enum WishlistScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Wishlist'),
  userId<int>('userId', 'Wishlist'),
  name$<String>('name', 'Wishlist'),
  createdAt<DateTime>('createdAt', 'Wishlist'),
  updatedAt<DateTime>('updatedAt', 'Wishlist');

  const WishlistScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class UserWishlistsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserWishlistsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.WishlistWhereInput? where;

  final _i1.PrismaUnion<Iterable<_i2.WishlistOrderByWithRelationInput>,
      _i2.WishlistOrderByWithRelationInput>? orderBy;

  final _i2.WishlistWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.WishlistScalar, Iterable<_i2.WishlistScalar>>?
      distinct;

  final _i2.WishlistSelect? select;

  final _i2.WishlistInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UserCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountOutputTypeSelect({
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final bool? addresses;

  final bool? carts;

  final bool? orders;

  final bool? reviews;

  final bool? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountArgs({this.select});

  final _i2.UserCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserInclude({
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.UserAddressesArgs>? addresses;

  final _i1.PrismaUnion<bool, _i2.UserCartsArgs>? carts;

  final _i1.PrismaUnion<bool, _i2.UserOrdersArgs>? orders;

  final _i1.PrismaUnion<bool, _i2.UserReviewsArgs>? reviews;

  final _i1.PrismaUnion<bool, _i2.UserWishlistsArgs>? wishlists;

  final _i1.PrismaUnion<bool, _i2.UserCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
        '_count': $count,
      };
}

class AddressSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressSelect({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingOrders,
    this.billingOrders,
    this.$count,
  });

  final bool? id;

  final bool? userId;

  final bool? addressLine1;

  final bool? addressLine2;

  final bool? city;

  final bool? state;

  final bool? postalCode;

  final bool? country;

  final bool? isDefault;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.AddressUserArgs>? user;

  final _i1.PrismaUnion<bool, _i2.AddressShippingOrdersArgs>? shippingOrders;

  final _i1.PrismaUnion<bool, _i2.AddressBillingOrdersArgs>? billingOrders;

  final _i1.PrismaUnion<bool, _i2.AddressCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
        '_count': $count,
      };
}

class UserSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSelect({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
    this.$count,
  });

  final bool? id;

  final bool? email;

  final bool? password;

  final bool? firstName;

  final bool? lastName;

  final bool? phone;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.UserAddressesArgs>? addresses;

  final _i1.PrismaUnion<bool, _i2.UserCartsArgs>? carts;

  final _i1.PrismaUnion<bool, _i2.UserOrdersArgs>? orders;

  final _i1.PrismaUnion<bool, _i2.UserReviewsArgs>? reviews;

  final _i1.PrismaUnion<bool, _i2.UserWishlistsArgs>? wishlists;

  final _i1.PrismaUnion<bool, _i2.UserCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
        '_count': $count,
      };
}

enum UserScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'User'),
  email<String>('email', 'User'),
  password<String>('password', 'User'),
  firstName<String>('firstName', 'User'),
  lastName<String>('lastName', 'User'),
  phone<String>('phone', 'User'),
  createdAt<DateTime>('createdAt', 'User'),
  updatedAt<DateTime>('updatedAt', 'User');

  const UserScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProductImageCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageCreateWithoutProductInput({
    required this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final String imageUrl;

  final bool? isPrimary;

  final int? displayOrder;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageUncheckedCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUncheckedCreateWithoutProductInput({
    this.id,
    required this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final int? id;

  final String imageUrl;

  final bool? isPrimary;

  final int? displayOrder;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageCreateOrConnectWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageCreateOrConnectWithoutProductInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductImageWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductImageCreateWithoutProductInput,
      _i2.ProductImageUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductImageCreateManyProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageCreateManyProductInput({
    this.id,
    required this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final int? id;

  final String imageUrl;

  final bool? isPrimary;

  final int? displayOrder;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageCreateManyProductInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageCreateManyProductInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.ProductImageCreateManyProductInput,
      Iterable<_i2.ProductImageCreateManyProductInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class ProductImageCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductImageCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductImageCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductImageUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductImageUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductImageCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductImageCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.ProductImageCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class AddressCreateWithoutBillingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateWithoutBillingOrdersInput({
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    required this.user,
    this.shippingOrders,
  });

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutAddressesInput user;

  final _i2.OrderCreateNestedManyWithoutShippingAddressInput? shippingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingOrders': shippingOrders,
      };
}

class DiscountCreateWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCreateWithoutProductsInput({
    this.code,
    this.description,
    required this.amount,
    required this.discountType,
    this.usageLimit,
    this.timesUsed,
    required this.validFrom,
    required this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? code;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal amount;

  final String discountType;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? usageLimit;

  final int? timesUsed;

  final DateTime validFrom;

  final DateTime validTo;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountUncheckedCreateWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUncheckedCreateWithoutProductsInput({
    this.id,
    this.code,
    this.description,
    required this.amount,
    required this.discountType,
    this.usageLimit,
    this.timesUsed,
    required this.validFrom,
    required this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? code;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal amount;

  final String discountType;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? usageLimit;

  final int? timesUsed;

  final DateTime validFrom;

  final DateTime validTo;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountWhereUniqueInput({
    this.id,
    this.code,
    this.AND,
    this.OR,
    this.NOT,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.products,
  });

  final int? id;

  final String? code;

  final _i1
      .PrismaUnion<_i2.DiscountWhereInput, Iterable<_i2.DiscountWhereInput>>?
      AND;

  final Iterable<_i2.DiscountWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.DiscountWhereInput, Iterable<_i2.DiscountWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? amount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? discountType;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      usageLimit;

  final _i1.PrismaUnion<_i2.IntFilter, int>? timesUsed;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? validFrom;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? validTo;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isActive;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.ProductDiscountListRelationFilter? products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
      };
}

class DiscountCreateOrConnectWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCreateOrConnectWithoutProductsInput({
    required this.where,
    required this.create,
  });

  final _i2.DiscountWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.DiscountCreateWithoutProductsInput,
      _i2.DiscountUncheckedCreateWithoutProductsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class DiscountCreateNestedOneWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCreateNestedOneWithoutProductsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.DiscountCreateWithoutProductsInput,
      _i2.DiscountUncheckedCreateWithoutProductsInput>? create;

  final _i2.DiscountCreateOrConnectWithoutProductsInput? connectOrCreate;

  final _i2.DiscountWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ProductDiscountCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateWithoutProductInput({required this.discount});

  final _i2.DiscountCreateNestedOneWithoutProductsInput discount;

  @override
  Map<String, dynamic> toJson() => {'discount': discount};
}

class ProductDiscountUncheckedCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedCreateWithoutProductInput(
      {required this.discountId});

  final int discountId;

  @override
  Map<String, dynamic> toJson() => {'discountId': discountId};
}

class ProductDiscountCreateOrConnectWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateOrConnectWithoutProductInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductDiscountWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateWithoutProductInput,
      _i2.ProductDiscountUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductDiscountCreateManyProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateManyProductInput({required this.discountId});

  final int discountId;

  @override
  Map<String, dynamic> toJson() => {'discountId': discountId};
}

class ProductDiscountCreateManyProductInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateManyProductInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.ProductDiscountCreateManyProductInput,
      Iterable<_i2.ProductDiscountCreateManyProductInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class ProductDiscountCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductDiscountCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductDiscountCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductDiscountUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductDiscountUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductDiscountCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.ProductDiscountCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProductCreateWithoutWishlistItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateWithoutWishlistItemsInput({
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.discounts,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryCreateNestedManyWithoutProductInput? categories;

  final _i2.ProductImageCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewCreateNestedManyWithoutProductInput? reviews;

  final _i2.ProductDiscountCreateNestedManyWithoutProductInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'discounts': discounts,
      };
}

class ProductCategoryUncheckedCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedCreateWithoutProductInput(
      {required this.categoryId});

  final int categoryId;

  @override
  Map<String, dynamic> toJson() => {'categoryId': categoryId};
}

class ProductCategoryCreateOrConnectWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateOrConnectWithoutProductInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductCategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateWithoutProductInput,
      _i2.ProductCategoryUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductCategoryCreateManyProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateManyProductInput({required this.categoryId});

  final int categoryId;

  @override
  Map<String, dynamic> toJson() => {'categoryId': categoryId};
}

class ProductCategoryCreateManyProductInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateManyProductInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.ProductCategoryCreateManyProductInput,
      Iterable<_i2.ProductCategoryCreateManyProductInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductCategoryCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductCategoryCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductCategoryUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductCategoryUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductCategoryCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.ProductCategoryCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProductImageUncheckedCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUncheckedCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductImageCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductImageCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductImageUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductImageUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductImageCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductImageCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.ProductImageCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class CartItemUncheckedCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedCreateWithoutProductInput({
    this.id,
    required this.cartId,
    this.quantity,
    required this.priceAtAddition,
    this.addedAt,
  });

  final int? id;

  final int cartId;

  final int? quantity;

  final _i1.Decimal priceAtAddition;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemCreateOrConnectWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateOrConnectWithoutProductInput({
    required this.where,
    required this.create,
  });

  final _i2.CartItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartItemCreateWithoutProductInput,
      _i2.CartItemUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class CartItemCreateManyProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateManyProductInput({
    this.id,
    required this.cartId,
    this.quantity,
    required this.priceAtAddition,
    this.addedAt,
  });

  final int? id;

  final int cartId;

  final int? quantity;

  final _i1.Decimal priceAtAddition;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemCreateManyProductInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateManyProductInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.CartItemCreateManyProductInput,
      Iterable<_i2.CartItemCreateManyProductInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class CartItemUncheckedCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.CartItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.CartItemCreateWithoutProductInput>,
              _i1.PrismaUnion<_i2.CartItemUncheckedCreateWithoutProductInput,
                  Iterable<_i2.CartItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.CartItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.CartItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.CartItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class OrderItemUncheckedCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedCreateWithoutProductInput({
    this.id,
    required this.orderId,
    required this.quantity,
    required this.priceAtPurchase,
    required this.subtotal,
    this.createdAt,
  });

  final int? id;

  final int orderId;

  final int quantity;

  final _i1.Decimal priceAtPurchase;

  final _i1.Decimal subtotal;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemCreateOrConnectWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateOrConnectWithoutProductInput({
    required this.where,
    required this.create,
  });

  final _i2.OrderItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderItemCreateWithoutProductInput,
      _i2.OrderItemUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrderItemCreateManyProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateManyProductInput({
    this.id,
    required this.orderId,
    required this.quantity,
    required this.priceAtPurchase,
    required this.subtotal,
    this.createdAt,
  });

  final int? id;

  final int orderId;

  final int quantity;

  final _i1.Decimal priceAtPurchase;

  final _i1.Decimal subtotal;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemCreateManyProductInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateManyProductInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.OrderItemCreateManyProductInput,
      Iterable<_i2.OrderItemCreateManyProductInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class OrderItemUncheckedCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrderItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderItemCreateWithoutProductInput>,
              _i1.PrismaUnion<_i2.OrderItemUncheckedCreateWithoutProductInput,
                  Iterable<_i2.OrderItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.OrderItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.OrderItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ReviewUncheckedCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedCreateWithoutProductInput({
    this.id,
    required this.userId,
    required this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final int rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewCreateOrConnectWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateOrConnectWithoutProductInput({
    required this.where,
    required this.create,
  });

  final _i2.ReviewWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ReviewCreateWithoutProductInput,
      _i2.ReviewUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ReviewCreateManyProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateManyProductInput({
    this.id,
    required this.userId,
    required this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final int rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewCreateManyProductInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateManyProductInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.ReviewCreateManyProductInput,
      Iterable<_i2.ReviewCreateManyProductInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class ReviewUncheckedCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.ReviewCreateWithoutProductInput,
      _i1.PrismaUnion<
          Iterable<_i2.ReviewCreateWithoutProductInput>,
          _i1.PrismaUnion<_i2.ReviewUncheckedCreateWithoutProductInput,
              Iterable<_i2.ReviewUncheckedCreateWithoutProductInput>>>>? create;

  final _i1.PrismaUnion<_i2.ReviewCreateOrConnectWithoutProductInput,
      Iterable<_i2.ReviewCreateOrConnectWithoutProductInput>>? connectOrCreate;

  final _i2.ReviewCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProductDiscountUncheckedCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductDiscountCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductDiscountCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductDiscountUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductDiscountUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductDiscountCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.ProductDiscountCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProductUncheckedCreateWithoutWishlistItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedCreateWithoutWishlistItemsInput({
    this.id,
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.discounts,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutProductInput?
      categories;

  final _i2.ProductImageUncheckedCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemUncheckedCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewUncheckedCreateNestedManyWithoutProductInput? reviews;

  final _i2.ProductDiscountUncheckedCreateNestedManyWithoutProductInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'discounts': discounts,
      };
}

class ProductWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductWhereUniqueInput({
    this.id,
    this.sku,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final int? id;

  final String? sku;

  final _i1.PrismaUnion<_i2.ProductWhereInput, Iterable<_i2.ProductWhereInput>>?
      AND;

  final Iterable<_i2.ProductWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductWhereInput, Iterable<_i2.ProductWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? price;

  final _i1.PrismaUnion<_i2.IntFilter, int>? stockQuantity;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isActive;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  final _i2.ProductCategoryListRelationFilter? categories;

  final _i2.ProductImageListRelationFilter? images;

  final _i2.CartItemListRelationFilter? cartItems;

  final _i2.OrderItemListRelationFilter? orderItems;

  final _i2.ReviewListRelationFilter? reviews;

  final _i2.WishlistItemListRelationFilter? wishlistItems;

  final _i2.ProductDiscountListRelationFilter? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'sku': sku,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductCreateOrConnectWithoutWishlistItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateOrConnectWithoutWishlistItemsInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutWishlistItemsInput,
      _i2.ProductUncheckedCreateWithoutWishlistItemsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductCreateNestedOneWithoutWishlistItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateNestedOneWithoutWishlistItemsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutWishlistItemsInput,
      _i2.ProductUncheckedCreateWithoutWishlistItemsInput>? create;

  final _i2.ProductCreateOrConnectWithoutWishlistItemsInput? connectOrCreate;

  final _i2.ProductWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class WishlistItemCreateWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateWithoutWishlistInput({
    this.addedAt,
    required this.product,
  });

  final DateTime? addedAt;

  final _i2.ProductCreateNestedOneWithoutWishlistItemsInput product;

  @override
  Map<String, dynamic> toJson() => {
        'addedAt': addedAt,
        'product': product,
      };
}

class WishlistItemUncheckedCreateWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedCreateWithoutWishlistInput({
    required this.productId,
    this.addedAt,
  });

  final int productId;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemCreateOrConnectWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateOrConnectWithoutWishlistInput({
    required this.where,
    required this.create,
  });

  final _i2.WishlistItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistItemCreateWithoutWishlistInput,
      _i2.WishlistItemUncheckedCreateWithoutWishlistInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class WishlistItemCreateManyWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateManyWishlistInput({
    required this.productId,
    this.addedAt,
  });

  final int productId;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemCreateManyWishlistInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateManyWishlistInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.WishlistItemCreateManyWishlistInput,
      Iterable<_i2.WishlistItemCreateManyWishlistInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class WishlistItemCreateNestedManyWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateNestedManyWithoutWishlistInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.WishlistItemCreateWithoutWishlistInput,
          _i1.PrismaUnion<
              Iterable<_i2.WishlistItemCreateWithoutWishlistInput>,
              _i1.PrismaUnion<
                  _i2.WishlistItemUncheckedCreateWithoutWishlistInput,
                  Iterable<
                      _i2.WishlistItemUncheckedCreateWithoutWishlistInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.WishlistItemCreateOrConnectWithoutWishlistInput,
          Iterable<_i2.WishlistItemCreateOrConnectWithoutWishlistInput>>?
      connectOrCreate;

  final _i2.WishlistItemCreateManyWishlistInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class WishlistCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateWithoutUserInput({
    this.name,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WishlistItemCreateNestedManyWithoutWishlistInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class WishlistItemUncheckedCreateNestedManyWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedCreateNestedManyWithoutWishlistInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.WishlistItemCreateWithoutWishlistInput,
          _i1.PrismaUnion<
              Iterable<_i2.WishlistItemCreateWithoutWishlistInput>,
              _i1.PrismaUnion<
                  _i2.WishlistItemUncheckedCreateWithoutWishlistInput,
                  Iterable<
                      _i2.WishlistItemUncheckedCreateWithoutWishlistInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.WishlistItemCreateOrConnectWithoutWishlistInput,
          Iterable<_i2.WishlistItemCreateOrConnectWithoutWishlistInput>>?
      connectOrCreate;

  final _i2.WishlistItemCreateManyWishlistInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class WishlistUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedCreateWithoutUserInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final int? id;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WishlistItemUncheckedCreateNestedManyWithoutWishlistInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class WishlistCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.WishlistWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistCreateWithoutUserInput,
      _i2.WishlistUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class WishlistCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateManyUserInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateManyUserInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.WishlistCreateManyUserInput,
      Iterable<_i2.WishlistCreateManyUserInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class WishlistCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.WishlistCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.WishlistCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.WishlistUncheckedCreateWithoutUserInput,
              Iterable<_i2.WishlistUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.WishlistCreateOrConnectWithoutUserInput,
      Iterable<_i2.WishlistCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.WishlistCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UserCreateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutReviewsInput({
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.wishlists,
  });

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressCreateNestedManyWithoutUserInput? addresses;

  final _i2.CartCreateNestedManyWithoutUserInput? carts;

  final _i2.OrderCreateNestedManyWithoutUserInput? orders;

  final _i2.WishlistCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'wishlists': wishlists,
      };
}

class OrderItemUncheckedCreateWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedCreateWithoutOrderInput({
    this.id,
    required this.productId,
    required this.quantity,
    required this.priceAtPurchase,
    required this.subtotal,
    this.createdAt,
  });

  final int? id;

  final int productId;

  final int quantity;

  final _i1.Decimal priceAtPurchase;

  final _i1.Decimal subtotal;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemCreateOrConnectWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateOrConnectWithoutOrderInput({
    required this.where,
    required this.create,
  });

  final _i2.OrderItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderItemCreateWithoutOrderInput,
      _i2.OrderItemUncheckedCreateWithoutOrderInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrderItemCreateManyOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateManyOrderInput({
    this.id,
    required this.productId,
    required this.quantity,
    required this.priceAtPurchase,
    required this.subtotal,
    this.createdAt,
  });

  final int? id;

  final int productId;

  final int quantity;

  final _i1.Decimal priceAtPurchase;

  final _i1.Decimal subtotal;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemCreateManyOrderInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateManyOrderInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.OrderItemCreateManyOrderInput,
      Iterable<_i2.OrderItemCreateManyOrderInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class OrderItemCreateNestedManyWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateNestedManyWithoutOrderInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrderItemCreateWithoutOrderInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderItemCreateWithoutOrderInput>,
              _i1.PrismaUnion<_i2.OrderItemUncheckedCreateWithoutOrderInput,
                  Iterable<_i2.OrderItemUncheckedCreateWithoutOrderInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderItemCreateOrConnectWithoutOrderInput,
      Iterable<_i2.OrderItemCreateOrConnectWithoutOrderInput>>? connectOrCreate;

  final _i2.OrderItemCreateManyOrderInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class PaymentCreateWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateWithoutOrderInput({
    required this.paymentMethod,
    this.transactionId,
    required this.amount,
    required this.status,
    this.paymentDate,
  });

  final String paymentMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? transactionId;

  final _i1.Decimal amount;

  final String status;

  final DateTime? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentUncheckedCreateWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateWithoutOrderInput({
    this.id,
    required this.paymentMethod,
    this.transactionId,
    required this.amount,
    required this.status,
    this.paymentDate,
  });

  final int? id;

  final String paymentMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? transactionId;

  final _i1.Decimal amount;

  final String status;

  final DateTime? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentCreateOrConnectWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateOrConnectWithoutOrderInput({
    required this.where,
    required this.create,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PaymentCreateWithoutOrderInput,
      _i2.PaymentUncheckedCreateWithoutOrderInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class PaymentCreateManyOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyOrderInput({
    this.id,
    required this.paymentMethod,
    this.transactionId,
    required this.amount,
    required this.status,
    this.paymentDate,
  });

  final int? id;

  final String paymentMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? transactionId;

  final _i1.Decimal amount;

  final String status;

  final DateTime? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentCreateManyOrderInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyOrderInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.PaymentCreateManyOrderInput,
      Iterable<_i2.PaymentCreateManyOrderInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class PaymentCreateNestedManyWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateNestedManyWithoutOrderInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.PaymentCreateWithoutOrderInput,
      _i1.PrismaUnion<
          Iterable<_i2.PaymentCreateWithoutOrderInput>,
          _i1.PrismaUnion<_i2.PaymentUncheckedCreateWithoutOrderInput,
              Iterable<_i2.PaymentUncheckedCreateWithoutOrderInput>>>>? create;

  final _i1.PrismaUnion<_i2.PaymentCreateOrConnectWithoutOrderInput,
      Iterable<_i2.PaymentCreateOrConnectWithoutOrderInput>>? connectOrCreate;

  final _i2.PaymentCreateManyOrderInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class OrderCreateWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateWithoutBillingAddressInput({
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    required this.user,
    required this.shippingAddress,
    this.items,
    this.payments,
  });

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutOrdersInput user;

  final _i2.AddressCreateNestedOneWithoutShippingOrdersInput shippingAddress;

  final _i2.OrderItemCreateNestedManyWithoutOrderInput? items;

  final _i2.PaymentCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'items': items,
        'payments': payments,
      };
}

class PaymentUncheckedCreateNestedManyWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateNestedManyWithoutOrderInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.PaymentCreateWithoutOrderInput,
      _i1.PrismaUnion<
          Iterable<_i2.PaymentCreateWithoutOrderInput>,
          _i1.PrismaUnion<_i2.PaymentUncheckedCreateWithoutOrderInput,
              Iterable<_i2.PaymentUncheckedCreateWithoutOrderInput>>>>? create;

  final _i1.PrismaUnion<_i2.PaymentCreateOrConnectWithoutOrderInput,
      Iterable<_i2.PaymentCreateOrConnectWithoutOrderInput>>? connectOrCreate;

  final _i2.PaymentCreateManyOrderInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class OrderUncheckedCreateWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedCreateWithoutBillingAddressInput({
    this.id,
    required this.userId,
    required this.shippingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
    this.payments,
  });

  final int? id;

  final int userId;

  final int shippingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutOrderInput? items;

  final _i2.PaymentUncheckedCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
        'payments': payments,
      };
}

class OrderCreateOrConnectWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateOrConnectWithoutBillingAddressInput({
    required this.where,
    required this.create,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutBillingAddressInput,
      _i2.OrderUncheckedCreateWithoutBillingAddressInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrderCreateManyBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateManyBillingAddressInput({
    this.id,
    required this.userId,
    required this.shippingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final int shippingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderCreateManyBillingAddressInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateManyBillingAddressInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.OrderCreateManyBillingAddressInput,
      Iterable<_i2.OrderCreateManyBillingAddressInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class OrderUncheckedCreateNestedManyWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedCreateNestedManyWithoutBillingAddressInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrderCreateWithoutBillingAddressInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderCreateWithoutBillingAddressInput>,
              _i1.PrismaUnion<
                  _i2.OrderUncheckedCreateWithoutBillingAddressInput,
                  Iterable<
                      _i2.OrderUncheckedCreateWithoutBillingAddressInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutBillingAddressInput,
          Iterable<_i2.OrderCreateOrConnectWithoutBillingAddressInput>>?
      connectOrCreate;

  final _i2.OrderCreateManyBillingAddressInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class AddressUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedCreateWithoutUserInput({
    this.id,
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.shippingOrders,
    this.billingOrders,
  });

  final int? id;

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderUncheckedCreateNestedManyWithoutShippingAddressInput?
      shippingOrders;

  final _i2.OrderUncheckedCreateNestedManyWithoutBillingAddressInput?
      billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.AddressWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.AddressCreateWithoutUserInput,
      _i2.AddressUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class AddressCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateManyUserInput({
    this.id,
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateManyUserInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.AddressCreateManyUserInput,
      Iterable<_i2.AddressCreateManyUserInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class AddressUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.AddressCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.AddressCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.AddressUncheckedCreateWithoutUserInput,
              Iterable<_i2.AddressUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.AddressCreateOrConnectWithoutUserInput,
      Iterable<_i2.AddressCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.AddressCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class CartItemUncheckedCreateWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedCreateWithoutCartInput({
    this.id,
    required this.productId,
    this.quantity,
    required this.priceAtAddition,
    this.addedAt,
  });

  final int? id;

  final int productId;

  final int? quantity;

  final _i1.Decimal priceAtAddition;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemCreateOrConnectWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateOrConnectWithoutCartInput({
    required this.where,
    required this.create,
  });

  final _i2.CartItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartItemCreateWithoutCartInput,
      _i2.CartItemUncheckedCreateWithoutCartInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class CartItemCreateManyCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateManyCartInput({
    this.id,
    required this.productId,
    this.quantity,
    required this.priceAtAddition,
    this.addedAt,
  });

  final int? id;

  final int productId;

  final int? quantity;

  final _i1.Decimal priceAtAddition;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemCreateManyCartInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateManyCartInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.CartItemCreateManyCartInput,
      Iterable<_i2.CartItemCreateManyCartInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class CartItemUncheckedCreateNestedManyWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedCreateNestedManyWithoutCartInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.CartItemCreateWithoutCartInput,
      _i1.PrismaUnion<
          Iterable<_i2.CartItemCreateWithoutCartInput>,
          _i1.PrismaUnion<_i2.CartItemUncheckedCreateWithoutCartInput,
              Iterable<_i2.CartItemUncheckedCreateWithoutCartInput>>>>? create;

  final _i1.PrismaUnion<_i2.CartItemCreateOrConnectWithoutCartInput,
      Iterable<_i2.CartItemCreateOrConnectWithoutCartInput>>? connectOrCreate;

  final _i2.CartItemCreateManyCartInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class CartUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedCreateWithoutUserInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final int? id;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CartItemUncheckedCreateNestedManyWithoutCartInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class CartCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.CartWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartCreateWithoutUserInput,
      _i2.CartUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class CartCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateManyUserInput({
    this.id,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateManyUserInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.CartCreateManyUserInput,
      Iterable<_i2.CartCreateManyUserInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class CartUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.CartCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.CartCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.CartUncheckedCreateWithoutUserInput,
              Iterable<_i2.CartUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.CartCreateOrConnectWithoutUserInput,
      Iterable<_i2.CartCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.CartCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class OrderUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedCreateWithoutUserInput({
    this.id,
    required this.shippingAddressId,
    required this.billingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
    this.payments,
  });

  final int? id;

  final int shippingAddressId;

  final int billingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutOrderInput? items;

  final _i2.PaymentUncheckedCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
        'payments': payments,
      };
}

class OrderCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutUserInput,
      _i2.OrderUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrderCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateManyUserInput({
    this.id,
    required this.shippingAddressId,
    required this.billingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int shippingAddressId;

  final int billingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateManyUserInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.OrderCreateManyUserInput,
      Iterable<_i2.OrderCreateManyUserInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class OrderUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OrderCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrderCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.OrderUncheckedCreateWithoutUserInput,
              Iterable<_i2.OrderUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutUserInput,
      Iterable<_i2.OrderCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.OrderCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class WishlistUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.WishlistCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.WishlistCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.WishlistUncheckedCreateWithoutUserInput,
              Iterable<_i2.WishlistUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.WishlistCreateOrConnectWithoutUserInput,
      Iterable<_i2.WishlistCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.WishlistCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UserUncheckedCreateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutReviewsInput({
    this.id,
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.wishlists,
  });

  final int? id;

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressUncheckedCreateNestedManyWithoutUserInput? addresses;

  final _i2.CartUncheckedCreateNestedManyWithoutUserInput? carts;

  final _i2.OrderUncheckedCreateNestedManyWithoutUserInput? orders;

  final _i2.WishlistUncheckedCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'wishlists': wishlists,
      };
}

class UserCreateOrConnectWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutReviewsInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UserCreateWithoutReviewsInput,
      _i2.UserUncheckedCreateWithoutReviewsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UserCreateNestedOneWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutReviewsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutReviewsInput,
      _i2.UserUncheckedCreateWithoutReviewsInput>? create;

  final _i2.UserCreateOrConnectWithoutReviewsInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ReviewCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateWithoutProductInput({
    required this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    required this.user,
  });

  final int rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutReviewsInput user;

  @override
  Map<String, dynamic> toJson() => {
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class ReviewCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.ReviewCreateWithoutProductInput,
      _i1.PrismaUnion<
          Iterable<_i2.ReviewCreateWithoutProductInput>,
          _i1.PrismaUnion<_i2.ReviewUncheckedCreateWithoutProductInput,
              Iterable<_i2.ReviewUncheckedCreateWithoutProductInput>>>>? create;

  final _i1.PrismaUnion<_i2.ReviewCreateOrConnectWithoutProductInput,
      Iterable<_i2.ReviewCreateOrConnectWithoutProductInput>>? connectOrCreate;

  final _i2.ReviewCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UserCreateWithoutWishlistsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutWishlistsInput({
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
  });

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressCreateNestedManyWithoutUserInput? addresses;

  final _i2.CartCreateNestedManyWithoutUserInput? carts;

  final _i2.OrderCreateNestedManyWithoutUserInput? orders;

  final _i2.ReviewCreateNestedManyWithoutUserInput? reviews;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
      };
}

class ReviewUncheckedCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedCreateWithoutUserInput({
    this.id,
    required this.productId,
    required this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int productId;

  final int rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewCreateOrConnectWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  final _i2.ReviewWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ReviewCreateWithoutUserInput,
      _i2.ReviewUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ReviewCreateManyUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateManyUserInput({
    this.id,
    required this.productId,
    required this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int productId;

  final int rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewCreateManyUserInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateManyUserInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.ReviewCreateManyUserInput,
      Iterable<_i2.ReviewCreateManyUserInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class ReviewUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.ReviewCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.ReviewCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.ReviewUncheckedCreateWithoutUserInput,
              Iterable<_i2.ReviewUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.ReviewCreateOrConnectWithoutUserInput,
      Iterable<_i2.ReviewCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.ReviewCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UserUncheckedCreateWithoutWishlistsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutWishlistsInput({
    this.id,
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
  });

  final int? id;

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressUncheckedCreateNestedManyWithoutUserInput? addresses;

  final _i2.CartUncheckedCreateNestedManyWithoutUserInput? carts;

  final _i2.OrderUncheckedCreateNestedManyWithoutUserInput? orders;

  final _i2.ReviewUncheckedCreateNestedManyWithoutUserInput? reviews;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
      };
}

class UserCreateOrConnectWithoutWishlistsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutWishlistsInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UserCreateWithoutWishlistsInput,
      _i2.UserUncheckedCreateWithoutWishlistsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UserCreateNestedOneWithoutWishlistsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutWishlistsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutWishlistsInput,
      _i2.UserUncheckedCreateWithoutWishlistsInput>? create;

  final _i2.UserCreateOrConnectWithoutWishlistsInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class WishlistCreateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateWithoutItemsInput({
    this.name,
    this.createdAt,
    this.updatedAt,
    required this.user,
  });

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutWishlistsInput user;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class WishlistUncheckedCreateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedCreateWithoutItemsInput({
    this.id,
    required this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistCreateOrConnectWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateOrConnectWithoutItemsInput({
    required this.where,
    required this.create,
  });

  final _i2.WishlistWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistCreateWithoutItemsInput,
      _i2.WishlistUncheckedCreateWithoutItemsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class WishlistCreateNestedOneWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateNestedOneWithoutItemsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.WishlistCreateWithoutItemsInput,
      _i2.WishlistUncheckedCreateWithoutItemsInput>? create;

  final _i2.WishlistCreateOrConnectWithoutItemsInput? connectOrCreate;

  final _i2.WishlistWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class WishlistItemCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateWithoutProductInput({
    this.addedAt,
    required this.wishlist,
  });

  final DateTime? addedAt;

  final _i2.WishlistCreateNestedOneWithoutItemsInput wishlist;

  @override
  Map<String, dynamic> toJson() => {
        'addedAt': addedAt,
        'wishlist': wishlist,
      };
}

class WishlistItemUncheckedCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedCreateWithoutProductInput({
    required this.wishlistId,
    this.addedAt,
  });

  final int wishlistId;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'addedAt': addedAt,
      };
}

class WishlistItemCreateOrConnectWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateOrConnectWithoutProductInput({
    required this.where,
    required this.create,
  });

  final _i2.WishlistItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistItemCreateWithoutProductInput,
      _i2.WishlistItemUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class WishlistItemCreateManyProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateManyProductInput({
    required this.wishlistId,
    this.addedAt,
  });

  final int wishlistId;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'addedAt': addedAt,
      };
}

class WishlistItemCreateManyProductInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateManyProductInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.WishlistItemCreateManyProductInput,
      Iterable<_i2.WishlistItemCreateManyProductInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class WishlistItemCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.WishlistItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.WishlistItemCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.WishlistItemUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.WishlistItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.WishlistItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.WishlistItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.WishlistItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProductCreateWithoutOrderItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateWithoutOrderItemsInput({
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryCreateNestedManyWithoutProductInput? categories;

  final _i2.ProductImageCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemCreateNestedManyWithoutProductInput? cartItems;

  final _i2.ReviewCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemCreateNestedManyWithoutProductInput? wishlistItems;

  final _i2.ProductDiscountCreateNestedManyWithoutProductInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class WishlistItemUncheckedCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.WishlistItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.WishlistItemCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.WishlistItemUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.WishlistItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.WishlistItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.WishlistItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.WishlistItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProductUncheckedCreateWithoutOrderItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedCreateWithoutOrderItemsInput({
    this.id,
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutProductInput?
      categories;

  final _i2.ProductImageUncheckedCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemUncheckedCreateNestedManyWithoutProductInput? cartItems;

  final _i2.ReviewUncheckedCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemUncheckedCreateNestedManyWithoutProductInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedCreateNestedManyWithoutProductInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductCreateOrConnectWithoutOrderItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateOrConnectWithoutOrderItemsInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutOrderItemsInput,
      _i2.ProductUncheckedCreateWithoutOrderItemsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductCreateNestedOneWithoutOrderItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateNestedOneWithoutOrderItemsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutOrderItemsInput,
      _i2.ProductUncheckedCreateWithoutOrderItemsInput>? create;

  final _i2.ProductCreateOrConnectWithoutOrderItemsInput? connectOrCreate;

  final _i2.ProductWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrderItemCreateWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateWithoutOrderInput({
    required this.quantity,
    required this.priceAtPurchase,
    required this.subtotal,
    this.createdAt,
    required this.product,
  });

  final int quantity;

  final _i1.Decimal priceAtPurchase;

  final _i1.Decimal subtotal;

  final DateTime? createdAt;

  final _i2.ProductCreateNestedOneWithoutOrderItemsInput product;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'product': product,
      };
}

class OrderItemUncheckedCreateNestedManyWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedCreateNestedManyWithoutOrderInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrderItemCreateWithoutOrderInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderItemCreateWithoutOrderInput>,
              _i1.PrismaUnion<_i2.OrderItemUncheckedCreateWithoutOrderInput,
                  Iterable<_i2.OrderItemUncheckedCreateWithoutOrderInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderItemCreateOrConnectWithoutOrderInput,
      Iterable<_i2.OrderItemCreateOrConnectWithoutOrderInput>>? connectOrCreate;

  final _i2.OrderItemCreateManyOrderInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class OrderUncheckedCreateWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedCreateWithoutShippingAddressInput({
    this.id,
    required this.userId,
    required this.billingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
    this.payments,
  });

  final int? id;

  final int userId;

  final int billingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutOrderInput? items;

  final _i2.PaymentUncheckedCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
        'payments': payments,
      };
}

class OrderCreateOrConnectWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateOrConnectWithoutShippingAddressInput({
    required this.where,
    required this.create,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutShippingAddressInput,
      _i2.OrderUncheckedCreateWithoutShippingAddressInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrderCreateManyShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateManyShippingAddressInput({
    this.id,
    required this.userId,
    required this.billingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final int billingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderCreateManyShippingAddressInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateManyShippingAddressInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.OrderCreateManyShippingAddressInput,
      Iterable<_i2.OrderCreateManyShippingAddressInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class OrderUncheckedCreateNestedManyWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedCreateNestedManyWithoutShippingAddressInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrderCreateWithoutShippingAddressInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderCreateWithoutShippingAddressInput>,
              _i1.PrismaUnion<
                  _i2.OrderUncheckedCreateWithoutShippingAddressInput,
                  Iterable<
                      _i2.OrderUncheckedCreateWithoutShippingAddressInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutShippingAddressInput,
          Iterable<_i2.OrderCreateOrConnectWithoutShippingAddressInput>>?
      connectOrCreate;

  final _i2.OrderCreateManyShippingAddressInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class AddressUncheckedCreateWithoutBillingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedCreateWithoutBillingOrdersInput({
    this.id,
    required this.userId,
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.shippingOrders,
  });

  final int? id;

  final int userId;

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderUncheckedCreateNestedManyWithoutShippingAddressInput?
      shippingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingOrders': shippingOrders,
      };
}

class AddressCreateOrConnectWithoutBillingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateOrConnectWithoutBillingOrdersInput({
    required this.where,
    required this.create,
  });

  final _i2.AddressWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.AddressCreateWithoutBillingOrdersInput,
      _i2.AddressUncheckedCreateWithoutBillingOrdersInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class AddressCreateNestedOneWithoutBillingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateNestedOneWithoutBillingOrdersInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.AddressCreateWithoutBillingOrdersInput,
      _i2.AddressUncheckedCreateWithoutBillingOrdersInput>? create;

  final _i2.AddressCreateOrConnectWithoutBillingOrdersInput? connectOrCreate;

  final _i2.AddressWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrderCreateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateWithoutItemsInput({
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    required this.user,
    required this.shippingAddress,
    required this.billingAddress,
    this.payments,
  });

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutOrdersInput user;

  final _i2.AddressCreateNestedOneWithoutShippingOrdersInput shippingAddress;

  final _i2.AddressCreateNestedOneWithoutBillingOrdersInput billingAddress;

  final _i2.PaymentCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'payments': payments,
      };
}

class OrderUncheckedCreateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedCreateWithoutItemsInput({
    this.id,
    required this.userId,
    required this.shippingAddressId,
    required this.billingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.payments,
  });

  final int? id;

  final int userId;

  final int shippingAddressId;

  final int billingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.PaymentUncheckedCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'payments': payments,
      };
}

class OrderCreateOrConnectWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateOrConnectWithoutItemsInput({
    required this.where,
    required this.create,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutItemsInput,
      _i2.OrderUncheckedCreateWithoutItemsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrderCreateNestedOneWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateNestedOneWithoutItemsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.OrderCreateWithoutItemsInput,
      _i2.OrderUncheckedCreateWithoutItemsInput>? create;

  final _i2.OrderCreateOrConnectWithoutItemsInput? connectOrCreate;

  final _i2.OrderWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrderItemCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateWithoutProductInput({
    required this.quantity,
    required this.priceAtPurchase,
    required this.subtotal,
    this.createdAt,
    required this.order,
  });

  final int quantity;

  final _i1.Decimal priceAtPurchase;

  final _i1.Decimal subtotal;

  final DateTime? createdAt;

  final _i2.OrderCreateNestedOneWithoutItemsInput order;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
      };
}

class OrderItemCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrderItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderItemCreateWithoutProductInput>,
              _i1.PrismaUnion<_i2.OrderItemUncheckedCreateWithoutProductInput,
                  Iterable<_i2.OrderItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.OrderItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.OrderItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProductCreateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateWithoutReviewsInput({
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.wishlistItems,
    this.discounts,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryCreateNestedManyWithoutProductInput? categories;

  final _i2.ProductImageCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemCreateNestedManyWithoutProductInput? orderItems;

  final _i2.WishlistItemCreateNestedManyWithoutProductInput? wishlistItems;

  final _i2.ProductDiscountCreateNestedManyWithoutProductInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedCreateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedCreateWithoutReviewsInput({
    this.id,
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.wishlistItems,
    this.discounts,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutProductInput?
      categories;

  final _i2.ProductImageUncheckedCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemUncheckedCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutProductInput? orderItems;

  final _i2.WishlistItemUncheckedCreateNestedManyWithoutProductInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedCreateNestedManyWithoutProductInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductCreateOrConnectWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateOrConnectWithoutReviewsInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutReviewsInput,
      _i2.ProductUncheckedCreateWithoutReviewsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductCreateNestedOneWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateNestedOneWithoutReviewsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutReviewsInput,
      _i2.ProductUncheckedCreateWithoutReviewsInput>? create;

  final _i2.ProductCreateOrConnectWithoutReviewsInput? connectOrCreate;

  final _i2.ProductWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ReviewCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateWithoutUserInput({
    required this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    required this.product,
  });

  final int rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCreateNestedOneWithoutReviewsInput product;

  @override
  Map<String, dynamic> toJson() => {
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
      };
}

class ReviewCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.ReviewCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.ReviewCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.ReviewUncheckedCreateWithoutUserInput,
              Iterable<_i2.ReviewUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.ReviewCreateOrConnectWithoutUserInput,
      Iterable<_i2.ReviewCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.ReviewCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UserCreateWithoutAddressesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutAddressesInput({
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CartCreateNestedManyWithoutUserInput? carts;

  final _i2.OrderCreateNestedManyWithoutUserInput? orders;

  final _i2.ReviewCreateNestedManyWithoutUserInput? reviews;

  final _i2.WishlistCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUncheckedCreateWithoutAddressesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutAddressesInput({
    this.id,
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final int? id;

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CartUncheckedCreateNestedManyWithoutUserInput? carts;

  final _i2.OrderUncheckedCreateNestedManyWithoutUserInput? orders;

  final _i2.ReviewUncheckedCreateNestedManyWithoutUserInput? reviews;

  final _i2.WishlistUncheckedCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserCreateOrConnectWithoutAddressesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutAddressesInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UserCreateWithoutAddressesInput,
      _i2.UserUncheckedCreateWithoutAddressesInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UserCreateNestedOneWithoutAddressesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutAddressesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutAddressesInput,
      _i2.UserUncheckedCreateWithoutAddressesInput>? create;

  final _i2.UserCreateOrConnectWithoutAddressesInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrderCreateNestedManyWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateNestedManyWithoutBillingAddressInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrderCreateWithoutBillingAddressInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderCreateWithoutBillingAddressInput>,
              _i1.PrismaUnion<
                  _i2.OrderUncheckedCreateWithoutBillingAddressInput,
                  Iterable<
                      _i2.OrderUncheckedCreateWithoutBillingAddressInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutBillingAddressInput,
          Iterable<_i2.OrderCreateOrConnectWithoutBillingAddressInput>>?
      connectOrCreate;

  final _i2.OrderCreateManyBillingAddressInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class AddressCreateWithoutShippingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateWithoutShippingOrdersInput({
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    required this.user,
    this.billingOrders,
  });

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutAddressesInput user;

  final _i2.OrderCreateNestedManyWithoutBillingAddressInput? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'billingOrders': billingOrders,
      };
}

class AddressUncheckedCreateWithoutShippingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedCreateWithoutShippingOrdersInput({
    this.id,
    required this.userId,
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.billingOrders,
  });

  final int? id;

  final int userId;

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderUncheckedCreateNestedManyWithoutBillingAddressInput?
      billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'billingOrders': billingOrders,
      };
}

class AddressCreateOrConnectWithoutShippingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateOrConnectWithoutShippingOrdersInput({
    required this.where,
    required this.create,
  });

  final _i2.AddressWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.AddressCreateWithoutShippingOrdersInput,
      _i2.AddressUncheckedCreateWithoutShippingOrdersInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class AddressCreateNestedOneWithoutShippingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateNestedOneWithoutShippingOrdersInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.AddressCreateWithoutShippingOrdersInput,
      _i2.AddressUncheckedCreateWithoutShippingOrdersInput>? create;

  final _i2.AddressCreateOrConnectWithoutShippingOrdersInput? connectOrCreate;

  final _i2.AddressWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrderCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateWithoutUserInput({
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    required this.shippingAddress,
    required this.billingAddress,
    this.items,
    this.payments,
  });

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressCreateNestedOneWithoutShippingOrdersInput shippingAddress;

  final _i2.AddressCreateNestedOneWithoutBillingOrdersInput billingAddress;

  final _i2.OrderItemCreateNestedManyWithoutOrderInput? items;

  final _i2.PaymentCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
      };
}

class OrderCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OrderCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrderCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.OrderUncheckedCreateWithoutUserInput,
              Iterable<_i2.OrderUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutUserInput,
      Iterable<_i2.OrderCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.OrderCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UserCreateWithoutCartsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutCartsInput({
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressCreateNestedManyWithoutUserInput? addresses;

  final _i2.OrderCreateNestedManyWithoutUserInput? orders;

  final _i2.ReviewCreateNestedManyWithoutUserInput? reviews;

  final _i2.WishlistCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUncheckedCreateWithoutCartsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutCartsInput({
    this.id,
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final int? id;

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressUncheckedCreateNestedManyWithoutUserInput? addresses;

  final _i2.OrderUncheckedCreateNestedManyWithoutUserInput? orders;

  final _i2.ReviewUncheckedCreateNestedManyWithoutUserInput? reviews;

  final _i2.WishlistUncheckedCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserCreateOrConnectWithoutCartsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutCartsInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UserCreateWithoutCartsInput,
      _i2.UserUncheckedCreateWithoutCartsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UserCreateNestedOneWithoutCartsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutCartsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutCartsInput,
      _i2.UserUncheckedCreateWithoutCartsInput>? create;

  final _i2.UserCreateOrConnectWithoutCartsInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class CartCreateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateWithoutItemsInput({
    this.createdAt,
    this.updatedAt,
    required this.user,
  });

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutCartsInput user;

  @override
  Map<String, dynamic> toJson() => {
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class CartUncheckedCreateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedCreateWithoutItemsInput({
    this.id,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartCreateOrConnectWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateOrConnectWithoutItemsInput({
    required this.where,
    required this.create,
  });

  final _i2.CartWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartCreateWithoutItemsInput,
      _i2.CartUncheckedCreateWithoutItemsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class CartCreateNestedOneWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateNestedOneWithoutItemsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.CartCreateWithoutItemsInput,
      _i2.CartUncheckedCreateWithoutItemsInput>? create;

  final _i2.CartCreateOrConnectWithoutItemsInput? connectOrCreate;

  final _i2.CartWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class CartItemCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateWithoutProductInput({
    this.quantity,
    required this.priceAtAddition,
    this.addedAt,
    required this.cart,
  });

  final int? quantity;

  final _i1.Decimal priceAtAddition;

  final DateTime? addedAt;

  final _i2.CartCreateNestedOneWithoutItemsInput cart;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
      };
}

class CartItemCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.CartItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.CartItemCreateWithoutProductInput>,
              _i1.PrismaUnion<_i2.CartItemUncheckedCreateWithoutProductInput,
                  Iterable<_i2.CartItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.CartItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.CartItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.CartItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProductCreateWithoutCategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateWithoutCategoriesInput({
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductImageCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemCreateNestedManyWithoutProductInput? wishlistItems;

  final _i2.ProductDiscountCreateNestedManyWithoutProductInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedCreateWithoutCategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedCreateWithoutCategoriesInput({
    this.id,
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductImageUncheckedCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemUncheckedCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewUncheckedCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemUncheckedCreateNestedManyWithoutProductInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedCreateNestedManyWithoutProductInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductCreateOrConnectWithoutCategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateOrConnectWithoutCategoriesInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutCategoriesInput,
      _i2.ProductUncheckedCreateWithoutCategoriesInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductCreateNestedOneWithoutCategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateNestedOneWithoutCategoriesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutCategoriesInput,
      _i2.ProductUncheckedCreateWithoutCategoriesInput>? create;

  final _i2.ProductCreateOrConnectWithoutCategoriesInput? connectOrCreate;

  final _i2.ProductWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ProductCategoryCreateWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateWithoutCategoryInput({required this.product});

  final _i2.ProductCreateNestedOneWithoutCategoriesInput product;

  @override
  Map<String, dynamic> toJson() => {'product': product};
}

class ProductCategoryUncheckedCreateWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedCreateWithoutCategoryInput(
      {required this.productId});

  final int productId;

  @override
  Map<String, dynamic> toJson() => {'productId': productId};
}

class ProductCategoryCreateOrConnectWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateOrConnectWithoutCategoryInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductCategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateWithoutCategoryInput,
      _i2.ProductCategoryUncheckedCreateWithoutCategoryInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductCategoryCreateManyCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateManyCategoryInput({required this.productId});

  final int productId;

  @override
  Map<String, dynamic> toJson() => {'productId': productId};
}

class ProductCategoryCreateManyCategoryInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateManyCategoryInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.ProductCategoryCreateManyCategoryInput,
      Iterable<_i2.ProductCategoryCreateManyCategoryInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class ProductCategoryCreateNestedManyWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateNestedManyWithoutCategoryInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductCategoryCreateWithoutCategoryInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductCategoryCreateWithoutCategoryInput>,
              _i1.PrismaUnion<
                  _i2.ProductCategoryUncheckedCreateWithoutCategoryInput,
                  Iterable<
                      _i2
                      .ProductCategoryUncheckedCreateWithoutCategoryInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateOrConnectWithoutCategoryInput,
          Iterable<_i2.ProductCategoryCreateOrConnectWithoutCategoryInput>>?
      connectOrCreate;

  final _i2.ProductCategoryCreateManyCategoryInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class CategoryCreateWithoutSubcategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateWithoutSubcategoriesInput({
    required this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.products,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CategoryCreateNestedOneWithoutSubcategoriesInput? parentCategory;

  final _i2.ProductCategoryCreateNestedManyWithoutCategoryInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'products': products,
      };
}

class ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductCategoryCreateWithoutCategoryInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductCategoryCreateWithoutCategoryInput>,
              _i1.PrismaUnion<
                  _i2.ProductCategoryUncheckedCreateWithoutCategoryInput,
                  Iterable<
                      _i2
                      .ProductCategoryUncheckedCreateWithoutCategoryInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateOrConnectWithoutCategoryInput,
          Iterable<_i2.ProductCategoryCreateOrConnectWithoutCategoryInput>>?
      connectOrCreate;

  final _i2.ProductCategoryCreateManyCategoryInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class CategoryUncheckedCreateWithoutSubcategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedCreateWithoutSubcategoriesInput({
    this.id,
    required this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.products,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? parentCategoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput?
      products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
      };
}

class CategoryCreateOrConnectWithoutSubcategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateOrConnectWithoutSubcategoriesInput({
    required this.where,
    required this.create,
  });

  final _i2.CategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutSubcategoriesInput,
      _i2.CategoryUncheckedCreateWithoutSubcategoriesInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class CategoryCreateNestedOneWithoutSubcategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateNestedOneWithoutSubcategoriesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutSubcategoriesInput,
      _i2.CategoryUncheckedCreateWithoutSubcategoriesInput>? create;

  final _i2.CategoryCreateOrConnectWithoutSubcategoriesInput? connectOrCreate;

  final _i2.CategoryWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class CategoryCreateWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateWithoutParentCategoryInput({
    required this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.subcategories,
    this.products,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CategoryCreateNestedManyWithoutParentCategoryInput? subcategories;

  final _i2.ProductCategoryCreateNestedManyWithoutCategoryInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryCreateOrConnectWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateOrConnectWithoutParentCategoryInput({
    required this.where,
    required this.create,
  });

  final _i2.CategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutParentCategoryInput,
      _i2.CategoryUncheckedCreateWithoutParentCategoryInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class CategoryCreateManyParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateManyParentCategoryInput({
    this.id,
    required this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategoryCreateManyParentCategoryInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateManyParentCategoryInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.CategoryCreateManyParentCategoryInput,
      Iterable<_i2.CategoryCreateManyParentCategoryInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class CategoryUncheckedCreateNestedManyWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedCreateNestedManyWithoutParentCategoryInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.CategoryCreateWithoutParentCategoryInput,
          _i1.PrismaUnion<
              Iterable<_i2.CategoryCreateWithoutParentCategoryInput>,
              _i1.PrismaUnion<
                  _i2.CategoryUncheckedCreateWithoutParentCategoryInput,
                  Iterable<
                      _i2.CategoryUncheckedCreateWithoutParentCategoryInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.CategoryCreateOrConnectWithoutParentCategoryInput,
          Iterable<_i2.CategoryCreateOrConnectWithoutParentCategoryInput>>?
      connectOrCreate;

  final _i2.CategoryCreateManyParentCategoryInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class CategoryUncheckedCreateWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedCreateWithoutParentCategoryInput({
    this.id,
    required this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.subcategories,
    this.products,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CategoryUncheckedCreateNestedManyWithoutParentCategoryInput?
      subcategories;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput?
      products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryCreateNestedManyWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateNestedManyWithoutParentCategoryInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.CategoryCreateWithoutParentCategoryInput,
          _i1.PrismaUnion<
              Iterable<_i2.CategoryCreateWithoutParentCategoryInput>,
              _i1.PrismaUnion<
                  _i2.CategoryUncheckedCreateWithoutParentCategoryInput,
                  Iterable<
                      _i2.CategoryUncheckedCreateWithoutParentCategoryInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.CategoryCreateOrConnectWithoutParentCategoryInput,
          Iterable<_i2.CategoryCreateOrConnectWithoutParentCategoryInput>>?
      connectOrCreate;

  final _i2.CategoryCreateManyParentCategoryInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class CategoryCreateWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateWithoutProductsInput({
    required this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.subcategories,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CategoryCreateNestedOneWithoutSubcategoriesInput? parentCategory;

  final _i2.CategoryCreateNestedManyWithoutParentCategoryInput? subcategories;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'subcategories': subcategories,
      };
}

class CategoryUncheckedCreateWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedCreateWithoutProductsInput({
    this.id,
    required this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.subcategories,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? parentCategoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CategoryUncheckedCreateNestedManyWithoutParentCategoryInput?
      subcategories;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'subcategories': subcategories,
      };
}

class CategoryCreateOrConnectWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateOrConnectWithoutProductsInput({
    required this.where,
    required this.create,
  });

  final _i2.CategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutProductsInput,
      _i2.CategoryUncheckedCreateWithoutProductsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class CategoryCreateNestedOneWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateNestedOneWithoutProductsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutProductsInput,
      _i2.CategoryUncheckedCreateWithoutProductsInput>? create;

  final _i2.CategoryCreateOrConnectWithoutProductsInput? connectOrCreate;

  final _i2.CategoryWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ProductCategoryCreateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateWithoutProductInput({required this.category});

  final _i2.CategoryCreateNestedOneWithoutProductsInput category;

  @override
  Map<String, dynamic> toJson() => {'category': category};
}

class ProductCategoryCreateNestedManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateNestedManyWithoutProductInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductCategoryCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductCategoryCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductCategoryUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductCategoryUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductCategoryCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i2.ProductCategoryCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProductCreateWithoutCartItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateWithoutCartItemsInput({
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryCreateNestedManyWithoutProductInput? categories;

  final _i2.ProductImageCreateNestedManyWithoutProductInput? images;

  final _i2.OrderItemCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemCreateNestedManyWithoutProductInput? wishlistItems;

  final _i2.ProductDiscountCreateNestedManyWithoutProductInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedCreateWithoutCartItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedCreateWithoutCartItemsInput({
    this.id,
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutProductInput?
      categories;

  final _i2.ProductImageUncheckedCreateNestedManyWithoutProductInput? images;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewUncheckedCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemUncheckedCreateNestedManyWithoutProductInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedCreateNestedManyWithoutProductInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductCreateOrConnectWithoutCartItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateOrConnectWithoutCartItemsInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutCartItemsInput,
      _i2.ProductUncheckedCreateWithoutCartItemsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductCreateNestedOneWithoutCartItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateNestedOneWithoutCartItemsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutCartItemsInput,
      _i2.ProductUncheckedCreateWithoutCartItemsInput>? create;

  final _i2.ProductCreateOrConnectWithoutCartItemsInput? connectOrCreate;

  final _i2.ProductWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class CartItemCreateWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateWithoutCartInput({
    this.quantity,
    required this.priceAtAddition,
    this.addedAt,
    required this.product,
  });

  final int? quantity;

  final _i1.Decimal priceAtAddition;

  final DateTime? addedAt;

  final _i2.ProductCreateNestedOneWithoutCartItemsInput product;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'product': product,
      };
}

class CartItemCreateNestedManyWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateNestedManyWithoutCartInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.CartItemCreateWithoutCartInput,
      _i1.PrismaUnion<
          Iterable<_i2.CartItemCreateWithoutCartInput>,
          _i1.PrismaUnion<_i2.CartItemUncheckedCreateWithoutCartInput,
              Iterable<_i2.CartItemUncheckedCreateWithoutCartInput>>>>? create;

  final _i1.PrismaUnion<_i2.CartItemCreateOrConnectWithoutCartInput,
      Iterable<_i2.CartItemCreateOrConnectWithoutCartInput>>? connectOrCreate;

  final _i2.CartItemCreateManyCartInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class CartCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateWithoutUserInput({
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CartItemCreateNestedManyWithoutCartInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class CartCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.CartCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.CartCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.CartUncheckedCreateWithoutUserInput,
              Iterable<_i2.CartUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.CartCreateOrConnectWithoutUserInput,
      Iterable<_i2.CartCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.CartCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UserCreateWithoutOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateWithoutOrdersInput({
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.reviews,
    this.wishlists,
  });

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressCreateNestedManyWithoutUserInput? addresses;

  final _i2.CartCreateNestedManyWithoutUserInput? carts;

  final _i2.ReviewCreateNestedManyWithoutUserInput? reviews;

  final _i2.WishlistCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUncheckedCreateWithoutOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateWithoutOrdersInput({
    this.id,
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.reviews,
    this.wishlists,
  });

  final int? id;

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressUncheckedCreateNestedManyWithoutUserInput? addresses;

  final _i2.CartUncheckedCreateNestedManyWithoutUserInput? carts;

  final _i2.ReviewUncheckedCreateNestedManyWithoutUserInput? reviews;

  final _i2.WishlistUncheckedCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserCreateOrConnectWithoutOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateOrConnectWithoutOrdersInput({
    required this.where,
    required this.create,
  });

  final _i2.UserWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UserCreateWithoutOrdersInput,
      _i2.UserUncheckedCreateWithoutOrdersInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UserCreateNestedOneWithoutOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateNestedOneWithoutOrdersInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutOrdersInput,
      _i2.UserUncheckedCreateWithoutOrdersInput>? create;

  final _i2.UserCreateOrConnectWithoutOrdersInput? connectOrCreate;

  final _i2.UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrderCreateWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateWithoutShippingAddressInput({
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    required this.user,
    required this.billingAddress,
    this.items,
    this.payments,
  });

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutOrdersInput user;

  final _i2.AddressCreateNestedOneWithoutBillingOrdersInput billingAddress;

  final _i2.OrderItemCreateNestedManyWithoutOrderInput? items;

  final _i2.PaymentCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
      };
}

class OrderCreateNestedManyWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateNestedManyWithoutShippingAddressInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrderCreateWithoutShippingAddressInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderCreateWithoutShippingAddressInput>,
              _i1.PrismaUnion<
                  _i2.OrderUncheckedCreateWithoutShippingAddressInput,
                  Iterable<
                      _i2.OrderUncheckedCreateWithoutShippingAddressInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutShippingAddressInput,
          Iterable<_i2.OrderCreateOrConnectWithoutShippingAddressInput>>?
      connectOrCreate;

  final _i2.OrderCreateManyShippingAddressInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class AddressCreateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateWithoutUserInput({
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.shippingOrders,
    this.billingOrders,
  });

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderCreateNestedManyWithoutShippingAddressInput? shippingOrders;

  final _i2.OrderCreateNestedManyWithoutBillingAddressInput? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressCreateNestedManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.AddressCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.AddressCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.AddressUncheckedCreateWithoutUserInput,
              Iterable<_i2.AddressUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.AddressCreateOrConnectWithoutUserInput,
      Iterable<_i2.AddressCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i2.AddressCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UserCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateInput({
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressCreateNestedManyWithoutUserInput? addresses;

  final _i2.CartCreateNestedManyWithoutUserInput? carts;

  final _i2.OrderCreateNestedManyWithoutUserInput? orders;

  final _i2.ReviewCreateNestedManyWithoutUserInput? reviews;

  final _i2.WishlistCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateInput({
    this.id,
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final int? id;

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressUncheckedCreateNestedManyWithoutUserInput? addresses;

  final _i2.CartUncheckedCreateNestedManyWithoutUserInput? carts;

  final _i2.OrderUncheckedCreateNestedManyWithoutUserInput? orders;

  final _i2.ReviewUncheckedCreateNestedManyWithoutUserInput? reviews;

  final _i2.WishlistUncheckedCreateNestedManyWithoutUserInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class AffectedRowsOutput {
  const AffectedRowsOutput({this.count});

  factory AffectedRowsOutput.fromJson(Map json) =>
      AffectedRowsOutput(count: json['count']);

  final int? count;

  Map<String, dynamic> toJson() => {'count': count};
}

class UserCreateManyInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateManyInput({
    this.id,
    required this.email,
    required this.password,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final String email;

  final String password;

  final String firstName;

  final String lastName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CreateManyUserAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyUserAndReturnOutputTypeSelect({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? email;

  final bool? password;

  final bool? firstName;

  final bool? lastName;

  final bool? phone;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class StringFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringFieldUpdateOperationsInput({this.set});

  final String? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableStringFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableStringFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<String, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class DateTimeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeFieldUpdateOperationsInput({this.set});

  final DateTime? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class BoolFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolFieldUpdateOperationsInput({this.set});

  final bool? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class DecimalFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DecimalFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final _i1.Decimal? set;

  final _i1.Decimal? increment;

  final _i1.Decimal? decrement;

  final _i1.Decimal? multiply;

  final _i1.Decimal? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class IntFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final int? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class ProductImageUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUpdateWithoutProductInput({
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? imageUrl;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isPrimary;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? displayOrder;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageUncheckedUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUncheckedUpdateWithoutProductInput({
    this.id,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? imageUrl;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isPrimary;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? displayOrder;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageUpsertWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUpsertWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ProductImageWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductImageUpdateWithoutProductInput,
      _i2.ProductImageUncheckedUpdateWithoutProductInput> update;

  final _i1.PrismaUnion<_i2.ProductImageCreateWithoutProductInput,
      _i2.ProductImageUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ProductImageUpdateWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUpdateWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductImageWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductImageUpdateWithoutProductInput,
      _i2.ProductImageUncheckedUpdateWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductImageScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i1.PrismaUnion<_i2.ProductImageScalarWhereInput,
      Iterable<_i2.ProductImageScalarWhereInput>>? AND;

  final Iterable<_i2.ProductImageScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductImageScalarWhereInput,
      Iterable<_i2.ProductImageScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? imageUrl;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isPrimary;

  final _i1.PrismaUnion<_i2.IntFilter, int>? displayOrder;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUpdateManyMutationInput({
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? imageUrl;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isPrimary;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? displayOrder;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageUncheckedUpdateManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUncheckedUpdateManyWithoutProductInput({
    this.id,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? imageUrl;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isPrimary;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? displayOrder;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageUpdateManyWithWhereWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUpdateManyWithWhereWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductImageScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ProductImageUpdateManyMutationInput,
      _i2.ProductImageUncheckedUpdateManyWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductImageUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductImageCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductImageCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductImageUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductImageUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductImageCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductImageCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProductImageUpsertWithWhereUniqueWithoutProductInput,
          Iterable<_i2.ProductImageUpsertWithWhereUniqueWithoutProductInput>>?
      upsert;

  final _i2.ProductImageCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProductImageUpdateWithWhereUniqueWithoutProductInput,
          Iterable<_i2.ProductImageUpdateWithWhereUniqueWithoutProductInput>>?
      update;

  final _i1.PrismaUnion<_i2.ProductImageUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.ProductImageUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductImageScalarWhereInput,
      Iterable<_i2.ProductImageScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class AddressUpdateWithoutBillingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateWithoutBillingOrdersInput({
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingOrders,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutAddressesNestedInput? user;

  final _i2.OrderUpdateManyWithoutShippingAddressNestedInput? shippingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingOrders': shippingOrders,
      };
}

class NullableIntFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableIntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class DiscountUpdateWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUpdateWithoutProductsInput({
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      discountType;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? usageLimit;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? timesUsed;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validFrom;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validTo;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountUncheckedUpdateWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUncheckedUpdateWithoutProductsInput({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      discountType;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? usageLimit;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? timesUsed;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validFrom;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validTo;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountUpsertWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUpsertWithoutProductsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.DiscountUpdateWithoutProductsInput,
      _i2.DiscountUncheckedUpdateWithoutProductsInput> update;

  final _i1.PrismaUnion<_i2.DiscountCreateWithoutProductsInput,
      _i2.DiscountUncheckedCreateWithoutProductsInput> create;

  final _i2.DiscountWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class DiscountUpdateToOneWithWhereWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUpdateToOneWithWhereWithoutProductsInput({
    this.where,
    required this.data,
  });

  final _i2.DiscountWhereInput? where;

  final _i1.PrismaUnion<_i2.DiscountUpdateWithoutProductsInput,
      _i2.DiscountUncheckedUpdateWithoutProductsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class DiscountUpdateOneRequiredWithoutProductsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUpdateOneRequiredWithoutProductsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.DiscountCreateWithoutProductsInput,
      _i2.DiscountUncheckedCreateWithoutProductsInput>? create;

  final _i2.DiscountCreateOrConnectWithoutProductsInput? connectOrCreate;

  final _i2.DiscountUpsertWithoutProductsInput? upsert;

  final _i2.DiscountWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.DiscountUpdateToOneWithWhereWithoutProductsInput,
      _i1.PrismaUnion<_i2.DiscountUpdateWithoutProductsInput,
          _i2.DiscountUncheckedUpdateWithoutProductsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ProductDiscountUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateWithoutProductInput({this.discount});

  final _i2.DiscountUpdateOneRequiredWithoutProductsNestedInput? discount;

  @override
  Map<String, dynamic> toJson() => {'discount': discount};
}

class ProductDiscountUncheckedUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedUpdateWithoutProductInput({this.discountId});

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? discountId;

  @override
  Map<String, dynamic> toJson() => {'discountId': discountId};
}

class ProductDiscountUpsertWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpsertWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ProductDiscountWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductDiscountUpdateWithoutProductInput,
      _i2.ProductDiscountUncheckedUpdateWithoutProductInput> update;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateWithoutProductInput,
      _i2.ProductDiscountUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ProductDiscountUpdateWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductDiscountWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductDiscountUpdateWithoutProductInput,
      _i2.ProductDiscountUncheckedUpdateWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductDiscountScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.discountId,
  });

  final _i1.PrismaUnion<_i2.ProductDiscountScalarWhereInput,
      Iterable<_i2.ProductDiscountScalarWhereInput>>? AND;

  final Iterable<_i2.ProductDiscountScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductDiscountScalarWhereInput,
      Iterable<_i2.ProductDiscountScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateManyMutationInput();

  @override
  Map<String, dynamic> toJson() => {};
}

class ProductDiscountUncheckedUpdateManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedUpdateManyWithoutProductInput(
      {this.discountId});

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? discountId;

  @override
  Map<String, dynamic> toJson() => {'discountId': discountId};
}

class ProductDiscountUpdateManyWithWhereWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateManyWithWhereWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductDiscountScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ProductDiscountUpdateManyMutationInput,
      _i2.ProductDiscountUncheckedUpdateManyWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductDiscountUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductDiscountCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductDiscountCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductDiscountUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductDiscountUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductDiscountCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.ProductDiscountUpsertWithWhereUniqueWithoutProductInput,
      Iterable<
          _i2.ProductDiscountUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.ProductDiscountCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.ProductDiscountUpdateWithWhereUniqueWithoutProductInput,
      Iterable<
          _i2.ProductDiscountUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<
          _i2.ProductDiscountUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.ProductDiscountUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductDiscountScalarWhereInput,
      Iterable<_i2.ProductDiscountScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProductUpdateWithoutWishlistItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateWithoutWishlistItemsInput({
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.discounts,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUpdateManyWithoutProductNestedInput? categories;

  final _i2.ProductImageUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUpdateManyWithoutProductNestedInput? reviews;

  final _i2.ProductDiscountUpdateManyWithoutProductNestedInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'discounts': discounts,
      };
}

class ProductCategoryUncheckedUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedUpdateWithoutProductInput({this.categoryId});

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? categoryId;

  @override
  Map<String, dynamic> toJson() => {'categoryId': categoryId};
}

class ProductCategoryUpdateWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductCategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCategoryUpdateWithoutProductInput,
      _i2.ProductCategoryUncheckedUpdateWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductCategoryScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.categoryId,
  });

  final _i1.PrismaUnion<_i2.ProductCategoryScalarWhereInput,
      Iterable<_i2.ProductCategoryScalarWhereInput>>? AND;

  final Iterable<_i2.ProductCategoryScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProductCategoryScalarWhereInput,
      Iterable<_i2.ProductCategoryScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateManyMutationInput();

  @override
  Map<String, dynamic> toJson() => {};
}

class ProductCategoryUncheckedUpdateManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedUpdateManyWithoutProductInput(
      {this.categoryId});

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? categoryId;

  @override
  Map<String, dynamic> toJson() => {'categoryId': categoryId};
}

class ProductCategoryUpdateManyWithWhereWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateManyWithWhereWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductCategoryScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ProductCategoryUpdateManyMutationInput,
      _i2.ProductCategoryUncheckedUpdateManyWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductCategoryCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductCategoryCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductCategoryUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductCategoryUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductCategoryCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.ProductCategoryUpsertWithWhereUniqueWithoutProductInput,
      Iterable<
          _i2.ProductCategoryUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.ProductCategoryCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.ProductCategoryUpdateWithWhereUniqueWithoutProductInput,
      Iterable<
          _i2.ProductCategoryUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<
          _i2.ProductCategoryUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.ProductCategoryUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductCategoryScalarWhereInput,
      Iterable<_i2.ProductCategoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProductImageUncheckedUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUncheckedUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductImageCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductImageCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductImageUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductImageUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductImageCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductImageCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProductImageUpsertWithWhereUniqueWithoutProductInput,
          Iterable<_i2.ProductImageUpsertWithWhereUniqueWithoutProductInput>>?
      upsert;

  final _i2.ProductImageCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductImageWhereUniqueInput,
      Iterable<_i2.ProductImageWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProductImageUpdateWithWhereUniqueWithoutProductInput,
          Iterable<_i2.ProductImageUpdateWithWhereUniqueWithoutProductInput>>?
      update;

  final _i1.PrismaUnion<_i2.ProductImageUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.ProductImageUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductImageScalarWhereInput,
      Iterable<_i2.ProductImageScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class CartItemUncheckedUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedUpdateWithoutProductInput({
    this.id,
    this.cartId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? cartId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemUpdateWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.CartItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartItemUpdateWithoutProductInput,
      _i2.CartItemUncheckedUpdateWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CartItemScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i1.PrismaUnion<_i2.CartItemScalarWhereInput,
      Iterable<_i2.CartItemScalarWhereInput>>? AND;

  final Iterable<_i2.CartItemScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.CartItemScalarWhereInput,
      Iterable<_i2.CartItemScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? cartId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? quantity;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? priceAtAddition;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateManyMutationInput({
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemUncheckedUpdateManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedUpdateManyWithoutProductInput({
    this.id,
    this.cartId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? cartId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemUpdateManyWithWhereWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateManyWithWhereWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.CartItemScalarWhereInput where;

  final _i1.PrismaUnion<_i2.CartItemUpdateManyMutationInput,
      _i2.CartItemUncheckedUpdateManyWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CartItemUncheckedUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.CartItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.CartItemCreateWithoutProductInput>,
              _i1.PrismaUnion<_i2.CartItemUncheckedCreateWithoutProductInput,
                  Iterable<_i2.CartItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.CartItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.CartItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.CartItemUpsertWithWhereUniqueWithoutProductInput,
      Iterable<_i2.CartItemUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.CartItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.CartItemUpdateWithWhereUniqueWithoutProductInput,
      Iterable<_i2.CartItemUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<_i2.CartItemUpdateManyWithWhereWithoutProductInput,
      Iterable<_i2.CartItemUpdateManyWithWhereWithoutProductInput>>? updateMany;

  final _i1.PrismaUnion<_i2.CartItemScalarWhereInput,
      Iterable<_i2.CartItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OrderItemUncheckedUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedUpdateWithoutProductInput({
    this.id,
    this.orderId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? orderId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemUpdateWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderItemUpdateWithoutProductInput,
      _i2.OrderItemUncheckedUpdateWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderItemScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i1.PrismaUnion<_i2.OrderItemScalarWhereInput,
      Iterable<_i2.OrderItemScalarWhereInput>>? AND;

  final Iterable<_i2.OrderItemScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OrderItemScalarWhereInput,
      Iterable<_i2.OrderItemScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? orderId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? quantity;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? priceAtPurchase;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? subtotal;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateManyMutationInput({
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemUncheckedUpdateManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedUpdateManyWithoutProductInput({
    this.id,
    this.orderId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? orderId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemUpdateManyWithWhereWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateManyWithWhereWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderItemScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrderItemUpdateManyMutationInput,
      _i2.OrderItemUncheckedUpdateManyWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderItemUncheckedUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrderItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderItemCreateWithoutProductInput>,
              _i1.PrismaUnion<_i2.OrderItemUncheckedCreateWithoutProductInput,
                  Iterable<_i2.OrderItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.OrderItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OrderItemUpsertWithWhereUniqueWithoutProductInput,
      Iterable<_i2.OrderItemUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.OrderItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrderItemUpdateWithWhereUniqueWithoutProductInput,
      Iterable<_i2.OrderItemUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<_i2.OrderItemUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.OrderItemUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OrderItemScalarWhereInput,
      Iterable<_i2.OrderItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ReviewUncheckedUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedUpdateWithoutProductInput({
    this.id,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewUpdateWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.ReviewWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ReviewUpdateWithoutProductInput,
      _i2.ReviewUncheckedUpdateWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ReviewScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.ReviewScalarWhereInput,
      Iterable<_i2.ReviewScalarWhereInput>>? AND;

  final Iterable<_i2.ReviewScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ReviewScalarWhereInput,
      Iterable<_i2.ReviewScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? rating;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateManyMutationInput({
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewUncheckedUpdateManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedUpdateManyWithoutProductInput({
    this.id,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewUpdateManyWithWhereWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateManyWithWhereWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.ReviewScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ReviewUpdateManyMutationInput,
      _i2.ReviewUncheckedUpdateManyWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ReviewUncheckedUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.ReviewCreateWithoutProductInput,
      _i1.PrismaUnion<
          Iterable<_i2.ReviewCreateWithoutProductInput>,
          _i1.PrismaUnion<_i2.ReviewUncheckedCreateWithoutProductInput,
              Iterable<_i2.ReviewUncheckedCreateWithoutProductInput>>>>? create;

  final _i1.PrismaUnion<_i2.ReviewCreateOrConnectWithoutProductInput,
      Iterable<_i2.ReviewCreateOrConnectWithoutProductInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.ReviewUpsertWithWhereUniqueWithoutProductInput,
      Iterable<_i2.ReviewUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.ReviewCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ReviewUpdateWithWhereUniqueWithoutProductInput,
      Iterable<_i2.ReviewUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<_i2.ReviewUpdateManyWithWhereWithoutProductInput,
      Iterable<_i2.ReviewUpdateManyWithWhereWithoutProductInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ReviewScalarWhereInput,
      Iterable<_i2.ReviewScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProductDiscountUncheckedUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductDiscountCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductDiscountCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductDiscountUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductDiscountUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductDiscountCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.ProductDiscountUpsertWithWhereUniqueWithoutProductInput,
      Iterable<
          _i2.ProductDiscountUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.ProductDiscountCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.ProductDiscountUpdateWithWhereUniqueWithoutProductInput,
      Iterable<
          _i2.ProductDiscountUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<
          _i2.ProductDiscountUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.ProductDiscountUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductDiscountScalarWhereInput,
      Iterable<_i2.ProductDiscountScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProductUncheckedUpdateWithoutWishlistItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedUpdateWithoutWishlistItemsInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.discounts,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutProductNestedInput?
      categories;

  final _i2.ProductImageUncheckedUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUncheckedUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUncheckedUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUncheckedUpdateManyWithoutProductNestedInput? reviews;

  final _i2.ProductDiscountUncheckedUpdateManyWithoutProductNestedInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'discounts': discounts,
      };
}

class ProductUpsertWithoutWishlistItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpsertWithoutWishlistItemsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutWishlistItemsInput,
      _i2.ProductUncheckedUpdateWithoutWishlistItemsInput> update;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutWishlistItemsInput,
      _i2.ProductUncheckedCreateWithoutWishlistItemsInput> create;

  final _i2.ProductWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ProductUpdateToOneWithWhereWithoutWishlistItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateToOneWithWhereWithoutWishlistItemsInput({
    this.where,
    required this.data,
  });

  final _i2.ProductWhereInput? where;

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutWishlistItemsInput,
      _i2.ProductUncheckedUpdateWithoutWishlistItemsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductUpdateOneRequiredWithoutWishlistItemsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateOneRequiredWithoutWishlistItemsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutWishlistItemsInput,
      _i2.ProductUncheckedCreateWithoutWishlistItemsInput>? create;

  final _i2.ProductCreateOrConnectWithoutWishlistItemsInput? connectOrCreate;

  final _i2.ProductUpsertWithoutWishlistItemsInput? upsert;

  final _i2.ProductWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ProductUpdateToOneWithWhereWithoutWishlistItemsInput,
      _i1.PrismaUnion<_i2.ProductUpdateWithoutWishlistItemsInput,
          _i2.ProductUncheckedUpdateWithoutWishlistItemsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class WishlistItemUpdateWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateWithoutWishlistInput({
    this.addedAt,
    this.product,
  });

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  final _i2.ProductUpdateOneRequiredWithoutWishlistItemsNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'addedAt': addedAt,
        'product': product,
      };
}

class WishlistItemUncheckedUpdateWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedUpdateWithoutWishlistInput({
    this.productId,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemUpsertWithWhereUniqueWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpsertWithWhereUniqueWithoutWishlistInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.WishlistItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateWithoutWishlistInput,
      _i2.WishlistItemUncheckedUpdateWithoutWishlistInput> update;

  final _i1.PrismaUnion<_i2.WishlistItemCreateWithoutWishlistInput,
      _i2.WishlistItemUncheckedCreateWithoutWishlistInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class WishlistItemUpdateWithWhereUniqueWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateWithWhereUniqueWithoutWishlistInput({
    required this.where,
    required this.data,
  });

  final _i2.WishlistItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateWithoutWishlistInput,
      _i2.WishlistItemUncheckedUpdateWithoutWishlistInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class WishlistItemScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  final _i1.PrismaUnion<_i2.WishlistItemScalarWhereInput,
      Iterable<_i2.WishlistItemScalarWhereInput>>? AND;

  final Iterable<_i2.WishlistItemScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WishlistItemScalarWhereInput,
      Iterable<_i2.WishlistItemScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? wishlistId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? productId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateManyMutationInput({this.addedAt});

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {'addedAt': addedAt};
}

class WishlistItemUncheckedUpdateManyWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedUpdateManyWithoutWishlistInput({
    this.productId,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemUpdateManyWithWhereWithoutWishlistInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateManyWithWhereWithoutWishlistInput({
    required this.where,
    required this.data,
  });

  final _i2.WishlistItemScalarWhereInput where;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateManyMutationInput,
      _i2.WishlistItemUncheckedUpdateManyWithoutWishlistInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class WishlistItemUpdateManyWithoutWishlistNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateManyWithoutWishlistNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.WishlistItemCreateWithoutWishlistInput,
          _i1.PrismaUnion<
              Iterable<_i2.WishlistItemCreateWithoutWishlistInput>,
              _i1.PrismaUnion<
                  _i2.WishlistItemUncheckedCreateWithoutWishlistInput,
                  Iterable<
                      _i2.WishlistItemUncheckedCreateWithoutWishlistInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.WishlistItemCreateOrConnectWithoutWishlistInput,
          Iterable<_i2.WishlistItemCreateOrConnectWithoutWishlistInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.WishlistItemUpsertWithWhereUniqueWithoutWishlistInput,
          Iterable<_i2.WishlistItemUpsertWithWhereUniqueWithoutWishlistInput>>?
      upsert;

  final _i2.WishlistItemCreateManyWishlistInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.WishlistItemUpdateWithWhereUniqueWithoutWishlistInput,
          Iterable<_i2.WishlistItemUpdateWithWhereUniqueWithoutWishlistInput>>?
      update;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateManyWithWhereWithoutWishlistInput,
          Iterable<_i2.WishlistItemUpdateManyWithWhereWithoutWishlistInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.WishlistItemScalarWhereInput,
      Iterable<_i2.WishlistItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class WishlistUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpdateWithoutUserInput({
    this.name,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.WishlistItemUpdateManyWithoutWishlistNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.WishlistItemCreateWithoutWishlistInput,
          _i1.PrismaUnion<
              Iterable<_i2.WishlistItemCreateWithoutWishlistInput>,
              _i1.PrismaUnion<
                  _i2.WishlistItemUncheckedCreateWithoutWishlistInput,
                  Iterable<
                      _i2.WishlistItemUncheckedCreateWithoutWishlistInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.WishlistItemCreateOrConnectWithoutWishlistInput,
          Iterable<_i2.WishlistItemCreateOrConnectWithoutWishlistInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.WishlistItemUpsertWithWhereUniqueWithoutWishlistInput,
          Iterable<_i2.WishlistItemUpsertWithWhereUniqueWithoutWishlistInput>>?
      upsert;

  final _i2.WishlistItemCreateManyWishlistInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.WishlistItemUpdateWithWhereUniqueWithoutWishlistInput,
          Iterable<_i2.WishlistItemUpdateWithWhereUniqueWithoutWishlistInput>>?
      update;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateManyWithWhereWithoutWishlistInput,
          Iterable<_i2.WishlistItemUpdateManyWithWhereWithoutWishlistInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.WishlistItemScalarWhereInput,
      Iterable<_i2.WishlistItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class WishlistUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedUpdateWithoutUserInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class WishlistUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.WishlistWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistUpdateWithoutUserInput,
      _i2.WishlistUncheckedUpdateWithoutUserInput> update;

  final _i1.PrismaUnion<_i2.WishlistCreateWithoutUserInput,
      _i2.WishlistUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class WishlistUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.WishlistWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistUpdateWithoutUserInput,
      _i2.WishlistUncheckedUpdateWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class WishlistScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.WishlistScalarWhereInput,
      Iterable<_i2.WishlistScalarWhereInput>>? AND;

  final Iterable<_i2.WishlistScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WishlistScalarWhereInput,
      Iterable<_i2.WishlistScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpdateManyMutationInput({
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistUncheckedUpdateManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedUpdateManyWithoutUserInput({
    this.id,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.WishlistScalarWhereInput where;

  final _i1.PrismaUnion<_i2.WishlistUpdateManyMutationInput,
      _i2.WishlistUncheckedUpdateManyWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class WishlistUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.WishlistCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.WishlistCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.WishlistUncheckedCreateWithoutUserInput,
              Iterable<_i2.WishlistUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.WishlistCreateOrConnectWithoutUserInput,
      Iterable<_i2.WishlistCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.WishlistUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.WishlistUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.WishlistCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.WishlistUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.WishlistUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.WishlistUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.WishlistUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.WishlistScalarWhereInput,
      Iterable<_i2.WishlistScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UserUpdateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutReviewsInput({
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.wishlists,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUpdateManyWithoutUserNestedInput? addresses;

  final _i2.CartUpdateManyWithoutUserNestedInput? carts;

  final _i2.OrderUpdateManyWithoutUserNestedInput? orders;

  final _i2.WishlistUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'wishlists': wishlists,
      };
}

class OrderItemUncheckedUpdateWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedUpdateWithoutOrderInput({
    this.id,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemUpdateWithWhereUniqueWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateWithWhereUniqueWithoutOrderInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderItemUpdateWithoutOrderInput,
      _i2.OrderItemUncheckedUpdateWithoutOrderInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderItemUncheckedUpdateManyWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedUpdateManyWithoutOrderInput({
    this.id,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemUpdateManyWithWhereWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateManyWithWhereWithoutOrderInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderItemScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrderItemUpdateManyMutationInput,
      _i2.OrderItemUncheckedUpdateManyWithoutOrderInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderItemUpdateManyWithoutOrderNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateManyWithoutOrderNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrderItemCreateWithoutOrderInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderItemCreateWithoutOrderInput>,
              _i1.PrismaUnion<_i2.OrderItemUncheckedCreateWithoutOrderInput,
                  Iterable<_i2.OrderItemUncheckedCreateWithoutOrderInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderItemCreateOrConnectWithoutOrderInput,
      Iterable<_i2.OrderItemCreateOrConnectWithoutOrderInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrderItemUpsertWithWhereUniqueWithoutOrderInput,
      Iterable<_i2.OrderItemUpsertWithWhereUniqueWithoutOrderInput>>? upsert;

  final _i2.OrderItemCreateManyOrderInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrderItemUpdateWithWhereUniqueWithoutOrderInput,
      Iterable<_i2.OrderItemUpdateWithWhereUniqueWithoutOrderInput>>? update;

  final _i1.PrismaUnion<_i2.OrderItemUpdateManyWithWhereWithoutOrderInput,
      Iterable<_i2.OrderItemUpdateManyWithWhereWithoutOrderInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrderItemScalarWhereInput,
      Iterable<_i2.OrderItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class PaymentUpdateWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateWithoutOrderInput({
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentMethod;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentUncheckedUpdateWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateWithoutOrderInput({
    this.id,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentMethod;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentUpsertWithWhereUniqueWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpsertWithWhereUniqueWithoutOrderInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PaymentUpdateWithoutOrderInput,
      _i2.PaymentUncheckedUpdateWithoutOrderInput> update;

  final _i1.PrismaUnion<_i2.PaymentCreateWithoutOrderInput,
      _i2.PaymentUncheckedCreateWithoutOrderInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class PaymentUpdateWithWhereUniqueWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateWithWhereUniqueWithoutOrderInput({
    required this.where,
    required this.data,
  });

  final _i2.PaymentWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PaymentUpdateWithoutOrderInput,
      _i2.PaymentUncheckedUpdateWithoutOrderInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PaymentScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i1.PrismaUnion<_i2.PaymentScalarWhereInput,
      Iterable<_i2.PaymentScalarWhereInput>>? AND;

  final Iterable<_i2.PaymentScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.PaymentScalarWhereInput,
      Iterable<_i2.PaymentScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? orderId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentMethod;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? amount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? status;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyMutationInput({
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentMethod;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentUncheckedUpdateManyWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateManyWithoutOrderInput({
    this.id,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentMethod;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentUpdateManyWithWhereWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyWithWhereWithoutOrderInput({
    required this.where,
    required this.data,
  });

  final _i2.PaymentScalarWhereInput where;

  final _i1.PrismaUnion<_i2.PaymentUpdateManyMutationInput,
      _i2.PaymentUncheckedUpdateManyWithoutOrderInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PaymentUpdateManyWithoutOrderNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateManyWithoutOrderNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.PaymentCreateWithoutOrderInput,
      _i1.PrismaUnion<
          Iterable<_i2.PaymentCreateWithoutOrderInput>,
          _i1.PrismaUnion<_i2.PaymentUncheckedCreateWithoutOrderInput,
              Iterable<_i2.PaymentUncheckedCreateWithoutOrderInput>>>>? create;

  final _i1.PrismaUnion<_i2.PaymentCreateOrConnectWithoutOrderInput,
      Iterable<_i2.PaymentCreateOrConnectWithoutOrderInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.PaymentUpsertWithWhereUniqueWithoutOrderInput,
      Iterable<_i2.PaymentUpsertWithWhereUniqueWithoutOrderInput>>? upsert;

  final _i2.PaymentCreateManyOrderInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PaymentUpdateWithWhereUniqueWithoutOrderInput,
      Iterable<_i2.PaymentUpdateWithWhereUniqueWithoutOrderInput>>? update;

  final _i1.PrismaUnion<_i2.PaymentUpdateManyWithWhereWithoutOrderInput,
      Iterable<_i2.PaymentUpdateManyWithWhereWithoutOrderInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PaymentScalarWhereInput,
      Iterable<_i2.PaymentScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OrderUpdateWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateWithoutBillingAddressInput({
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.items,
    this.payments,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutOrdersNestedInput? user;

  final _i2.AddressUpdateOneRequiredWithoutShippingOrdersNestedInput?
      shippingAddress;

  final _i2.OrderItemUpdateManyWithoutOrderNestedInput? items;

  final _i2.PaymentUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'items': items,
        'payments': payments,
      };
}

class PaymentUncheckedUpdateManyWithoutOrderNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateManyWithoutOrderNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.PaymentCreateWithoutOrderInput,
      _i1.PrismaUnion<
          Iterable<_i2.PaymentCreateWithoutOrderInput>,
          _i1.PrismaUnion<_i2.PaymentUncheckedCreateWithoutOrderInput,
              Iterable<_i2.PaymentUncheckedCreateWithoutOrderInput>>>>? create;

  final _i1.PrismaUnion<_i2.PaymentCreateOrConnectWithoutOrderInput,
      Iterable<_i2.PaymentCreateOrConnectWithoutOrderInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.PaymentUpsertWithWhereUniqueWithoutOrderInput,
      Iterable<_i2.PaymentUpsertWithWhereUniqueWithoutOrderInput>>? upsert;

  final _i2.PaymentCreateManyOrderInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PaymentWhereUniqueInput,
      Iterable<_i2.PaymentWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PaymentUpdateWithWhereUniqueWithoutOrderInput,
      Iterable<_i2.PaymentUpdateWithWhereUniqueWithoutOrderInput>>? update;

  final _i1.PrismaUnion<_i2.PaymentUpdateManyWithWhereWithoutOrderInput,
      Iterable<_i2.PaymentUpdateManyWithWhereWithoutOrderInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PaymentScalarWhereInput,
      Iterable<_i2.PaymentScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OrderUncheckedUpdateWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateWithoutBillingAddressInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
    this.payments,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      shippingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderItemUncheckedUpdateManyWithoutOrderNestedInput? items;

  final _i2.PaymentUncheckedUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
        'payments': payments,
      };
}

class OrderUpsertWithWhereUniqueWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpsertWithWhereUniqueWithoutBillingAddressInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutBillingAddressInput,
      _i2.OrderUncheckedUpdateWithoutBillingAddressInput> update;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutBillingAddressInput,
      _i2.OrderUncheckedCreateWithoutBillingAddressInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrderUpdateWithWhereUniqueWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateWithWhereUniqueWithoutBillingAddressInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutBillingAddressInput,
      _i2.OrderUncheckedUpdateWithoutBillingAddressInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.OrderScalarWhereInput,
      Iterable<_i2.OrderScalarWhereInput>>? AND;

  final Iterable<_i2.OrderScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OrderScalarWhereInput,
      Iterable<_i2.OrderScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? shippingAddressId;

  final _i1.PrismaUnion<_i2.IntFilter, int>? billingAddressId;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? subtotal;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? tax;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? shippingCost;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? totalAmount;

  final _i1.PrismaUnion<_i2.StringFilter, String>? status;

  final _i1.PrismaUnion<_i2.StringFilter, String>? paymentStatus;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateManyMutationInput({
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderUncheckedUpdateManyWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateManyWithoutBillingAddressInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      shippingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderUpdateManyWithWhereWithoutBillingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateManyWithWhereWithoutBillingAddressInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrderUpdateManyMutationInput,
      _i2.OrderUncheckedUpdateManyWithoutBillingAddressInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderUncheckedUpdateManyWithoutBillingAddressNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateManyWithoutBillingAddressNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrderCreateWithoutBillingAddressInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderCreateWithoutBillingAddressInput>,
              _i1.PrismaUnion<
                  _i2.OrderUncheckedCreateWithoutBillingAddressInput,
                  Iterable<
                      _i2.OrderUncheckedCreateWithoutBillingAddressInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutBillingAddressInput,
          Iterable<_i2.OrderCreateOrConnectWithoutBillingAddressInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.OrderUpsertWithWhereUniqueWithoutBillingAddressInput,
          Iterable<_i2.OrderUpsertWithWhereUniqueWithoutBillingAddressInput>>?
      upsert;

  final _i2.OrderCreateManyBillingAddressInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.OrderUpdateWithWhereUniqueWithoutBillingAddressInput,
          Iterable<_i2.OrderUpdateWithWhereUniqueWithoutBillingAddressInput>>?
      update;

  final _i1.PrismaUnion<_i2.OrderUpdateManyWithWhereWithoutBillingAddressInput,
          Iterable<_i2.OrderUpdateManyWithWhereWithoutBillingAddressInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OrderScalarWhereInput,
      Iterable<_i2.OrderScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class AddressUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedUpdateWithoutUserInput({
    this.id,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.shippingOrders,
    this.billingOrders,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderUncheckedUpdateManyWithoutShippingAddressNestedInput?
      shippingOrders;

  final _i2.OrderUncheckedUpdateManyWithoutBillingAddressNestedInput?
      billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.AddressWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.AddressUpdateWithoutUserInput,
      _i2.AddressUncheckedUpdateWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class AddressScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.AddressScalarWhereInput,
      Iterable<_i2.AddressScalarWhereInput>>? AND;

  final Iterable<_i2.AddressScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AddressScalarWhereInput,
      Iterable<_i2.AddressScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? addressLine1;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<_i2.StringFilter, String>? city;

  final _i1.PrismaUnion<_i2.StringFilter, String>? state;

  final _i1.PrismaUnion<_i2.StringFilter, String>? postalCode;

  final _i1.PrismaUnion<_i2.StringFilter, String>? country;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? isDefault;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateManyMutationInput({
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressUncheckedUpdateManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedUpdateManyWithoutUserInput({
    this.id,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.AddressScalarWhereInput where;

  final _i1.PrismaUnion<_i2.AddressUpdateManyMutationInput,
      _i2.AddressUncheckedUpdateManyWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class AddressUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.AddressCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.AddressCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.AddressUncheckedCreateWithoutUserInput,
              Iterable<_i2.AddressUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.AddressCreateOrConnectWithoutUserInput,
      Iterable<_i2.AddressCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.AddressUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.AddressUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.AddressCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.AddressUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.AddressUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.AddressUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.AddressUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.AddressScalarWhereInput,
      Iterable<_i2.AddressScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class CartItemUncheckedUpdateWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedUpdateWithoutCartInput({
    this.id,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemUpdateWithWhereUniqueWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateWithWhereUniqueWithoutCartInput({
    required this.where,
    required this.data,
  });

  final _i2.CartItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartItemUpdateWithoutCartInput,
      _i2.CartItemUncheckedUpdateWithoutCartInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CartItemUncheckedUpdateManyWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedUpdateManyWithoutCartInput({
    this.id,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemUpdateManyWithWhereWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateManyWithWhereWithoutCartInput({
    required this.where,
    required this.data,
  });

  final _i2.CartItemScalarWhereInput where;

  final _i1.PrismaUnion<_i2.CartItemUpdateManyMutationInput,
      _i2.CartItemUncheckedUpdateManyWithoutCartInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CartItemUncheckedUpdateManyWithoutCartNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedUpdateManyWithoutCartNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.CartItemCreateWithoutCartInput,
      _i1.PrismaUnion<
          Iterable<_i2.CartItemCreateWithoutCartInput>,
          _i1.PrismaUnion<_i2.CartItemUncheckedCreateWithoutCartInput,
              Iterable<_i2.CartItemUncheckedCreateWithoutCartInput>>>>? create;

  final _i1.PrismaUnion<_i2.CartItemCreateOrConnectWithoutCartInput,
      Iterable<_i2.CartItemCreateOrConnectWithoutCartInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.CartItemUpsertWithWhereUniqueWithoutCartInput,
      Iterable<_i2.CartItemUpsertWithWhereUniqueWithoutCartInput>>? upsert;

  final _i2.CartItemCreateManyCartInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.CartItemUpdateWithWhereUniqueWithoutCartInput,
      Iterable<_i2.CartItemUpdateWithWhereUniqueWithoutCartInput>>? update;

  final _i1.PrismaUnion<_i2.CartItemUpdateManyWithWhereWithoutCartInput,
      Iterable<_i2.CartItemUpdateManyWithWhereWithoutCartInput>>? updateMany;

  final _i1.PrismaUnion<_i2.CartItemScalarWhereInput,
      Iterable<_i2.CartItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class CartUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedUpdateWithoutUserInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CartItemUncheckedUpdateManyWithoutCartNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class CartUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.CartWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartUpdateWithoutUserInput,
      _i2.CartUncheckedUpdateWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CartScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.CartScalarWhereInput,
      Iterable<_i2.CartScalarWhereInput>>? AND;

  final Iterable<_i2.CartScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.CartScalarWhereInput,
      Iterable<_i2.CartScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpdateManyMutationInput({
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartUncheckedUpdateManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedUpdateManyWithoutUserInput({
    this.id,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.CartScalarWhereInput where;

  final _i1.PrismaUnion<_i2.CartUpdateManyMutationInput,
      _i2.CartUncheckedUpdateManyWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CartUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.CartCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.CartCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.CartUncheckedCreateWithoutUserInput,
              Iterable<_i2.CartUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.CartCreateOrConnectWithoutUserInput,
      Iterable<_i2.CartCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.CartUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.CartUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.CartCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.CartUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.CartUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.CartUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.CartUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.CartScalarWhereInput,
      Iterable<_i2.CartScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OrderUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateWithoutUserInput({
    this.id,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
    this.payments,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      shippingAddressId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      billingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderItemUncheckedUpdateManyWithoutOrderNestedInput? items;

  final _i2.PaymentUncheckedUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
        'payments': payments,
      };
}

class OrderUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutUserInput,
      _i2.OrderUncheckedUpdateWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderUncheckedUpdateManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateManyWithoutUserInput({
    this.id,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      shippingAddressId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      billingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrderUpdateManyMutationInput,
      _i2.OrderUncheckedUpdateManyWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OrderCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrderCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.OrderUncheckedCreateWithoutUserInput,
              Iterable<_i2.OrderUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutUserInput,
      Iterable<_i2.OrderCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrderUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.OrderUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.OrderCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrderUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.OrderUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.OrderUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.OrderUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrderScalarWhereInput,
      Iterable<_i2.OrderScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class WishlistUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.WishlistCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.WishlistCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.WishlistUncheckedCreateWithoutUserInput,
              Iterable<_i2.WishlistUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.WishlistCreateOrConnectWithoutUserInput,
      Iterable<_i2.WishlistCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.WishlistUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.WishlistUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.WishlistCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.WishlistWhereUniqueInput,
      Iterable<_i2.WishlistWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.WishlistUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.WishlistUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.WishlistUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.WishlistUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.WishlistScalarWhereInput,
      Iterable<_i2.WishlistScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UserUncheckedUpdateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutReviewsInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.wishlists,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUncheckedUpdateManyWithoutUserNestedInput? addresses;

  final _i2.CartUncheckedUpdateManyWithoutUserNestedInput? carts;

  final _i2.OrderUncheckedUpdateManyWithoutUserNestedInput? orders;

  final _i2.WishlistUncheckedUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'wishlists': wishlists,
      };
}

class UserUpsertWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutReviewsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UserUpdateWithoutReviewsInput,
      _i2.UserUncheckedUpdateWithoutReviewsInput> update;

  final _i1.PrismaUnion<_i2.UserCreateWithoutReviewsInput,
      _i2.UserUncheckedCreateWithoutReviewsInput> create;

  final _i2.UserWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UserUpdateToOneWithWhereWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateToOneWithWhereWithoutReviewsInput({
    this.where,
    required this.data,
  });

  final _i2.UserWhereInput? where;

  final _i1.PrismaUnion<_i2.UserUpdateWithoutReviewsInput,
      _i2.UserUncheckedUpdateWithoutReviewsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UserUpdateOneRequiredWithoutReviewsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutReviewsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutReviewsInput,
      _i2.UserUncheckedCreateWithoutReviewsInput>? create;

  final _i2.UserCreateOrConnectWithoutReviewsInput? connectOrCreate;

  final _i2.UserUpsertWithoutReviewsInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UserUpdateToOneWithWhereWithoutReviewsInput,
      _i1.PrismaUnion<_i2.UserUpdateWithoutReviewsInput,
          _i2.UserUncheckedUpdateWithoutReviewsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ReviewUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateWithoutProductInput({
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutReviewsNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class ReviewUpsertWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpsertWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ReviewWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ReviewUpdateWithoutProductInput,
      _i2.ReviewUncheckedUpdateWithoutProductInput> update;

  final _i1.PrismaUnion<_i2.ReviewCreateWithoutProductInput,
      _i2.ReviewUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ReviewUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.ReviewCreateWithoutProductInput,
      _i1.PrismaUnion<
          Iterable<_i2.ReviewCreateWithoutProductInput>,
          _i1.PrismaUnion<_i2.ReviewUncheckedCreateWithoutProductInput,
              Iterable<_i2.ReviewUncheckedCreateWithoutProductInput>>>>? create;

  final _i1.PrismaUnion<_i2.ReviewCreateOrConnectWithoutProductInput,
      Iterable<_i2.ReviewCreateOrConnectWithoutProductInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.ReviewUpsertWithWhereUniqueWithoutProductInput,
      Iterable<_i2.ReviewUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.ReviewCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ReviewUpdateWithWhereUniqueWithoutProductInput,
      Iterable<_i2.ReviewUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<_i2.ReviewUpdateManyWithWhereWithoutProductInput,
      Iterable<_i2.ReviewUpdateManyWithWhereWithoutProductInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ReviewScalarWhereInput,
      Iterable<_i2.ReviewScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UserUpdateWithoutWishlistsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutWishlistsInput({
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUpdateManyWithoutUserNestedInput? addresses;

  final _i2.CartUpdateManyWithoutUserNestedInput? carts;

  final _i2.OrderUpdateManyWithoutUserNestedInput? orders;

  final _i2.ReviewUpdateManyWithoutUserNestedInput? reviews;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
      };
}

class ReviewUncheckedUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedUpdateWithoutUserInput({
    this.id,
    this.productId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.ReviewWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ReviewUpdateWithoutUserInput,
      _i2.ReviewUncheckedUpdateWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ReviewUncheckedUpdateManyWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedUpdateManyWithoutUserInput({
    this.id,
    this.productId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  final _i2.ReviewScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ReviewUpdateManyMutationInput,
      _i2.ReviewUncheckedUpdateManyWithoutUserInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ReviewUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.ReviewCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.ReviewCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.ReviewUncheckedCreateWithoutUserInput,
              Iterable<_i2.ReviewUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.ReviewCreateOrConnectWithoutUserInput,
      Iterable<_i2.ReviewCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.ReviewUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.ReviewUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.ReviewCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ReviewUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.ReviewUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.ReviewUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.ReviewUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ReviewScalarWhereInput,
      Iterable<_i2.ReviewScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UserUncheckedUpdateWithoutWishlistsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutWishlistsInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUncheckedUpdateManyWithoutUserNestedInput? addresses;

  final _i2.CartUncheckedUpdateManyWithoutUserNestedInput? carts;

  final _i2.OrderUncheckedUpdateManyWithoutUserNestedInput? orders;

  final _i2.ReviewUncheckedUpdateManyWithoutUserNestedInput? reviews;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
      };
}

class UserUpsertWithoutWishlistsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutWishlistsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UserUpdateWithoutWishlistsInput,
      _i2.UserUncheckedUpdateWithoutWishlistsInput> update;

  final _i1.PrismaUnion<_i2.UserCreateWithoutWishlistsInput,
      _i2.UserUncheckedCreateWithoutWishlistsInput> create;

  final _i2.UserWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UserUpdateToOneWithWhereWithoutWishlistsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateToOneWithWhereWithoutWishlistsInput({
    this.where,
    required this.data,
  });

  final _i2.UserWhereInput? where;

  final _i1.PrismaUnion<_i2.UserUpdateWithoutWishlistsInput,
      _i2.UserUncheckedUpdateWithoutWishlistsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UserUpdateOneRequiredWithoutWishlistsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutWishlistsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutWishlistsInput,
      _i2.UserUncheckedCreateWithoutWishlistsInput>? create;

  final _i2.UserCreateOrConnectWithoutWishlistsInput? connectOrCreate;

  final _i2.UserUpsertWithoutWishlistsInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UserUpdateToOneWithWhereWithoutWishlistsInput,
      _i1.PrismaUnion<_i2.UserUpdateWithoutWishlistsInput,
          _i2.UserUncheckedUpdateWithoutWishlistsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class WishlistUpdateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpdateWithoutItemsInput({
    this.name,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutWishlistsNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class WishlistUncheckedUpdateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedUpdateWithoutItemsInput({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistUpsertWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpsertWithoutItemsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.WishlistUpdateWithoutItemsInput,
      _i2.WishlistUncheckedUpdateWithoutItemsInput> update;

  final _i1.PrismaUnion<_i2.WishlistCreateWithoutItemsInput,
      _i2.WishlistUncheckedCreateWithoutItemsInput> create;

  final _i2.WishlistWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class WishlistUpdateToOneWithWhereWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpdateToOneWithWhereWithoutItemsInput({
    this.where,
    required this.data,
  });

  final _i2.WishlistWhereInput? where;

  final _i1.PrismaUnion<_i2.WishlistUpdateWithoutItemsInput,
      _i2.WishlistUncheckedUpdateWithoutItemsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class WishlistUpdateOneRequiredWithoutItemsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpdateOneRequiredWithoutItemsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.WishlistCreateWithoutItemsInput,
      _i2.WishlistUncheckedCreateWithoutItemsInput>? create;

  final _i2.WishlistCreateOrConnectWithoutItemsInput? connectOrCreate;

  final _i2.WishlistUpsertWithoutItemsInput? upsert;

  final _i2.WishlistWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.WishlistUpdateToOneWithWhereWithoutItemsInput,
      _i1.PrismaUnion<_i2.WishlistUpdateWithoutItemsInput,
          _i2.WishlistUncheckedUpdateWithoutItemsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class WishlistItemUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateWithoutProductInput({
    this.addedAt,
    this.wishlist,
  });

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  final _i2.WishlistUpdateOneRequiredWithoutItemsNestedInput? wishlist;

  @override
  Map<String, dynamic> toJson() => {
        'addedAt': addedAt,
        'wishlist': wishlist,
      };
}

class WishlistItemUncheckedUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedUpdateWithoutProductInput({
    this.wishlistId,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? wishlistId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'addedAt': addedAt,
      };
}

class WishlistItemUpsertWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpsertWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.WishlistItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateWithoutProductInput,
      _i2.WishlistItemUncheckedUpdateWithoutProductInput> update;

  final _i1.PrismaUnion<_i2.WishlistItemCreateWithoutProductInput,
      _i2.WishlistItemUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class WishlistItemUpdateWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.WishlistItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateWithoutProductInput,
      _i2.WishlistItemUncheckedUpdateWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class WishlistItemUncheckedUpdateManyWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedUpdateManyWithoutProductInput({
    this.wishlistId,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? wishlistId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'addedAt': addedAt,
      };
}

class WishlistItemUpdateManyWithWhereWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateManyWithWhereWithoutProductInput({
    required this.where,
    required this.data,
  });

  final _i2.WishlistItemScalarWhereInput where;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateManyMutationInput,
      _i2.WishlistItemUncheckedUpdateManyWithoutProductInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class WishlistItemUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.WishlistItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.WishlistItemCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.WishlistItemUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.WishlistItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.WishlistItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.WishlistItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.WishlistItemUpsertWithWhereUniqueWithoutProductInput,
          Iterable<_i2.WishlistItemUpsertWithWhereUniqueWithoutProductInput>>?
      upsert;

  final _i2.WishlistItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.WishlistItemUpdateWithWhereUniqueWithoutProductInput,
          Iterable<_i2.WishlistItemUpdateWithWhereUniqueWithoutProductInput>>?
      update;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.WishlistItemUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.WishlistItemScalarWhereInput,
      Iterable<_i2.WishlistItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProductUpdateWithoutOrderItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateWithoutOrderItemsInput({
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUpdateManyWithoutProductNestedInput? categories;

  final _i2.ProductImageUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.ReviewUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUpdateManyWithoutProductNestedInput? wishlistItems;

  final _i2.ProductDiscountUpdateManyWithoutProductNestedInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.WishlistItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.WishlistItemCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.WishlistItemUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.WishlistItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.WishlistItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.WishlistItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.WishlistItemUpsertWithWhereUniqueWithoutProductInput,
          Iterable<_i2.WishlistItemUpsertWithWhereUniqueWithoutProductInput>>?
      upsert;

  final _i2.WishlistItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.WishlistItemWhereUniqueInput,
      Iterable<_i2.WishlistItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.WishlistItemUpdateWithWhereUniqueWithoutProductInput,
          Iterable<_i2.WishlistItemUpdateWithWhereUniqueWithoutProductInput>>?
      update;

  final _i1.PrismaUnion<_i2.WishlistItemUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.WishlistItemUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.WishlistItemScalarWhereInput,
      Iterable<_i2.WishlistItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProductUncheckedUpdateWithoutOrderItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedUpdateWithoutOrderItemsInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutProductNestedInput?
      categories;

  final _i2.ProductImageUncheckedUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUncheckedUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.ReviewUncheckedUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUncheckedUpdateManyWithoutProductNestedInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedUpdateManyWithoutProductNestedInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUpsertWithoutOrderItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpsertWithoutOrderItemsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutOrderItemsInput,
      _i2.ProductUncheckedUpdateWithoutOrderItemsInput> update;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutOrderItemsInput,
      _i2.ProductUncheckedCreateWithoutOrderItemsInput> create;

  final _i2.ProductWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ProductUpdateToOneWithWhereWithoutOrderItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateToOneWithWhereWithoutOrderItemsInput({
    this.where,
    required this.data,
  });

  final _i2.ProductWhereInput? where;

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutOrderItemsInput,
      _i2.ProductUncheckedUpdateWithoutOrderItemsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateOneRequiredWithoutOrderItemsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutOrderItemsInput,
      _i2.ProductUncheckedCreateWithoutOrderItemsInput>? create;

  final _i2.ProductCreateOrConnectWithoutOrderItemsInput? connectOrCreate;

  final _i2.ProductUpsertWithoutOrderItemsInput? upsert;

  final _i2.ProductWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ProductUpdateToOneWithWhereWithoutOrderItemsInput,
      _i1.PrismaUnion<_i2.ProductUpdateWithoutOrderItemsInput,
          _i2.ProductUncheckedUpdateWithoutOrderItemsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OrderItemUpdateWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateWithoutOrderInput({
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.product,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i2.ProductUpdateOneRequiredWithoutOrderItemsNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'product': product,
      };
}

class OrderItemUpsertWithWhereUniqueWithoutOrderInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpsertWithWhereUniqueWithoutOrderInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrderItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderItemUpdateWithoutOrderInput,
      _i2.OrderItemUncheckedUpdateWithoutOrderInput> update;

  final _i1.PrismaUnion<_i2.OrderItemCreateWithoutOrderInput,
      _i2.OrderItemUncheckedCreateWithoutOrderInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedUpdateManyWithoutOrderNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrderItemCreateWithoutOrderInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderItemCreateWithoutOrderInput>,
              _i1.PrismaUnion<_i2.OrderItemUncheckedCreateWithoutOrderInput,
                  Iterable<_i2.OrderItemUncheckedCreateWithoutOrderInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderItemCreateOrConnectWithoutOrderInput,
      Iterable<_i2.OrderItemCreateOrConnectWithoutOrderInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrderItemUpsertWithWhereUniqueWithoutOrderInput,
      Iterable<_i2.OrderItemUpsertWithWhereUniqueWithoutOrderInput>>? upsert;

  final _i2.OrderItemCreateManyOrderInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrderItemUpdateWithWhereUniqueWithoutOrderInput,
      Iterable<_i2.OrderItemUpdateWithWhereUniqueWithoutOrderInput>>? update;

  final _i1.PrismaUnion<_i2.OrderItemUpdateManyWithWhereWithoutOrderInput,
      Iterable<_i2.OrderItemUpdateManyWithWhereWithoutOrderInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrderItemScalarWhereInput,
      Iterable<_i2.OrderItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OrderUncheckedUpdateWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateWithoutShippingAddressInput({
    this.id,
    this.userId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
    this.payments,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      billingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderItemUncheckedUpdateManyWithoutOrderNestedInput? items;

  final _i2.PaymentUncheckedUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
        'payments': payments,
      };
}

class OrderUpdateWithWhereUniqueWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateWithWhereUniqueWithoutShippingAddressInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutShippingAddressInput,
      _i2.OrderUncheckedUpdateWithoutShippingAddressInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderUncheckedUpdateManyWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateManyWithoutShippingAddressInput({
    this.id,
    this.userId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      billingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderUpdateManyWithWhereWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateManyWithWhereWithoutShippingAddressInput({
    required this.where,
    required this.data,
  });

  final _i2.OrderScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrderUpdateManyMutationInput,
      _i2.OrderUncheckedUpdateManyWithoutShippingAddressInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderUncheckedUpdateManyWithoutShippingAddressNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateManyWithoutShippingAddressNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrderCreateWithoutShippingAddressInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderCreateWithoutShippingAddressInput>,
              _i1.PrismaUnion<
                  _i2.OrderUncheckedCreateWithoutShippingAddressInput,
                  Iterable<
                      _i2.OrderUncheckedCreateWithoutShippingAddressInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutShippingAddressInput,
          Iterable<_i2.OrderCreateOrConnectWithoutShippingAddressInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.OrderUpsertWithWhereUniqueWithoutShippingAddressInput,
          Iterable<_i2.OrderUpsertWithWhereUniqueWithoutShippingAddressInput>>?
      upsert;

  final _i2.OrderCreateManyShippingAddressInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.OrderUpdateWithWhereUniqueWithoutShippingAddressInput,
          Iterable<_i2.OrderUpdateWithWhereUniqueWithoutShippingAddressInput>>?
      update;

  final _i1.PrismaUnion<_i2.OrderUpdateManyWithWhereWithoutShippingAddressInput,
          Iterable<_i2.OrderUpdateManyWithWhereWithoutShippingAddressInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OrderScalarWhereInput,
      Iterable<_i2.OrderScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class AddressUncheckedUpdateWithoutBillingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedUpdateWithoutBillingOrdersInput({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.shippingOrders,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderUncheckedUpdateManyWithoutShippingAddressNestedInput?
      shippingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingOrders': shippingOrders,
      };
}

class AddressUpsertWithoutBillingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpsertWithoutBillingOrdersInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.AddressUpdateWithoutBillingOrdersInput,
      _i2.AddressUncheckedUpdateWithoutBillingOrdersInput> update;

  final _i1.PrismaUnion<_i2.AddressCreateWithoutBillingOrdersInput,
      _i2.AddressUncheckedCreateWithoutBillingOrdersInput> create;

  final _i2.AddressWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class AddressUpdateToOneWithWhereWithoutBillingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateToOneWithWhereWithoutBillingOrdersInput({
    this.where,
    required this.data,
  });

  final _i2.AddressWhereInput? where;

  final _i1.PrismaUnion<_i2.AddressUpdateWithoutBillingOrdersInput,
      _i2.AddressUncheckedUpdateWithoutBillingOrdersInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class AddressUpdateOneRequiredWithoutBillingOrdersNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateOneRequiredWithoutBillingOrdersNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.AddressCreateWithoutBillingOrdersInput,
      _i2.AddressUncheckedCreateWithoutBillingOrdersInput>? create;

  final _i2.AddressCreateOrConnectWithoutBillingOrdersInput? connectOrCreate;

  final _i2.AddressUpsertWithoutBillingOrdersInput? upsert;

  final _i2.AddressWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.AddressUpdateToOneWithWhereWithoutBillingOrdersInput,
      _i1.PrismaUnion<_i2.AddressUpdateWithoutBillingOrdersInput,
          _i2.AddressUncheckedUpdateWithoutBillingOrdersInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OrderUpdateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateWithoutItemsInput({
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.billingAddress,
    this.payments,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutOrdersNestedInput? user;

  final _i2.AddressUpdateOneRequiredWithoutShippingOrdersNestedInput?
      shippingAddress;

  final _i2.AddressUpdateOneRequiredWithoutBillingOrdersNestedInput?
      billingAddress;

  final _i2.PaymentUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'payments': payments,
      };
}

class OrderUncheckedUpdateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateWithoutItemsInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.payments,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      shippingAddressId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      billingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.PaymentUncheckedUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'payments': payments,
      };
}

class OrderUpsertWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpsertWithoutItemsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutItemsInput,
      _i2.OrderUncheckedUpdateWithoutItemsInput> update;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutItemsInput,
      _i2.OrderUncheckedCreateWithoutItemsInput> create;

  final _i2.OrderWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class OrderUpdateToOneWithWhereWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateToOneWithWhereWithoutItemsInput({
    this.where,
    required this.data,
  });

  final _i2.OrderWhereInput? where;

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutItemsInput,
      _i2.OrderUncheckedUpdateWithoutItemsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderUpdateOneRequiredWithoutItemsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateOneRequiredWithoutItemsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.OrderCreateWithoutItemsInput,
      _i2.OrderUncheckedCreateWithoutItemsInput>? create;

  final _i2.OrderCreateOrConnectWithoutItemsInput? connectOrCreate;

  final _i2.OrderUpsertWithoutItemsInput? upsert;

  final _i2.OrderWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.OrderUpdateToOneWithWhereWithoutItemsInput,
      _i1.PrismaUnion<_i2.OrderUpdateWithoutItemsInput,
          _i2.OrderUncheckedUpdateWithoutItemsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OrderItemUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateWithoutProductInput({
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.order,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i2.OrderUpdateOneRequiredWithoutItemsNestedInput? order;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
      };
}

class OrderItemUpsertWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpsertWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrderItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderItemUpdateWithoutProductInput,
      _i2.OrderItemUncheckedUpdateWithoutProductInput> update;

  final _i1.PrismaUnion<_i2.OrderItemCreateWithoutProductInput,
      _i2.OrderItemUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrderItemUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrderItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderItemCreateWithoutProductInput>,
              _i1.PrismaUnion<_i2.OrderItemUncheckedCreateWithoutProductInput,
                  Iterable<_i2.OrderItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.OrderItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OrderItemUpsertWithWhereUniqueWithoutProductInput,
      Iterable<_i2.OrderItemUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.OrderItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderItemWhereUniqueInput,
      Iterable<_i2.OrderItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrderItemUpdateWithWhereUniqueWithoutProductInput,
      Iterable<_i2.OrderItemUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<_i2.OrderItemUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.OrderItemUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OrderItemScalarWhereInput,
      Iterable<_i2.OrderItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProductUpdateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateWithoutReviewsInput({
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUpdateManyWithoutProductNestedInput? categories;

  final _i2.ProductImageUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.WishlistItemUpdateManyWithoutProductNestedInput? wishlistItems;

  final _i2.ProductDiscountUpdateManyWithoutProductNestedInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedUpdateWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedUpdateWithoutReviewsInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutProductNestedInput?
      categories;

  final _i2.ProductImageUncheckedUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUncheckedUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUncheckedUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.WishlistItemUncheckedUpdateManyWithoutProductNestedInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedUpdateManyWithoutProductNestedInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUpsertWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpsertWithoutReviewsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutReviewsInput,
      _i2.ProductUncheckedUpdateWithoutReviewsInput> update;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutReviewsInput,
      _i2.ProductUncheckedCreateWithoutReviewsInput> create;

  final _i2.ProductWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ProductUpdateToOneWithWhereWithoutReviewsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateToOneWithWhereWithoutReviewsInput({
    this.where,
    required this.data,
  });

  final _i2.ProductWhereInput? where;

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutReviewsInput,
      _i2.ProductUncheckedUpdateWithoutReviewsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductUpdateOneRequiredWithoutReviewsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateOneRequiredWithoutReviewsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutReviewsInput,
      _i2.ProductUncheckedCreateWithoutReviewsInput>? create;

  final _i2.ProductCreateOrConnectWithoutReviewsInput? connectOrCreate;

  final _i2.ProductUpsertWithoutReviewsInput? upsert;

  final _i2.ProductWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ProductUpdateToOneWithWhereWithoutReviewsInput,
      _i1.PrismaUnion<_i2.ProductUpdateWithoutReviewsInput,
          _i2.ProductUncheckedUpdateWithoutReviewsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ReviewUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateWithoutUserInput({
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.product,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductUpdateOneRequiredWithoutReviewsNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
      };
}

class ReviewUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ReviewWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ReviewUpdateWithoutUserInput,
      _i2.ReviewUncheckedUpdateWithoutUserInput> update;

  final _i1.PrismaUnion<_i2.ReviewCreateWithoutUserInput,
      _i2.ReviewUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ReviewUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.ReviewCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.ReviewCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.ReviewUncheckedCreateWithoutUserInput,
              Iterable<_i2.ReviewUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.ReviewCreateOrConnectWithoutUserInput,
      Iterable<_i2.ReviewCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.ReviewUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.ReviewUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.ReviewCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ReviewWhereUniqueInput,
      Iterable<_i2.ReviewWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ReviewUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.ReviewUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.ReviewUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.ReviewUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ReviewScalarWhereInput,
      Iterable<_i2.ReviewScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UserUpdateWithoutAddressesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutAddressesInput({
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CartUpdateManyWithoutUserNestedInput? carts;

  final _i2.OrderUpdateManyWithoutUserNestedInput? orders;

  final _i2.ReviewUpdateManyWithoutUserNestedInput? reviews;

  final _i2.WishlistUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUncheckedUpdateWithoutAddressesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutAddressesInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CartUncheckedUpdateManyWithoutUserNestedInput? carts;

  final _i2.OrderUncheckedUpdateManyWithoutUserNestedInput? orders;

  final _i2.ReviewUncheckedUpdateManyWithoutUserNestedInput? reviews;

  final _i2.WishlistUncheckedUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUpsertWithoutAddressesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutAddressesInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UserUpdateWithoutAddressesInput,
      _i2.UserUncheckedUpdateWithoutAddressesInput> update;

  final _i1.PrismaUnion<_i2.UserCreateWithoutAddressesInput,
      _i2.UserUncheckedCreateWithoutAddressesInput> create;

  final _i2.UserWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UserUpdateToOneWithWhereWithoutAddressesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateToOneWithWhereWithoutAddressesInput({
    this.where,
    required this.data,
  });

  final _i2.UserWhereInput? where;

  final _i1.PrismaUnion<_i2.UserUpdateWithoutAddressesInput,
      _i2.UserUncheckedUpdateWithoutAddressesInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UserUpdateOneRequiredWithoutAddressesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutAddressesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutAddressesInput,
      _i2.UserUncheckedCreateWithoutAddressesInput>? create;

  final _i2.UserCreateOrConnectWithoutAddressesInput? connectOrCreate;

  final _i2.UserUpsertWithoutAddressesInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UserUpdateToOneWithWhereWithoutAddressesInput,
      _i1.PrismaUnion<_i2.UserUpdateWithoutAddressesInput,
          _i2.UserUncheckedUpdateWithoutAddressesInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OrderUpdateManyWithoutBillingAddressNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateManyWithoutBillingAddressNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrderCreateWithoutBillingAddressInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderCreateWithoutBillingAddressInput>,
              _i1.PrismaUnion<
                  _i2.OrderUncheckedCreateWithoutBillingAddressInput,
                  Iterable<
                      _i2.OrderUncheckedCreateWithoutBillingAddressInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutBillingAddressInput,
          Iterable<_i2.OrderCreateOrConnectWithoutBillingAddressInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.OrderUpsertWithWhereUniqueWithoutBillingAddressInput,
          Iterable<_i2.OrderUpsertWithWhereUniqueWithoutBillingAddressInput>>?
      upsert;

  final _i2.OrderCreateManyBillingAddressInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.OrderUpdateWithWhereUniqueWithoutBillingAddressInput,
          Iterable<_i2.OrderUpdateWithWhereUniqueWithoutBillingAddressInput>>?
      update;

  final _i1.PrismaUnion<_i2.OrderUpdateManyWithWhereWithoutBillingAddressInput,
          Iterable<_i2.OrderUpdateManyWithWhereWithoutBillingAddressInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OrderScalarWhereInput,
      Iterable<_i2.OrderScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class AddressUpdateWithoutShippingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateWithoutShippingOrdersInput({
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.billingOrders,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutAddressesNestedInput? user;

  final _i2.OrderUpdateManyWithoutBillingAddressNestedInput? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'billingOrders': billingOrders,
      };
}

class AddressUncheckedUpdateWithoutShippingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedUpdateWithoutShippingOrdersInput({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.billingOrders,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderUncheckedUpdateManyWithoutBillingAddressNestedInput?
      billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'billingOrders': billingOrders,
      };
}

class AddressUpsertWithoutShippingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpsertWithoutShippingOrdersInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.AddressUpdateWithoutShippingOrdersInput,
      _i2.AddressUncheckedUpdateWithoutShippingOrdersInput> update;

  final _i1.PrismaUnion<_i2.AddressCreateWithoutShippingOrdersInput,
      _i2.AddressUncheckedCreateWithoutShippingOrdersInput> create;

  final _i2.AddressWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class AddressUpdateToOneWithWhereWithoutShippingOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateToOneWithWhereWithoutShippingOrdersInput({
    this.where,
    required this.data,
  });

  final _i2.AddressWhereInput? where;

  final _i1.PrismaUnion<_i2.AddressUpdateWithoutShippingOrdersInput,
      _i2.AddressUncheckedUpdateWithoutShippingOrdersInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class AddressUpdateOneRequiredWithoutShippingOrdersNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateOneRequiredWithoutShippingOrdersNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.AddressCreateWithoutShippingOrdersInput,
      _i2.AddressUncheckedCreateWithoutShippingOrdersInput>? create;

  final _i2.AddressCreateOrConnectWithoutShippingOrdersInput? connectOrCreate;

  final _i2.AddressUpsertWithoutShippingOrdersInput? upsert;

  final _i2.AddressWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.AddressUpdateToOneWithWhereWithoutShippingOrdersInput,
      _i1.PrismaUnion<_i2.AddressUpdateWithoutShippingOrdersInput,
          _i2.AddressUncheckedUpdateWithoutShippingOrdersInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OrderUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateWithoutUserInput({
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.shippingAddress,
    this.billingAddress,
    this.items,
    this.payments,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUpdateOneRequiredWithoutShippingOrdersNestedInput?
      shippingAddress;

  final _i2.AddressUpdateOneRequiredWithoutBillingOrdersNestedInput?
      billingAddress;

  final _i2.OrderItemUpdateManyWithoutOrderNestedInput? items;

  final _i2.PaymentUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
      };
}

class OrderUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutUserInput,
      _i2.OrderUncheckedUpdateWithoutUserInput> update;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutUserInput,
      _i2.OrderUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrderUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OrderCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrderCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.OrderUncheckedCreateWithoutUserInput,
              Iterable<_i2.OrderUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutUserInput,
      Iterable<_i2.OrderCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrderUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.OrderUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.OrderCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrderUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.OrderUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.OrderUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.OrderUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrderScalarWhereInput,
      Iterable<_i2.OrderScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UserUpdateWithoutCartsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutCartsInput({
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUpdateManyWithoutUserNestedInput? addresses;

  final _i2.OrderUpdateManyWithoutUserNestedInput? orders;

  final _i2.ReviewUpdateManyWithoutUserNestedInput? reviews;

  final _i2.WishlistUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUncheckedUpdateWithoutCartsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutCartsInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUncheckedUpdateManyWithoutUserNestedInput? addresses;

  final _i2.OrderUncheckedUpdateManyWithoutUserNestedInput? orders;

  final _i2.ReviewUncheckedUpdateManyWithoutUserNestedInput? reviews;

  final _i2.WishlistUncheckedUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUpsertWithoutCartsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutCartsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UserUpdateWithoutCartsInput,
      _i2.UserUncheckedUpdateWithoutCartsInput> update;

  final _i1.PrismaUnion<_i2.UserCreateWithoutCartsInput,
      _i2.UserUncheckedCreateWithoutCartsInput> create;

  final _i2.UserWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UserUpdateToOneWithWhereWithoutCartsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateToOneWithWhereWithoutCartsInput({
    this.where,
    required this.data,
  });

  final _i2.UserWhereInput? where;

  final _i1.PrismaUnion<_i2.UserUpdateWithoutCartsInput,
      _i2.UserUncheckedUpdateWithoutCartsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UserUpdateOneRequiredWithoutCartsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutCartsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutCartsInput,
      _i2.UserUncheckedCreateWithoutCartsInput>? create;

  final _i2.UserCreateOrConnectWithoutCartsInput? connectOrCreate;

  final _i2.UserUpsertWithoutCartsInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UserUpdateToOneWithWhereWithoutCartsInput,
      _i1.PrismaUnion<_i2.UserUpdateWithoutCartsInput,
          _i2.UserUncheckedUpdateWithoutCartsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class CartUpdateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpdateWithoutItemsInput({
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutCartsNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class CartUncheckedUpdateWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedUpdateWithoutItemsInput({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartUpsertWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpsertWithoutItemsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.CartUpdateWithoutItemsInput,
      _i2.CartUncheckedUpdateWithoutItemsInput> update;

  final _i1.PrismaUnion<_i2.CartCreateWithoutItemsInput,
      _i2.CartUncheckedCreateWithoutItemsInput> create;

  final _i2.CartWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class CartUpdateToOneWithWhereWithoutItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpdateToOneWithWhereWithoutItemsInput({
    this.where,
    required this.data,
  });

  final _i2.CartWhereInput? where;

  final _i1.PrismaUnion<_i2.CartUpdateWithoutItemsInput,
      _i2.CartUncheckedUpdateWithoutItemsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CartUpdateOneRequiredWithoutItemsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpdateOneRequiredWithoutItemsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.CartCreateWithoutItemsInput,
      _i2.CartUncheckedCreateWithoutItemsInput>? create;

  final _i2.CartCreateOrConnectWithoutItemsInput? connectOrCreate;

  final _i2.CartUpsertWithoutItemsInput? upsert;

  final _i2.CartWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.CartUpdateToOneWithWhereWithoutItemsInput,
      _i1.PrismaUnion<_i2.CartUpdateWithoutItemsInput,
          _i2.CartUncheckedUpdateWithoutItemsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class CartItemUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateWithoutProductInput({
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.cart,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  final _i2.CartUpdateOneRequiredWithoutItemsNestedInput? cart;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
      };
}

class CartItemUpsertWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpsertWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.CartItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartItemUpdateWithoutProductInput,
      _i2.CartItemUncheckedUpdateWithoutProductInput> update;

  final _i1.PrismaUnion<_i2.CartItemCreateWithoutProductInput,
      _i2.CartItemUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class CartItemUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.CartItemCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.CartItemCreateWithoutProductInput>,
              _i1.PrismaUnion<_i2.CartItemUncheckedCreateWithoutProductInput,
                  Iterable<_i2.CartItemUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.CartItemCreateOrConnectWithoutProductInput,
          Iterable<_i2.CartItemCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.CartItemUpsertWithWhereUniqueWithoutProductInput,
      Iterable<_i2.CartItemUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.CartItemCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.CartItemUpdateWithWhereUniqueWithoutProductInput,
      Iterable<_i2.CartItemUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<_i2.CartItemUpdateManyWithWhereWithoutProductInput,
      Iterable<_i2.CartItemUpdateManyWithWhereWithoutProductInput>>? updateMany;

  final _i1.PrismaUnion<_i2.CartItemScalarWhereInput,
      Iterable<_i2.CartItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProductUpdateWithoutCategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateWithoutCategoriesInput({
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductImageUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUpdateManyWithoutProductNestedInput? wishlistItems;

  final _i2.ProductDiscountUpdateManyWithoutProductNestedInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedUpdateWithoutCategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedUpdateWithoutCategoriesInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductImageUncheckedUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUncheckedUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUncheckedUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUncheckedUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUncheckedUpdateManyWithoutProductNestedInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedUpdateManyWithoutProductNestedInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUpsertWithoutCategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpsertWithoutCategoriesInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutCategoriesInput,
      _i2.ProductUncheckedUpdateWithoutCategoriesInput> update;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutCategoriesInput,
      _i2.ProductUncheckedCreateWithoutCategoriesInput> create;

  final _i2.ProductWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ProductUpdateToOneWithWhereWithoutCategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateToOneWithWhereWithoutCategoriesInput({
    this.where,
    required this.data,
  });

  final _i2.ProductWhereInput? where;

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutCategoriesInput,
      _i2.ProductUncheckedUpdateWithoutCategoriesInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductUpdateOneRequiredWithoutCategoriesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateOneRequiredWithoutCategoriesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutCategoriesInput,
      _i2.ProductUncheckedCreateWithoutCategoriesInput>? create;

  final _i2.ProductCreateOrConnectWithoutCategoriesInput? connectOrCreate;

  final _i2.ProductUpsertWithoutCategoriesInput? upsert;

  final _i2.ProductWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ProductUpdateToOneWithWhereWithoutCategoriesInput,
      _i1.PrismaUnion<_i2.ProductUpdateWithoutCategoriesInput,
          _i2.ProductUncheckedUpdateWithoutCategoriesInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ProductCategoryUpdateWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateWithoutCategoryInput({this.product});

  final _i2.ProductUpdateOneRequiredWithoutCategoriesNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {'product': product};
}

class ProductCategoryUncheckedUpdateWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedUpdateWithoutCategoryInput({this.productId});

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  @override
  Map<String, dynamic> toJson() => {'productId': productId};
}

class ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ProductCategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCategoryUpdateWithoutCategoryInput,
      _i2.ProductCategoryUncheckedUpdateWithoutCategoryInput> update;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateWithoutCategoryInput,
      _i2.ProductCategoryUncheckedCreateWithoutCategoryInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductCategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCategoryUpdateWithoutCategoryInput,
      _i2.ProductCategoryUncheckedUpdateWithoutCategoryInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductCategoryUncheckedUpdateManyWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedUpdateManyWithoutCategoryInput(
      {this.productId});

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  @override
  Map<String, dynamic> toJson() => {'productId': productId};
}

class ProductCategoryUpdateManyWithWhereWithoutCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateManyWithWhereWithoutCategoryInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductCategoryScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ProductCategoryUpdateManyMutationInput,
      _i2.ProductCategoryUncheckedUpdateManyWithoutCategoryInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductCategoryUpdateManyWithoutCategoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateManyWithoutCategoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductCategoryCreateWithoutCategoryInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductCategoryCreateWithoutCategoryInput>,
              _i1.PrismaUnion<
                  _i2.ProductCategoryUncheckedCreateWithoutCategoryInput,
                  Iterable<
                      _i2
                      .ProductCategoryUncheckedCreateWithoutCategoryInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateOrConnectWithoutCategoryInput,
          Iterable<_i2.ProductCategoryCreateOrConnectWithoutCategoryInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput,
          Iterable<
              _i2.ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput>>?
      upsert;

  final _i2.ProductCategoryCreateManyCategoryInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput,
          Iterable<
              _i2.ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ProductCategoryUpdateManyWithWhereWithoutCategoryInput,
          Iterable<_i2.ProductCategoryUpdateManyWithWhereWithoutCategoryInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductCategoryScalarWhereInput,
      Iterable<_i2.ProductCategoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class CategoryUpdateWithoutSubcategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateWithoutSubcategoriesInput({
    this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.products,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CategoryUpdateOneWithoutSubcategoriesNestedInput? parentCategory;

  final _i2.ProductCategoryUpdateManyWithoutCategoryNestedInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'products': products,
      };
}

class ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductCategoryCreateWithoutCategoryInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductCategoryCreateWithoutCategoryInput>,
              _i1.PrismaUnion<
                  _i2.ProductCategoryUncheckedCreateWithoutCategoryInput,
                  Iterable<
                      _i2
                      .ProductCategoryUncheckedCreateWithoutCategoryInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateOrConnectWithoutCategoryInput,
          Iterable<_i2.ProductCategoryCreateOrConnectWithoutCategoryInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput,
          Iterable<
              _i2.ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput>>?
      upsert;

  final _i2.ProductCategoryCreateManyCategoryInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput,
          Iterable<
              _i2.ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ProductCategoryUpdateManyWithWhereWithoutCategoryInput,
          Iterable<_i2.ProductCategoryUpdateManyWithWhereWithoutCategoryInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductCategoryScalarWhereInput,
      Iterable<_i2.ProductCategoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class CategoryUncheckedUpdateWithoutSubcategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedUpdateWithoutSubcategoriesInput({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.products,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? parentCategoryId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput?
      products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
      };
}

class CategoryUpsertWithoutSubcategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpsertWithoutSubcategoriesInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.CategoryUpdateWithoutSubcategoriesInput,
      _i2.CategoryUncheckedUpdateWithoutSubcategoriesInput> update;

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutSubcategoriesInput,
      _i2.CategoryUncheckedCreateWithoutSubcategoriesInput> create;

  final _i2.CategoryWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class CategoryUpdateToOneWithWhereWithoutSubcategoriesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateToOneWithWhereWithoutSubcategoriesInput({
    this.where,
    required this.data,
  });

  final _i2.CategoryWhereInput? where;

  final _i1.PrismaUnion<_i2.CategoryUpdateWithoutSubcategoriesInput,
      _i2.CategoryUncheckedUpdateWithoutSubcategoriesInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CategoryUpdateOneWithoutSubcategoriesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateOneWithoutSubcategoriesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutSubcategoriesInput,
      _i2.CategoryUncheckedCreateWithoutSubcategoriesInput>? create;

  final _i2.CategoryCreateOrConnectWithoutSubcategoriesInput? connectOrCreate;

  final _i2.CategoryUpsertWithoutSubcategoriesInput? upsert;

  final _i1.PrismaUnion<bool, _i2.CategoryWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.CategoryWhereInput>? delete;

  final _i2.CategoryWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.CategoryUpdateToOneWithWhereWithoutSubcategoriesInput,
      _i1.PrismaUnion<_i2.CategoryUpdateWithoutSubcategoriesInput,
          _i2.CategoryUncheckedUpdateWithoutSubcategoriesInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class CategoryUpdateWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateWithoutParentCategoryInput({
    this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.subcategories,
    this.products,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CategoryUpdateManyWithoutParentCategoryNestedInput? subcategories;

  final _i2.ProductCategoryUpdateManyWithoutCategoryNestedInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryUpdateWithWhereUniqueWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateWithWhereUniqueWithoutParentCategoryInput({
    required this.where,
    required this.data,
  });

  final _i2.CategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CategoryUpdateWithoutParentCategoryInput,
      _i2.CategoryUncheckedUpdateWithoutParentCategoryInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CategoryScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.CategoryScalarWhereInput,
      Iterable<_i2.CategoryScalarWhereInput>>? AND;

  final Iterable<_i2.CategoryScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.CategoryScalarWhereInput,
      Iterable<_i2.CategoryScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      parentCategoryId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategoryUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateManyMutationInput({
    this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategoryUncheckedUpdateManyWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedUpdateManyWithoutParentCategoryInput({
    this.id,
    this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategoryUpdateManyWithWhereWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateManyWithWhereWithoutParentCategoryInput({
    required this.where,
    required this.data,
  });

  final _i2.CategoryScalarWhereInput where;

  final _i1.PrismaUnion<_i2.CategoryUpdateManyMutationInput,
      _i2.CategoryUncheckedUpdateManyWithoutParentCategoryInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CategoryUncheckedUpdateManyWithoutParentCategoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedUpdateManyWithoutParentCategoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.CategoryCreateWithoutParentCategoryInput,
          _i1.PrismaUnion<
              Iterable<_i2.CategoryCreateWithoutParentCategoryInput>,
              _i1.PrismaUnion<
                  _i2.CategoryUncheckedCreateWithoutParentCategoryInput,
                  Iterable<
                      _i2.CategoryUncheckedCreateWithoutParentCategoryInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.CategoryCreateOrConnectWithoutParentCategoryInput,
          Iterable<_i2.CategoryCreateOrConnectWithoutParentCategoryInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.CategoryUpsertWithWhereUniqueWithoutParentCategoryInput,
      Iterable<
          _i2.CategoryUpsertWithWhereUniqueWithoutParentCategoryInput>>? upsert;

  final _i2.CategoryCreateManyParentCategoryInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.CategoryUpdateWithWhereUniqueWithoutParentCategoryInput,
      Iterable<
          _i2.CategoryUpdateWithWhereUniqueWithoutParentCategoryInput>>? update;

  final _i1.PrismaUnion<
          _i2.CategoryUpdateManyWithWhereWithoutParentCategoryInput,
          Iterable<_i2.CategoryUpdateManyWithWhereWithoutParentCategoryInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.CategoryScalarWhereInput,
      Iterable<_i2.CategoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class CategoryUncheckedUpdateWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedUpdateWithoutParentCategoryInput({
    this.id,
    this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.subcategories,
    this.products,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CategoryUncheckedUpdateManyWithoutParentCategoryNestedInput?
      subcategories;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput?
      products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryUpsertWithWhereUniqueWithoutParentCategoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpsertWithWhereUniqueWithoutParentCategoryInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.CategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CategoryUpdateWithoutParentCategoryInput,
      _i2.CategoryUncheckedUpdateWithoutParentCategoryInput> update;

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutParentCategoryInput,
      _i2.CategoryUncheckedCreateWithoutParentCategoryInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class CategoryUpdateManyWithoutParentCategoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateManyWithoutParentCategoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.CategoryCreateWithoutParentCategoryInput,
          _i1.PrismaUnion<
              Iterable<_i2.CategoryCreateWithoutParentCategoryInput>,
              _i1.PrismaUnion<
                  _i2.CategoryUncheckedCreateWithoutParentCategoryInput,
                  Iterable<
                      _i2.CategoryUncheckedCreateWithoutParentCategoryInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.CategoryCreateOrConnectWithoutParentCategoryInput,
          Iterable<_i2.CategoryCreateOrConnectWithoutParentCategoryInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.CategoryUpsertWithWhereUniqueWithoutParentCategoryInput,
      Iterable<
          _i2.CategoryUpsertWithWhereUniqueWithoutParentCategoryInput>>? upsert;

  final _i2.CategoryCreateManyParentCategoryInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.CategoryWhereUniqueInput,
      Iterable<_i2.CategoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.CategoryUpdateWithWhereUniqueWithoutParentCategoryInput,
      Iterable<
          _i2.CategoryUpdateWithWhereUniqueWithoutParentCategoryInput>>? update;

  final _i1.PrismaUnion<
          _i2.CategoryUpdateManyWithWhereWithoutParentCategoryInput,
          Iterable<_i2.CategoryUpdateManyWithWhereWithoutParentCategoryInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.CategoryScalarWhereInput,
      Iterable<_i2.CategoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class CategoryUpdateWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateWithoutProductsInput({
    this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.subcategories,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CategoryUpdateOneWithoutSubcategoriesNestedInput? parentCategory;

  final _i2.CategoryUpdateManyWithoutParentCategoryNestedInput? subcategories;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'subcategories': subcategories,
      };
}

class CategoryUncheckedUpdateWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedUpdateWithoutProductsInput({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.subcategories,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? parentCategoryId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CategoryUncheckedUpdateManyWithoutParentCategoryNestedInput?
      subcategories;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'subcategories': subcategories,
      };
}

class CategoryUpsertWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpsertWithoutProductsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.CategoryUpdateWithoutProductsInput,
      _i2.CategoryUncheckedUpdateWithoutProductsInput> update;

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutProductsInput,
      _i2.CategoryUncheckedCreateWithoutProductsInput> create;

  final _i2.CategoryWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class CategoryUpdateToOneWithWhereWithoutProductsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateToOneWithWhereWithoutProductsInput({
    this.where,
    required this.data,
  });

  final _i2.CategoryWhereInput? where;

  final _i1.PrismaUnion<_i2.CategoryUpdateWithoutProductsInput,
      _i2.CategoryUncheckedUpdateWithoutProductsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class CategoryUpdateOneRequiredWithoutProductsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateOneRequiredWithoutProductsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.CategoryCreateWithoutProductsInput,
      _i2.CategoryUncheckedCreateWithoutProductsInput>? create;

  final _i2.CategoryCreateOrConnectWithoutProductsInput? connectOrCreate;

  final _i2.CategoryUpsertWithoutProductsInput? upsert;

  final _i2.CategoryWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.CategoryUpdateToOneWithWhereWithoutProductsInput,
      _i1.PrismaUnion<_i2.CategoryUpdateWithoutProductsInput,
          _i2.CategoryUncheckedUpdateWithoutProductsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ProductCategoryUpdateWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateWithoutProductInput({this.category});

  final _i2.CategoryUpdateOneRequiredWithoutProductsNestedInput? category;

  @override
  Map<String, dynamic> toJson() => {'category': category};
}

class ProductCategoryUpsertWithWhereUniqueWithoutProductInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpsertWithWhereUniqueWithoutProductInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ProductCategoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCategoryUpdateWithoutProductInput,
      _i2.ProductCategoryUncheckedUpdateWithoutProductInput> update;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateWithoutProductInput,
      _i2.ProductCategoryUncheckedCreateWithoutProductInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ProductCategoryUpdateManyWithoutProductNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateManyWithoutProductNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductCategoryCreateWithoutProductInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductCategoryCreateWithoutProductInput>,
              _i1.PrismaUnion<
                  _i2.ProductCategoryUncheckedCreateWithoutProductInput,
                  Iterable<
                      _i2.ProductCategoryUncheckedCreateWithoutProductInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductCategoryCreateOrConnectWithoutProductInput,
          Iterable<_i2.ProductCategoryCreateOrConnectWithoutProductInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.ProductCategoryUpsertWithWhereUniqueWithoutProductInput,
      Iterable<
          _i2.ProductCategoryUpsertWithWhereUniqueWithoutProductInput>>? upsert;

  final _i2.ProductCategoryCreateManyProductInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductCategoryWhereUniqueInput,
      Iterable<_i2.ProductCategoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.ProductCategoryUpdateWithWhereUniqueWithoutProductInput,
      Iterable<
          _i2.ProductCategoryUpdateWithWhereUniqueWithoutProductInput>>? update;

  final _i1.PrismaUnion<
          _i2.ProductCategoryUpdateManyWithWhereWithoutProductInput,
          Iterable<_i2.ProductCategoryUpdateManyWithWhereWithoutProductInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductCategoryScalarWhereInput,
      Iterable<_i2.ProductCategoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProductUpdateWithoutCartItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateWithoutCartItemsInput({
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUpdateManyWithoutProductNestedInput? categories;

  final _i2.ProductImageUpdateManyWithoutProductNestedInput? images;

  final _i2.OrderItemUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUpdateManyWithoutProductNestedInput? wishlistItems;

  final _i2.ProductDiscountUpdateManyWithoutProductNestedInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedUpdateWithoutCartItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedUpdateWithoutCartItemsInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutProductNestedInput?
      categories;

  final _i2.ProductImageUncheckedUpdateManyWithoutProductNestedInput? images;

  final _i2.OrderItemUncheckedUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUncheckedUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUncheckedUpdateManyWithoutProductNestedInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedUpdateManyWithoutProductNestedInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUpsertWithoutCartItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpsertWithoutCartItemsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutCartItemsInput,
      _i2.ProductUncheckedUpdateWithoutCartItemsInput> update;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutCartItemsInput,
      _i2.ProductUncheckedCreateWithoutCartItemsInput> create;

  final _i2.ProductWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ProductUpdateToOneWithWhereWithoutCartItemsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateToOneWithWhereWithoutCartItemsInput({
    this.where,
    required this.data,
  });

  final _i2.ProductWhereInput? where;

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutCartItemsInput,
      _i2.ProductUncheckedUpdateWithoutCartItemsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductUpdateOneRequiredWithoutCartItemsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateOneRequiredWithoutCartItemsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutCartItemsInput,
      _i2.ProductUncheckedCreateWithoutCartItemsInput>? create;

  final _i2.ProductCreateOrConnectWithoutCartItemsInput? connectOrCreate;

  final _i2.ProductUpsertWithoutCartItemsInput? upsert;

  final _i2.ProductWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ProductUpdateToOneWithWhereWithoutCartItemsInput,
      _i1.PrismaUnion<_i2.ProductUpdateWithoutCartItemsInput,
          _i2.ProductUncheckedUpdateWithoutCartItemsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class CartItemUpdateWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateWithoutCartInput({
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.product,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  final _i2.ProductUpdateOneRequiredWithoutCartItemsNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'product': product,
      };
}

class CartItemUpsertWithWhereUniqueWithoutCartInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpsertWithWhereUniqueWithoutCartInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.CartItemWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartItemUpdateWithoutCartInput,
      _i2.CartItemUncheckedUpdateWithoutCartInput> update;

  final _i1.PrismaUnion<_i2.CartItemCreateWithoutCartInput,
      _i2.CartItemUncheckedCreateWithoutCartInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class CartItemUpdateManyWithoutCartNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateManyWithoutCartNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.CartItemCreateWithoutCartInput,
      _i1.PrismaUnion<
          Iterable<_i2.CartItemCreateWithoutCartInput>,
          _i1.PrismaUnion<_i2.CartItemUncheckedCreateWithoutCartInput,
              Iterable<_i2.CartItemUncheckedCreateWithoutCartInput>>>>? create;

  final _i1.PrismaUnion<_i2.CartItemCreateOrConnectWithoutCartInput,
      Iterable<_i2.CartItemCreateOrConnectWithoutCartInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.CartItemUpsertWithWhereUniqueWithoutCartInput,
      Iterable<_i2.CartItemUpsertWithWhereUniqueWithoutCartInput>>? upsert;

  final _i2.CartItemCreateManyCartInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.CartItemWhereUniqueInput,
      Iterable<_i2.CartItemWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.CartItemUpdateWithWhereUniqueWithoutCartInput,
      Iterable<_i2.CartItemUpdateWithWhereUniqueWithoutCartInput>>? update;

  final _i1.PrismaUnion<_i2.CartItemUpdateManyWithWhereWithoutCartInput,
      Iterable<_i2.CartItemUpdateManyWithWhereWithoutCartInput>>? updateMany;

  final _i1.PrismaUnion<_i2.CartItemScalarWhereInput,
      Iterable<_i2.CartItemScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class CartUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpdateWithoutUserInput({
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CartItemUpdateManyWithoutCartNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class CartUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.CartWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.CartUpdateWithoutUserInput,
      _i2.CartUncheckedUpdateWithoutUserInput> update;

  final _i1.PrismaUnion<_i2.CartCreateWithoutUserInput,
      _i2.CartUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class CartUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.CartCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.CartCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.CartUncheckedCreateWithoutUserInput,
              Iterable<_i2.CartUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.CartCreateOrConnectWithoutUserInput,
      Iterable<_i2.CartCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.CartUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.CartUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.CartCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.CartWhereUniqueInput,
      Iterable<_i2.CartWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.CartUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.CartUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.CartUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.CartUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.CartScalarWhereInput,
      Iterable<_i2.CartScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UserUpdateWithoutOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateWithoutOrdersInput({
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.reviews,
    this.wishlists,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUpdateManyWithoutUserNestedInput? addresses;

  final _i2.CartUpdateManyWithoutUserNestedInput? carts;

  final _i2.ReviewUpdateManyWithoutUserNestedInput? reviews;

  final _i2.WishlistUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUncheckedUpdateWithoutOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateWithoutOrdersInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.reviews,
    this.wishlists,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUncheckedUpdateManyWithoutUserNestedInput? addresses;

  final _i2.CartUncheckedUpdateManyWithoutUserNestedInput? carts;

  final _i2.ReviewUncheckedUpdateManyWithoutUserNestedInput? reviews;

  final _i2.WishlistUncheckedUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUpsertWithoutOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpsertWithoutOrdersInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UserUpdateWithoutOrdersInput,
      _i2.UserUncheckedUpdateWithoutOrdersInput> update;

  final _i1.PrismaUnion<_i2.UserCreateWithoutOrdersInput,
      _i2.UserUncheckedCreateWithoutOrdersInput> create;

  final _i2.UserWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UserUpdateToOneWithWhereWithoutOrdersInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateToOneWithWhereWithoutOrdersInput({
    this.where,
    required this.data,
  });

  final _i2.UserWhereInput? where;

  final _i1.PrismaUnion<_i2.UserUpdateWithoutOrdersInput,
      _i2.UserUncheckedUpdateWithoutOrdersInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UserUpdateOneRequiredWithoutOrdersNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateOneRequiredWithoutOrdersNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UserCreateWithoutOrdersInput,
      _i2.UserUncheckedCreateWithoutOrdersInput>? create;

  final _i2.UserCreateOrConnectWithoutOrdersInput? connectOrCreate;

  final _i2.UserUpsertWithoutOrdersInput? upsert;

  final _i2.UserWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UserUpdateToOneWithWhereWithoutOrdersInput,
      _i1.PrismaUnion<_i2.UserUpdateWithoutOrdersInput,
          _i2.UserUncheckedUpdateWithoutOrdersInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OrderUpdateWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateWithoutShippingAddressInput({
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.billingAddress,
    this.items,
    this.payments,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutOrdersNestedInput? user;

  final _i2.AddressUpdateOneRequiredWithoutBillingOrdersNestedInput?
      billingAddress;

  final _i2.OrderItemUpdateManyWithoutOrderNestedInput? items;

  final _i2.PaymentUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
      };
}

class OrderUpsertWithWhereUniqueWithoutShippingAddressInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpsertWithWhereUniqueWithoutShippingAddressInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutShippingAddressInput,
      _i2.OrderUncheckedUpdateWithoutShippingAddressInput> update;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutShippingAddressInput,
      _i2.OrderUncheckedCreateWithoutShippingAddressInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrderUpdateManyWithoutShippingAddressNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateManyWithoutShippingAddressNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrderCreateWithoutShippingAddressInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrderCreateWithoutShippingAddressInput>,
              _i1.PrismaUnion<
                  _i2.OrderUncheckedCreateWithoutShippingAddressInput,
                  Iterable<
                      _i2.OrderUncheckedCreateWithoutShippingAddressInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrderCreateOrConnectWithoutShippingAddressInput,
          Iterable<_i2.OrderCreateOrConnectWithoutShippingAddressInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.OrderUpsertWithWhereUniqueWithoutShippingAddressInput,
          Iterable<_i2.OrderUpsertWithWhereUniqueWithoutShippingAddressInput>>?
      upsert;

  final _i2.OrderCreateManyShippingAddressInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrderWhereUniqueInput,
      Iterable<_i2.OrderWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.OrderUpdateWithWhereUniqueWithoutShippingAddressInput,
          Iterable<_i2.OrderUpdateWithWhereUniqueWithoutShippingAddressInput>>?
      update;

  final _i1.PrismaUnion<_i2.OrderUpdateManyWithWhereWithoutShippingAddressInput,
          Iterable<_i2.OrderUpdateManyWithWhereWithoutShippingAddressInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OrderScalarWhereInput,
      Iterable<_i2.OrderScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class AddressUpdateWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateWithoutUserInput({
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.shippingOrders,
    this.billingOrders,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderUpdateManyWithoutShippingAddressNestedInput? shippingOrders;

  final _i2.OrderUpdateManyWithoutBillingAddressNestedInput? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.AddressWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.AddressUpdateWithoutUserInput,
      _i2.AddressUncheckedUpdateWithoutUserInput> update;

  final _i1.PrismaUnion<_i2.AddressCreateWithoutUserInput,
      _i2.AddressUncheckedCreateWithoutUserInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class AddressUpdateManyWithoutUserNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.AddressCreateWithoutUserInput,
      _i1.PrismaUnion<
          Iterable<_i2.AddressCreateWithoutUserInput>,
          _i1.PrismaUnion<_i2.AddressUncheckedCreateWithoutUserInput,
              Iterable<_i2.AddressUncheckedCreateWithoutUserInput>>>>? create;

  final _i1.PrismaUnion<_i2.AddressCreateOrConnectWithoutUserInput,
      Iterable<_i2.AddressCreateOrConnectWithoutUserInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.AddressUpsertWithWhereUniqueWithoutUserInput,
      Iterable<_i2.AddressUpsertWithWhereUniqueWithoutUserInput>>? upsert;

  final _i2.AddressCreateManyUserInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.AddressWhereUniqueInput,
      Iterable<_i2.AddressWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.AddressUpdateWithWhereUniqueWithoutUserInput,
      Iterable<_i2.AddressUpdateWithWhereUniqueWithoutUserInput>>? update;

  final _i1.PrismaUnion<_i2.AddressUpdateManyWithWhereWithoutUserInput,
      Iterable<_i2.AddressUpdateManyWithWhereWithoutUserInput>>? updateMany;

  final _i1.PrismaUnion<_i2.AddressScalarWhereInput,
      Iterable<_i2.AddressScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UserUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateInput({
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUpdateManyWithoutUserNestedInput? addresses;

  final _i2.CartUpdateManyWithoutUserNestedInput? carts;

  final _i2.OrderUpdateManyWithoutUserNestedInput? orders;

  final _i2.ReviewUpdateManyWithoutUserNestedInput? reviews;

  final _i2.WishlistUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.addresses,
    this.carts,
    this.orders,
    this.reviews,
    this.wishlists,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.AddressUncheckedUpdateManyWithoutUserNestedInput? addresses;

  final _i2.CartUncheckedUpdateManyWithoutUserNestedInput? carts;

  final _i2.OrderUncheckedUpdateManyWithoutUserNestedInput? orders;

  final _i2.ReviewUncheckedUpdateManyWithoutUserNestedInput? reviews;

  final _i2.WishlistUncheckedUpdateManyWithoutUserNestedInput? wishlists;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'addresses': addresses,
        'carts': carts,
        'orders': orders,
        'reviews': reviews,
        'wishlists': wishlists,
      };
}

class UserUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateManyMutationInput({
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UserUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateManyInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? password;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      firstName;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? lastName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UpdateManyUserAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyUserAndReturnOutputTypeSelect({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? email;

  final bool? password;

  final bool? firstName;

  final bool? lastName;

  final bool? phone;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UserCountAggregateOutputType {
  const UserCountAggregateOutputType({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory UserCountAggregateOutputType.fromJson(Map json) =>
      UserCountAggregateOutputType(
        id: json['id'],
        email: json['email'],
        password: json['password'],
        firstName: json['firstName'],
        lastName: json['lastName'],
        phone: json['phone'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? email;

  final int? password;

  final int? firstName;

  final int? lastName;

  final int? phone;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class UserAvgAggregateOutputType {
  const UserAvgAggregateOutputType({this.id});

  factory UserAvgAggregateOutputType.fromJson(Map json) =>
      UserAvgAggregateOutputType(id: json['id']);

  final double? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class UserSumAggregateOutputType {
  const UserSumAggregateOutputType({this.id});

  factory UserSumAggregateOutputType.fromJson(Map json) =>
      UserSumAggregateOutputType(id: json['id']);

  final int? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class UserMinAggregateOutputType {
  const UserMinAggregateOutputType({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  factory UserMinAggregateOutputType.fromJson(Map json) =>
      UserMinAggregateOutputType(
        id: json['id'],
        email: json['email'],
        password: json['password'],
        firstName: json['firstName'],
        lastName: json['lastName'],
        phone: json['phone'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final String? email;

  final String? password;

  final String? firstName;

  final String? lastName;

  final String? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class UserMaxAggregateOutputType {
  const UserMaxAggregateOutputType({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  factory UserMaxAggregateOutputType.fromJson(Map json) =>
      UserMaxAggregateOutputType(
        id: json['id'],
        email: json['email'],
        password: json['password'],
        firstName: json['firstName'],
        lastName: json['lastName'],
        phone: json['phone'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final String? email;

  final String? password;

  final String? firstName;

  final String? lastName;

  final String? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class UserGroupByOutputType {
  const UserGroupByOutputType({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory UserGroupByOutputType.fromJson(Map json) => UserGroupByOutputType(
        id: json['id'],
        email: json['email'],
        password: json['password'],
        firstName: json['firstName'],
        lastName: json['lastName'],
        phone: json['phone'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
        $count: json['_count'] is Map
            ? _i2.UserCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UserAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UserSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UserMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UserMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? email;

  final String? password;

  final String? firstName;

  final String? lastName;

  final String? phone;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCountAggregateOutputType? $count;

  final _i2.UserAvgAggregateOutputType? $avg;

  final _i2.UserSumAggregateOutputType? $sum;

  final _i2.UserMinAggregateOutputType? $min;

  final _i2.UserMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class UserCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountOrderByAggregateInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? firstName;

  final _i2.SortOrder? lastName;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UserAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserAvgOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class UserMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMaxOrderByAggregateInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? firstName;

  final _i2.SortOrder? lastName;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UserMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMinOrderByAggregateInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? firstName;

  final _i2.SortOrder? lastName;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UserSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSumOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class UserOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserOrderByWithAggregationInput({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? firstName;

  final _i2.SortOrder? lastName;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.UserCountOrderByAggregateInput? $count;

  final _i2.UserAvgOrderByAggregateInput? $avg;

  final _i2.UserMaxOrderByAggregateInput? $max;

  final _i2.UserMinOrderByAggregateInput? $min;

  final _i2.UserSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedFloatFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double, _i1.Reference<double>>? equals;

  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedIntWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedIntFilter? $sum;

  final _i2.NestedIntFilter? $min;

  final _i2.NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class IntWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedIntFilter? $sum;

  final _i2.NestedIntFilter? $min;

  final _i2.NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class NestedStringWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String, _i1.Reference<String>>? equals;

  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<String, _i2.NestedStringWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedStringFilter? $min;

  final _i2.NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class StringWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String, _i1.Reference<String>>? equals;

  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<String, _i2.NestedStringWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedStringFilter? $min;

  final _i2.NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedStringNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NestedStringNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedStringNullableFilter? $min;

  final _i2.NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class StringNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NestedStringNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedStringNullableFilter? $min;

  final _i2.NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedDateTimeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDateTimeFilter? $min;

  final _i2.NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class DateTimeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDateTimeFilter? $min;

  final _i2.NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class UserScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.UserScalarWhereWithAggregatesInput,
      Iterable<_i2.UserScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.UserScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.UserScalarWhereWithAggregatesInput,
      Iterable<_i2.UserScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? email;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? password;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? firstName;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? lastName;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UserCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountAggregateOutputTypeSelect({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? email;

  final bool? password;

  final bool? firstName;

  final bool? lastName;

  final bool? phone;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class UserGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeCountArgs({this.select});

  final _i2.UserCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserAvgAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class UserGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeAvgArgs({this.select});

  final _i2.UserAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSumAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class UserGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeSumArgs({this.select});

  final _i2.UserSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMinAggregateOutputTypeSelect({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? email;

  final bool? password;

  final bool? firstName;

  final bool? lastName;

  final bool? phone;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UserGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeMinArgs({this.select});

  final _i2.UserMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMaxAggregateOutputTypeSelect({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? email;

  final bool? password;

  final bool? firstName;

  final bool? lastName;

  final bool? phone;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UserGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeMaxArgs({this.select});

  final _i2.UserMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeSelect({
    this.id,
    this.email,
    this.password,
    this.firstName,
    this.lastName,
    this.phone,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? email;

  final bool? password;

  final bool? firstName;

  final bool? lastName;

  final bool? phone;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateUser {
  const AggregateUser({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateUser.fromJson(Map json) => AggregateUser(
        $count: json['_count'] is Map
            ? _i2.UserCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UserAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UserSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UserMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UserMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.UserCountAggregateOutputType? $count;

  final _i2.UserAvgAggregateOutputType? $avg;

  final _i2.UserSumAggregateOutputType? $sum;

  final _i2.UserMinAggregateOutputType? $min;

  final _i2.UserMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateUserCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserCountArgs({this.select});

  final _i2.UserCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserAvgArgs({this.select});

  final _i2.UserAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserSumArgs({this.select});

  final _i2.UserSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserMinArgs({this.select});

  final _i2.UserMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserMaxArgs({this.select});

  final _i2.UserMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateUserCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateUserAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateUserSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateUserMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateUserMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AddressCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateInput({
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    required this.user,
    this.shippingOrders,
    this.billingOrders,
  });

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutAddressesInput user;

  final _i2.OrderCreateNestedManyWithoutShippingAddressInput? shippingOrders;

  final _i2.OrderCreateNestedManyWithoutBillingAddressInput? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedCreateInput({
    this.id,
    required this.userId,
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.shippingOrders,
    this.billingOrders,
  });

  final int? id;

  final int userId;

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderUncheckedCreateNestedManyWithoutShippingAddressInput?
      shippingOrders;

  final _i2.OrderUncheckedCreateNestedManyWithoutBillingAddressInput?
      billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCreateManyInput({
    this.id,
    required this.userId,
    required this.addressLine1,
    this.addressLine2,
    required this.city,
    required this.state,
    required this.postalCode,
    required this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final String addressLine1;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? addressLine2;

  final String city;

  final String state;

  final String postalCode;

  final String country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CreateManyAddressAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyAddressAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyAddressAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyAddressAndReturnOutputTypeSelect({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final bool? id;

  final bool? userId;

  final bool? addressLine1;

  final bool? addressLine2;

  final bool? city;

  final bool? state;

  final bool? postalCode;

  final bool? country;

  final bool? isDefault;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.CreateManyAddressAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class CreateManyAddressAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyAddressAndReturnOutputTypeInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.CreateManyAddressAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class AddressUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUpdateInput({
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingOrders,
    this.billingOrders,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutAddressesNestedInput? user;

  final _i2.OrderUpdateManyWithoutShippingAddressNestedInput? shippingOrders;

  final _i2.OrderUpdateManyWithoutBillingAddressNestedInput? billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedUpdateInput({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.shippingOrders,
    this.billingOrders,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderUncheckedUpdateManyWithoutShippingAddressNestedInput?
      shippingOrders;

  final _i2.OrderUncheckedUpdateManyWithoutBillingAddressNestedInput?
      billingOrders;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'shippingOrders': shippingOrders,
        'billingOrders': billingOrders,
      };
}

class AddressUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      addressLine1;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? city;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? state;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      postalCode;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? country;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isDefault;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UpdateManyAddressAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyAddressAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyAddressAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyAddressAndReturnOutputTypeSelect({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final bool? id;

  final bool? userId;

  final bool? addressLine1;

  final bool? addressLine2;

  final bool? city;

  final bool? state;

  final bool? postalCode;

  final bool? country;

  final bool? isDefault;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.UpdateManyAddressAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class UpdateManyAddressAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyAddressAndReturnOutputTypeInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.UpdateManyAddressAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class AddressCountAggregateOutputType {
  const AddressCountAggregateOutputType({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory AddressCountAggregateOutputType.fromJson(Map json) =>
      AddressCountAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        addressLine1: json['addressLine1'],
        addressLine2: json['addressLine2'],
        city: json['city'],
        state: json['state'],
        postalCode: json['postalCode'],
        country: json['country'],
        isDefault: json['isDefault'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? addressLine1;

  final int? addressLine2;

  final int? city;

  final int? state;

  final int? postalCode;

  final int? country;

  final int? isDefault;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class AddressAvgAggregateOutputType {
  const AddressAvgAggregateOutputType({
    this.id,
    this.userId,
  });

  factory AddressAvgAggregateOutputType.fromJson(Map json) =>
      AddressAvgAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
      );

  final double? id;

  final double? userId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class AddressSumAggregateOutputType {
  const AddressSumAggregateOutputType({
    this.id,
    this.userId,
  });

  factory AddressSumAggregateOutputType.fromJson(Map json) =>
      AddressSumAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
      );

  final int? id;

  final int? userId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class AddressMinAggregateOutputType {
  const AddressMinAggregateOutputType({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  factory AddressMinAggregateOutputType.fromJson(Map json) =>
      AddressMinAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        addressLine1: json['addressLine1'],
        addressLine2: json['addressLine2'],
        city: json['city'],
        state: json['state'],
        postalCode: json['postalCode'],
        country: json['country'],
        isDefault: json['isDefault'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? userId;

  final String? addressLine1;

  final String? addressLine2;

  final String? city;

  final String? state;

  final String? postalCode;

  final String? country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class AddressMaxAggregateOutputType {
  const AddressMaxAggregateOutputType({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  factory AddressMaxAggregateOutputType.fromJson(Map json) =>
      AddressMaxAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        addressLine1: json['addressLine1'],
        addressLine2: json['addressLine2'],
        city: json['city'],
        state: json['state'],
        postalCode: json['postalCode'],
        country: json['country'],
        isDefault: json['isDefault'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? userId;

  final String? addressLine1;

  final String? addressLine2;

  final String? city;

  final String? state;

  final String? postalCode;

  final String? country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class AddressGroupByOutputType {
  const AddressGroupByOutputType({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AddressGroupByOutputType.fromJson(Map json) =>
      AddressGroupByOutputType(
        id: json['id'],
        userId: json['userId'],
        addressLine1: json['addressLine1'],
        addressLine2: json['addressLine2'],
        city: json['city'],
        state: json['state'],
        postalCode: json['postalCode'],
        country: json['country'],
        isDefault: json['isDefault'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
        $count: json['_count'] is Map
            ? _i2.AddressCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.AddressAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.AddressSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AddressMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AddressMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? userId;

  final String? addressLine1;

  final String? addressLine2;

  final String? city;

  final String? state;

  final String? postalCode;

  final String? country;

  final bool? isDefault;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AddressCountAggregateOutputType? $count;

  final _i2.AddressAvgAggregateOutputType? $avg;

  final _i2.AddressSumAggregateOutputType? $sum;

  final _i2.AddressMinAggregateOutputType? $min;

  final _i2.AddressMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AddressCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? addressLine1;

  final _i2.SortOrder? addressLine2;

  final _i2.SortOrder? city;

  final _i2.SortOrder? state;

  final _i2.SortOrder? postalCode;

  final _i2.SortOrder? country;

  final _i2.SortOrder? isDefault;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressAvgOrderByAggregateInput({
    this.id,
    this.userId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class AddressMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? addressLine1;

  final _i2.SortOrder? addressLine2;

  final _i2.SortOrder? city;

  final _i2.SortOrder? state;

  final _i2.SortOrder? postalCode;

  final _i2.SortOrder? country;

  final _i2.SortOrder? isDefault;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? addressLine1;

  final _i2.SortOrder? addressLine2;

  final _i2.SortOrder? city;

  final _i2.SortOrder? state;

  final _i2.SortOrder? postalCode;

  final _i2.SortOrder? country;

  final _i2.SortOrder? isDefault;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressSumOrderByAggregateInput({
    this.id,
    this.userId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class AddressOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? addressLine1;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? addressLine2;

  final _i2.SortOrder? city;

  final _i2.SortOrder? state;

  final _i2.SortOrder? postalCode;

  final _i2.SortOrder? country;

  final _i2.SortOrder? isDefault;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.AddressCountOrderByAggregateInput? $count;

  final _i2.AddressAvgOrderByAggregateInput? $avg;

  final _i2.AddressMaxOrderByAggregateInput? $max;

  final _i2.AddressMinOrderByAggregateInput? $min;

  final _i2.AddressSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedBoolWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedBoolFilter? $min;

  final _i2.NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class BoolWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedBoolFilter? $min;

  final _i2.NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AddressScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.AddressScalarWhereWithAggregatesInput,
      Iterable<_i2.AddressScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.AddressScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.AddressScalarWhereWithAggregatesInput,
      Iterable<_i2.AddressScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? userId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? addressLine1;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? addressLine2;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? city;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? state;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? postalCode;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? country;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? isDefault;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? addressLine1;

  final bool? addressLine2;

  final bool? city;

  final bool? state;

  final bool? postalCode;

  final bool? country;

  final bool? isDefault;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class AddressGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressGroupByOutputTypeCountArgs({this.select});

  final _i2.AddressCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AddressAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
  });

  final bool? id;

  final bool? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class AddressGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressGroupByOutputTypeAvgArgs({this.select});

  final _i2.AddressAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AddressSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
  });

  final bool? id;

  final bool? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class AddressGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressGroupByOutputTypeSumArgs({this.select});

  final _i2.AddressSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AddressMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? addressLine1;

  final bool? addressLine2;

  final bool? city;

  final bool? state;

  final bool? postalCode;

  final bool? country;

  final bool? isDefault;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressGroupByOutputTypeMinArgs({this.select});

  final _i2.AddressMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AddressMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? addressLine1;

  final bool? addressLine2;

  final bool? city;

  final bool? state;

  final bool? postalCode;

  final bool? country;

  final bool? isDefault;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class AddressGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressGroupByOutputTypeMaxArgs({this.select});

  final _i2.AddressMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AddressGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AddressGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.addressLine1,
    this.addressLine2,
    this.city,
    this.state,
    this.postalCode,
    this.country,
    this.isDefault,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? addressLine1;

  final bool? addressLine2;

  final bool? city;

  final bool? state;

  final bool? postalCode;

  final bool? country;

  final bool? isDefault;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.AddressGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AddressGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AddressGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AddressGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AddressGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'addressLine1': addressLine1,
        'addressLine2': addressLine2,
        'city': city,
        'state': state,
        'postalCode': postalCode,
        'country': country,
        'isDefault': isDefault,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateAddress {
  const AggregateAddress({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateAddress.fromJson(Map json) => AggregateAddress(
        $count: json['_count'] is Map
            ? _i2.AddressCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.AddressAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.AddressSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AddressMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AddressMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.AddressCountAggregateOutputType? $count;

  final _i2.AddressAvgAggregateOutputType? $avg;

  final _i2.AddressSumAggregateOutputType? $sum;

  final _i2.AddressMinAggregateOutputType? $min;

  final _i2.AddressMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateAddressCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAddressCountArgs({this.select});

  final _i2.AddressCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAddressAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAddressAvgArgs({this.select});

  final _i2.AddressAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAddressSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAddressSumArgs({this.select});

  final _i2.AddressSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAddressMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAddressMinArgs({this.select});

  final _i2.AddressMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAddressMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAddressMaxArgs({this.select});

  final _i2.AddressMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAddressSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAddressSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateAddressCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateAddressAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateAddressSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateAddressMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateAddressMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class CategoryCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateInput({
    required this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.subcategories,
    this.products,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CategoryCreateNestedOneWithoutSubcategoriesInput? parentCategory;

  final _i2.CategoryCreateNestedManyWithoutParentCategoryInput? subcategories;

  final _i2.ProductCategoryCreateNestedManyWithoutCategoryInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedCreateInput({
    this.id,
    required this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.subcategories,
    this.products,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? parentCategoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CategoryUncheckedCreateNestedManyWithoutParentCategoryInput?
      subcategories;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput?
      products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateManyInput({
    this.id,
    required this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? parentCategoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CreateManyCategoryAndReturnOutputTypeParentCategoryArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCategoryAndReturnOutputTypeParentCategoryArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.CategoryWhereInput? where;

  final _i2.CategorySelect? select;

  final _i2.CategoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class CreateManyCategoryAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCategoryAndReturnOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? parentCategoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool,
          _i2.CreateManyCategoryAndReturnOutputTypeParentCategoryArgs>?
      parentCategory;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
      };
}

class CreateManyCategoryAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCategoryAndReturnOutputTypeInclude({this.parentCategory});

  final _i1.PrismaUnion<bool,
          _i2.CreateManyCategoryAndReturnOutputTypeParentCategoryArgs>?
      parentCategory;

  @override
  Map<String, dynamic> toJson() => {'parentCategory': parentCategory};
}

class CategoryUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateInput({
    this.name,
    this.description,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
    this.subcategories,
    this.products,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CategoryUpdateOneWithoutSubcategoriesNestedInput? parentCategory;

  final _i2.CategoryUpdateManyWithoutParentCategoryNestedInput? subcategories;

  final _i2.ProductCategoryUpdateManyWithoutCategoryNestedInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedUpdateInput({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.subcategories,
    this.products,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? parentCategoryId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CategoryUncheckedUpdateManyWithoutParentCategoryNestedInput?
      subcategories;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput?
      products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'subcategories': subcategories,
        'products': products,
      };
}

class CategoryUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? parentCategoryId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UpdateManyCategoryAndReturnOutputTypeParentCategoryArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCategoryAndReturnOutputTypeParentCategoryArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.CategoryWhereInput? where;

  final _i2.CategorySelect? select;

  final _i2.CategoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class UpdateManyCategoryAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCategoryAndReturnOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.parentCategory,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? parentCategoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool,
          _i2.UpdateManyCategoryAndReturnOutputTypeParentCategoryArgs>?
      parentCategory;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'parentCategory': parentCategory,
      };
}

class UpdateManyCategoryAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCategoryAndReturnOutputTypeInclude({this.parentCategory});

  final _i1.PrismaUnion<bool,
          _i2.UpdateManyCategoryAndReturnOutputTypeParentCategoryArgs>?
      parentCategory;

  @override
  Map<String, dynamic> toJson() => {'parentCategory': parentCategory};
}

class CategoryCountAggregateOutputType {
  const CategoryCountAggregateOutputType({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory CategoryCountAggregateOutputType.fromJson(Map json) =>
      CategoryCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        description: json['description'],
        parentCategoryId: json['parentCategoryId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? description;

  final int? parentCategoryId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class CategoryAvgAggregateOutputType {
  const CategoryAvgAggregateOutputType({
    this.id,
    this.parentCategoryId,
  });

  factory CategoryAvgAggregateOutputType.fromJson(Map json) =>
      CategoryAvgAggregateOutputType(
        id: json['id'],
        parentCategoryId: json['parentCategoryId'],
      );

  final double? id;

  final double? parentCategoryId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'parentCategoryId': parentCategoryId,
      };
}

class CategorySumAggregateOutputType {
  const CategorySumAggregateOutputType({
    this.id,
    this.parentCategoryId,
  });

  factory CategorySumAggregateOutputType.fromJson(Map json) =>
      CategorySumAggregateOutputType(
        id: json['id'],
        parentCategoryId: json['parentCategoryId'],
      );

  final int? id;

  final int? parentCategoryId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'parentCategoryId': parentCategoryId,
      };
}

class CategoryMinAggregateOutputType {
  const CategoryMinAggregateOutputType({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  factory CategoryMinAggregateOutputType.fromJson(Map json) =>
      CategoryMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        description: json['description'],
        parentCategoryId: json['parentCategoryId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final String? name;

  final String? description;

  final int? parentCategoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class CategoryMaxAggregateOutputType {
  const CategoryMaxAggregateOutputType({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  factory CategoryMaxAggregateOutputType.fromJson(Map json) =>
      CategoryMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        description: json['description'],
        parentCategoryId: json['parentCategoryId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final String? name;

  final String? description;

  final int? parentCategoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class CategoryGroupByOutputType {
  const CategoryGroupByOutputType({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory CategoryGroupByOutputType.fromJson(Map json) =>
      CategoryGroupByOutputType(
        id: json['id'],
        name: json['name'],
        description: json['description'],
        parentCategoryId: json['parentCategoryId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
        $count: json['_count'] is Map
            ? _i2.CategoryCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.CategoryAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.CategorySumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.CategoryMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CategoryMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? name;

  final String? description;

  final int? parentCategoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CategoryCountAggregateOutputType? $count;

  final _i2.CategoryAvgAggregateOutputType? $avg;

  final _i2.CategorySumAggregateOutputType? $sum;

  final _i2.CategoryMinAggregateOutputType? $min;

  final _i2.CategoryMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class CategoryCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCountOrderByAggregateInput({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? description;

  final _i2.SortOrder? parentCategoryId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategoryAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryAvgOrderByAggregateInput({
    this.id,
    this.parentCategoryId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? parentCategoryId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'parentCategoryId': parentCategoryId,
      };
}

class CategoryMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? description;

  final _i2.SortOrder? parentCategoryId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategoryMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryMinOrderByAggregateInput({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? description;

  final _i2.SortOrder? parentCategoryId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategorySumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategorySumOrderByAggregateInput({
    this.id,
    this.parentCategoryId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? parentCategoryId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'parentCategoryId': parentCategoryId,
      };
}

class CategoryOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryOrderByWithAggregationInput({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? parentCategoryId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.CategoryCountOrderByAggregateInput? $count;

  final _i2.CategoryAvgOrderByAggregateInput? $avg;

  final _i2.CategoryMaxOrderByAggregateInput? $max;

  final _i2.CategoryMinOrderByAggregateInput? $min;

  final _i2.CategorySumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedFloatNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i1.Reference<double>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i2.NestedFloatNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedIntNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NestedIntNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedIntNullableFilter? $sum;

  final _i2.NestedIntNullableFilter? $min;

  final _i2.NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class IntNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NestedIntNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedIntNullableFilter? $sum;

  final _i2.NestedIntNullableFilter? $min;

  final _i2.NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class CategoryScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.CategoryScalarWhereWithAggregatesInput,
      Iterable<_i2.CategoryScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.CategoryScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.CategoryScalarWhereWithAggregatesInput,
      Iterable<_i2.CategoryScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? parentCategoryId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategoryCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? parentCategoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class CategoryGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeCountArgs({this.select});

  final _i2.CategoryCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategoryAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryAvgAggregateOutputTypeSelect({
    this.id,
    this.parentCategoryId,
  });

  final bool? id;

  final bool? parentCategoryId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'parentCategoryId': parentCategoryId,
      };
}

class CategoryGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeAvgArgs({this.select});

  final _i2.CategoryAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategorySumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategorySumAggregateOutputTypeSelect({
    this.id,
    this.parentCategoryId,
  });

  final bool? id;

  final bool? parentCategoryId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'parentCategoryId': parentCategoryId,
      };
}

class CategoryGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeSumArgs({this.select});

  final _i2.CategorySumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategoryMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? parentCategoryId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategoryGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeMinArgs({this.select});

  final _i2.CategoryMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategoryMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? parentCategoryId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CategoryGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeMaxArgs({this.select});

  final _i2.CategoryMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategoryGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.parentCategoryId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? parentCategoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'parentCategoryId': parentCategoryId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateCategory {
  const AggregateCategory({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateCategory.fromJson(Map json) => AggregateCategory(
        $count: json['_count'] is Map
            ? _i2.CategoryCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.CategoryAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.CategorySumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.CategoryMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CategoryMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.CategoryCountAggregateOutputType? $count;

  final _i2.CategoryAvgAggregateOutputType? $avg;

  final _i2.CategorySumAggregateOutputType? $sum;

  final _i2.CategoryMinAggregateOutputType? $min;

  final _i2.CategoryMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateCategoryCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategoryCountArgs({this.select});

  final _i2.CategoryCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategoryAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategoryAvgArgs({this.select});

  final _i2.CategoryAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategorySumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategorySumArgs({this.select});

  final _i2.CategorySumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategoryMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategoryMinArgs({this.select});

  final _i2.CategoryMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategoryMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategoryMaxArgs({this.select});

  final _i2.CategoryMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategorySelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategorySelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateCategoryCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateCategoryAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateCategorySumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateCategoryMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateCategoryMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

enum ProductScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Product'),
  name$<String>('name', 'Product'),
  description<String>('description', 'Product'),
  price<_i1.Decimal>('price', 'Product'),
  stockQuantity<int>('stockQuantity', 'Product'),
  sku<String>('sku', 'Product'),
  isActive<bool>('isActive', 'Product'),
  createdAt<DateTime>('createdAt', 'Product'),
  updatedAt<DateTime>('updatedAt', 'Product');

  const ProductScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProductCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateInput({
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryCreateNestedManyWithoutProductInput? categories;

  final _i2.ProductImageCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemCreateNestedManyWithoutProductInput? wishlistItems;

  final _i2.ProductDiscountCreateNestedManyWithoutProductInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedCreateInput({
    this.id,
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutProductInput?
      categories;

  final _i2.ProductImageUncheckedCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemUncheckedCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewUncheckedCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemUncheckedCreateNestedManyWithoutProductInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedCreateNestedManyWithoutProductInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateManyInput({
    this.id,
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CreateManyProductAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductAndReturnOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? price;

  final bool? stockQuantity;

  final bool? sku;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateInput({
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUpdateManyWithoutProductNestedInput? categories;

  final _i2.ProductImageUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUpdateManyWithoutProductNestedInput? wishlistItems;

  final _i2.ProductDiscountUpdateManyWithoutProductNestedInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedUpdateInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutProductNestedInput?
      categories;

  final _i2.ProductImageUncheckedUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUncheckedUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUncheckedUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUncheckedUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUncheckedUpdateManyWithoutProductNestedInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedUpdateManyWithoutProductNestedInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateManyMutationInput({
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UpdateManyProductAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductAndReturnOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? price;

  final bool? stockQuantity;

  final bool? sku;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductCountAggregateOutputType {
  const ProductCountAggregateOutputType({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ProductCountAggregateOutputType.fromJson(Map json) =>
      ProductCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        description: json['description'],
        price: json['price'],
        stockQuantity: json['stockQuantity'],
        sku: json['sku'],
        isActive: json['isActive'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? description;

  final int? price;

  final int? stockQuantity;

  final int? sku;

  final int? isActive;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class ProductAvgAggregateOutputType {
  const ProductAvgAggregateOutputType({
    this.id,
    this.price,
    this.stockQuantity,
  });

  factory ProductAvgAggregateOutputType.fromJson(Map json) =>
      ProductAvgAggregateOutputType(
        id: json['id'],
        price: json['price'],
        stockQuantity: json['stockQuantity'],
      );

  final double? id;

  final _i1.Decimal? price;

  final double? stockQuantity;

  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
        'stockQuantity': stockQuantity,
      };
}

class ProductSumAggregateOutputType {
  const ProductSumAggregateOutputType({
    this.id,
    this.price,
    this.stockQuantity,
  });

  factory ProductSumAggregateOutputType.fromJson(Map json) =>
      ProductSumAggregateOutputType(
        id: json['id'],
        price: json['price'],
        stockQuantity: json['stockQuantity'],
      );

  final int? id;

  final _i1.Decimal? price;

  final int? stockQuantity;

  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
        'stockQuantity': stockQuantity,
      };
}

class ProductMinAggregateOutputType {
  const ProductMinAggregateOutputType({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  factory ProductMinAggregateOutputType.fromJson(Map json) =>
      ProductMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        description: json['description'],
        price: json['price'],
        stockQuantity: json['stockQuantity'],
        sku: json['sku'],
        isActive: json['isActive'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final String? name;

  final String? description;

  final _i1.Decimal? price;

  final int? stockQuantity;

  final String? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class ProductMaxAggregateOutputType {
  const ProductMaxAggregateOutputType({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  factory ProductMaxAggregateOutputType.fromJson(Map json) =>
      ProductMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        description: json['description'],
        price: json['price'],
        stockQuantity: json['stockQuantity'],
        sku: json['sku'],
        isActive: json['isActive'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final String? name;

  final String? description;

  final _i1.Decimal? price;

  final int? stockQuantity;

  final String? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class ProductGroupByOutputType {
  const ProductGroupByOutputType({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ProductGroupByOutputType.fromJson(Map json) =>
      ProductGroupByOutputType(
        id: json['id'],
        name: json['name'],
        description: json['description'],
        price: json['price'],
        stockQuantity: json['stockQuantity'],
        sku: json['sku'],
        isActive: json['isActive'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
        $count: json['_count'] is Map
            ? _i2.ProductCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? name;

  final String? description;

  final _i1.Decimal? price;

  final int? stockQuantity;

  final String? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCountAggregateOutputType? $count;

  final _i2.ProductAvgAggregateOutputType? $avg;

  final _i2.ProductSumAggregateOutputType? $sum;

  final _i2.ProductMinAggregateOutputType? $min;

  final _i2.ProductMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class ProductCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCountOrderByAggregateInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? stockQuantity;

  final _i2.SortOrder? sku;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductAvgOrderByAggregateInput({
    this.id,
    this.price,
    this.stockQuantity,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? price;

  final _i2.SortOrder? stockQuantity;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
        'stockQuantity': stockQuantity,
      };
}

class ProductMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? stockQuantity;

  final _i2.SortOrder? sku;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductMinOrderByAggregateInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? stockQuantity;

  final _i2.SortOrder? sku;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductSumOrderByAggregateInput({
    this.id,
    this.price,
    this.stockQuantity,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? price;

  final _i2.SortOrder? stockQuantity;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
        'stockQuantity': stockQuantity,
      };
}

class ProductOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductOrderByWithAggregationInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? price;

  final _i2.SortOrder? stockQuantity;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sku;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ProductCountOrderByAggregateInput? $count;

  final _i2.ProductAvgOrderByAggregateInput? $avg;

  final _i2.ProductMaxOrderByAggregateInput? $max;

  final _i2.ProductMinOrderByAggregateInput? $min;

  final _i2.ProductSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedDecimalWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDecimalWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? equals;

  final Iterable<_i1.Decimal>? $in;

  final Iterable<_i1.Decimal>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal, _i2.NestedDecimalWithAggregatesFilter>?
      not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDecimalFilter? $avg;

  final _i2.NestedDecimalFilter? $sum;

  final _i2.NestedDecimalFilter? $min;

  final _i2.NestedDecimalFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class DecimalWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DecimalWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? equals;

  final Iterable<_i1.Decimal>? $in;

  final Iterable<_i1.Decimal>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal, _i2.NestedDecimalWithAggregatesFilter>?
      not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDecimalFilter? $avg;

  final _i2.NestedDecimalFilter? $sum;

  final _i2.NestedDecimalFilter? $min;

  final _i2.NestedDecimalFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ProductScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.ProductScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ProductScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ProductScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>? price;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? stockQuantity;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? isActive;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? price;

  final bool? stockQuantity;

  final bool? sku;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class ProductGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductGroupByOutputTypeCountArgs({this.select});

  final _i2.ProductCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductAvgAggregateOutputTypeSelect({
    this.id,
    this.price,
    this.stockQuantity,
  });

  final bool? id;

  final bool? price;

  final bool? stockQuantity;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
        'stockQuantity': stockQuantity,
      };
}

class ProductGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductGroupByOutputTypeAvgArgs({this.select});

  final _i2.ProductAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductSumAggregateOutputTypeSelect({
    this.id,
    this.price,
    this.stockQuantity,
  });

  final bool? id;

  final bool? price;

  final bool? stockQuantity;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
        'stockQuantity': stockQuantity,
      };
}

class ProductGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductGroupByOutputTypeSumArgs({this.select});

  final _i2.ProductSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? price;

  final bool? stockQuantity;

  final bool? sku;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductGroupByOutputTypeMinArgs({this.select});

  final _i2.ProductMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? price;

  final bool? stockQuantity;

  final bool? sku;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductGroupByOutputTypeMaxArgs({this.select});

  final _i2.ProductMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? description;

  final bool? price;

  final bool? stockQuantity;

  final bool? sku;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ProductGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ProductGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ProductGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ProductGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ProductGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateProduct {
  const AggregateProduct({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateProduct.fromJson(Map json) => AggregateProduct(
        $count: json['_count'] is Map
            ? _i2.ProductCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ProductCountAggregateOutputType? $count;

  final _i2.ProductAvgAggregateOutputType? $avg;

  final _i2.ProductSumAggregateOutputType? $sum;

  final _i2.ProductMinAggregateOutputType? $min;

  final _i2.ProductMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateProductCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductCountArgs({this.select});

  final _i2.ProductCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductAvgArgs({this.select});

  final _i2.ProductAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductSumArgs({this.select});

  final _i2.ProductSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductMinArgs({this.select});

  final _i2.ProductMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductMaxArgs({this.select});

  final _i2.ProductMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateProductCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateProductAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateProductSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateProductMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateProductMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ProductCategoryCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateInput({
    required this.product,
    required this.category,
  });

  final _i2.ProductCreateNestedOneWithoutCategoriesInput product;

  final _i2.CategoryCreateNestedOneWithoutProductsInput category;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'category': category,
      };
}

class ProductCategoryUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedCreateInput({
    required this.productId,
    required this.categoryId,
  });

  final int productId;

  final int categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCreateManyInput({
    required this.productId,
    required this.categoryId,
  });

  final int productId;

  final int categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class CreateManyProductCategoryAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductCategoryAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyProductCategoryAndReturnOutputTypeCategoryArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductCategoryAndReturnOutputTypeCategoryArgs({
    this.select,
    this.include,
  });

  final _i2.CategorySelect? select;

  final _i2.CategoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyProductCategoryAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductCategoryAndReturnOutputTypeSelect({
    this.productId,
    this.categoryId,
    this.product,
    this.category,
  });

  final bool? productId;

  final bool? categoryId;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductCategoryAndReturnOutputTypeProductArgs>? product;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductCategoryAndReturnOutputTypeCategoryArgs>? category;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
        'product': product,
        'category': category,
      };
}

class CreateManyProductCategoryAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductCategoryAndReturnOutputTypeInclude({
    this.product,
    this.category,
  });

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductCategoryAndReturnOutputTypeProductArgs>? product;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductCategoryAndReturnOutputTypeCategoryArgs>? category;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'category': category,
      };
}

class ProductCategoryUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUpdateInput({
    this.product,
    this.category,
  });

  final _i2.ProductUpdateOneRequiredWithoutCategoriesNestedInput? product;

  final _i2.CategoryUpdateOneRequiredWithoutProductsNestedInput? category;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'category': category,
      };
}

class ProductCategoryUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedUpdateInput({
    this.productId,
    this.categoryId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryUncheckedUpdateManyInput({
    this.productId,
    this.categoryId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class UpdateManyProductCategoryAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductCategoryAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyProductCategoryAndReturnOutputTypeCategoryArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductCategoryAndReturnOutputTypeCategoryArgs({
    this.select,
    this.include,
  });

  final _i2.CategorySelect? select;

  final _i2.CategoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyProductCategoryAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductCategoryAndReturnOutputTypeSelect({
    this.productId,
    this.categoryId,
    this.product,
    this.category,
  });

  final bool? productId;

  final bool? categoryId;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductCategoryAndReturnOutputTypeProductArgs>? product;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductCategoryAndReturnOutputTypeCategoryArgs>? category;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
        'product': product,
        'category': category,
      };
}

class UpdateManyProductCategoryAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductCategoryAndReturnOutputTypeInclude({
    this.product,
    this.category,
  });

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductCategoryAndReturnOutputTypeProductArgs>? product;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductCategoryAndReturnOutputTypeCategoryArgs>? category;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'category': category,
      };
}

class ProductCategoryCountAggregateOutputType {
  const ProductCategoryCountAggregateOutputType({
    this.productId,
    this.categoryId,
    this.$all,
  });

  factory ProductCategoryCountAggregateOutputType.fromJson(Map json) =>
      ProductCategoryCountAggregateOutputType(
        productId: json['productId'],
        categoryId: json['categoryId'],
        $all: json['_all'],
      );

  final int? productId;

  final int? categoryId;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
        '_all': $all,
      };
}

class ProductCategoryAvgAggregateOutputType {
  const ProductCategoryAvgAggregateOutputType({
    this.productId,
    this.categoryId,
  });

  factory ProductCategoryAvgAggregateOutputType.fromJson(Map json) =>
      ProductCategoryAvgAggregateOutputType(
        productId: json['productId'],
        categoryId: json['categoryId'],
      );

  final double? productId;

  final double? categoryId;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategorySumAggregateOutputType {
  const ProductCategorySumAggregateOutputType({
    this.productId,
    this.categoryId,
  });

  factory ProductCategorySumAggregateOutputType.fromJson(Map json) =>
      ProductCategorySumAggregateOutputType(
        productId: json['productId'],
        categoryId: json['categoryId'],
      );

  final int? productId;

  final int? categoryId;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryMinAggregateOutputType {
  const ProductCategoryMinAggregateOutputType({
    this.productId,
    this.categoryId,
  });

  factory ProductCategoryMinAggregateOutputType.fromJson(Map json) =>
      ProductCategoryMinAggregateOutputType(
        productId: json['productId'],
        categoryId: json['categoryId'],
      );

  final int? productId;

  final int? categoryId;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryMaxAggregateOutputType {
  const ProductCategoryMaxAggregateOutputType({
    this.productId,
    this.categoryId,
  });

  factory ProductCategoryMaxAggregateOutputType.fromJson(Map json) =>
      ProductCategoryMaxAggregateOutputType(
        productId: json['productId'],
        categoryId: json['categoryId'],
      );

  final int? productId;

  final int? categoryId;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryGroupByOutputType {
  const ProductCategoryGroupByOutputType({
    this.productId,
    this.categoryId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ProductCategoryGroupByOutputType.fromJson(Map json) =>
      ProductCategoryGroupByOutputType(
        productId: json['productId'],
        categoryId: json['categoryId'],
        $count: json['_count'] is Map
            ? _i2.ProductCategoryCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductCategoryAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductCategorySumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductCategoryMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductCategoryMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? productId;

  final int? categoryId;

  final _i2.ProductCategoryCountAggregateOutputType? $count;

  final _i2.ProductCategoryAvgAggregateOutputType? $avg;

  final _i2.ProductCategorySumAggregateOutputType? $sum;

  final _i2.ProductCategoryMinAggregateOutputType? $min;

  final _i2.ProductCategoryMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class ProductCategoryCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCountOrderByAggregateInput({
    this.productId,
    this.categoryId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryAvgOrderByAggregateInput({
    this.productId,
    this.categoryId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryMaxOrderByAggregateInput({
    this.productId,
    this.categoryId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryMinOrderByAggregateInput({
    this.productId,
    this.categoryId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategorySumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategorySumOrderByAggregateInput({
    this.productId,
    this.categoryId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryOrderByWithAggregationInput({
    this.productId,
    this.categoryId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? categoryId;

  final _i2.ProductCategoryCountOrderByAggregateInput? $count;

  final _i2.ProductCategoryAvgOrderByAggregateInput? $avg;

  final _i2.ProductCategoryMaxOrderByAggregateInput? $max;

  final _i2.ProductCategoryMinOrderByAggregateInput? $min;

  final _i2.ProductCategorySumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ProductCategoryScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.categoryId,
  });

  final _i1.PrismaUnion<_i2.ProductCategoryScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductCategoryScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ProductCategoryScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ProductCategoryScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductCategoryScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryCountAggregateOutputTypeSelect({
    this.productId,
    this.categoryId,
    this.$all,
  });

  final bool? productId;

  final bool? categoryId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
        '_all': $all,
      };
}

class ProductCategoryGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryGroupByOutputTypeCountArgs({this.select});

  final _i2.ProductCategoryCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductCategoryAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryAvgAggregateOutputTypeSelect({
    this.productId,
    this.categoryId,
  });

  final bool? productId;

  final bool? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryGroupByOutputTypeAvgArgs({this.select});

  final _i2.ProductCategoryAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductCategorySumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategorySumAggregateOutputTypeSelect({
    this.productId,
    this.categoryId,
  });

  final bool? productId;

  final bool? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryGroupByOutputTypeSumArgs({this.select});

  final _i2.ProductCategorySumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductCategoryMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryMinAggregateOutputTypeSelect({
    this.productId,
    this.categoryId,
  });

  final bool? productId;

  final bool? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryGroupByOutputTypeMinArgs({this.select});

  final _i2.ProductCategoryMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductCategoryMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryMaxAggregateOutputTypeSelect({
    this.productId,
    this.categoryId,
  });

  final bool? productId;

  final bool? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
      };
}

class ProductCategoryGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryGroupByOutputTypeMaxArgs({this.select});

  final _i2.ProductCategoryMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductCategoryGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCategoryGroupByOutputTypeSelect({
    this.productId,
    this.categoryId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? productId;

  final bool? categoryId;

  final _i1.PrismaUnion<bool, _i2.ProductCategoryGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ProductCategoryGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.ProductCategoryGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.ProductCategoryGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.ProductCategoryGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'categoryId': categoryId,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateProductCategory {
  const AggregateProductCategory({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateProductCategory.fromJson(Map json) =>
      AggregateProductCategory(
        $count: json['_count'] is Map
            ? _i2.ProductCategoryCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductCategoryAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductCategorySumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductCategoryMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductCategoryMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ProductCategoryCountAggregateOutputType? $count;

  final _i2.ProductCategoryAvgAggregateOutputType? $avg;

  final _i2.ProductCategorySumAggregateOutputType? $sum;

  final _i2.ProductCategoryMinAggregateOutputType? $min;

  final _i2.ProductCategoryMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateProductCategoryCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductCategoryCountArgs({this.select});

  final _i2.ProductCategoryCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductCategoryAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductCategoryAvgArgs({this.select});

  final _i2.ProductCategoryAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductCategorySumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductCategorySumArgs({this.select});

  final _i2.ProductCategorySumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductCategoryMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductCategoryMinArgs({this.select});

  final _i2.ProductCategoryMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductCategoryMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductCategoryMaxArgs({this.select});

  final _i2.ProductCategoryMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductCategorySelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductCategorySelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateProductCategoryCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateProductCategoryAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateProductCategorySumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateProductCategoryMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateProductCategoryMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ProductCreateWithoutImagesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateWithoutImagesInput({
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryCreateNestedManyWithoutProductInput? categories;

  final _i2.CartItemCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemCreateNestedManyWithoutProductInput? wishlistItems;

  final _i2.ProductDiscountCreateNestedManyWithoutProductInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedCreateWithoutImagesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedCreateWithoutImagesInput({
    this.id,
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutProductInput?
      categories;

  final _i2.CartItemUncheckedCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewUncheckedCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemUncheckedCreateNestedManyWithoutProductInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedCreateNestedManyWithoutProductInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductCreateOrConnectWithoutImagesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateOrConnectWithoutImagesInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutImagesInput,
      _i2.ProductUncheckedCreateWithoutImagesInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductCreateNestedOneWithoutImagesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateNestedOneWithoutImagesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutImagesInput,
      _i2.ProductUncheckedCreateWithoutImagesInput>? create;

  final _i2.ProductCreateOrConnectWithoutImagesInput? connectOrCreate;

  final _i2.ProductWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ProductImageCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageCreateInput({
    required this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    required this.product,
  });

  final String imageUrl;

  final bool? isPrimary;

  final int? displayOrder;

  final DateTime? createdAt;

  final _i2.ProductCreateNestedOneWithoutImagesInput product;

  @override
  Map<String, dynamic> toJson() => {
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        'product': product,
      };
}

class ProductImageUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUncheckedCreateInput({
    this.id,
    required this.productId,
    required this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final int? id;

  final int productId;

  final String imageUrl;

  final bool? isPrimary;

  final int? displayOrder;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageCreateManyInput({
    this.id,
    required this.productId,
    required this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final int? id;

  final int productId;

  final String imageUrl;

  final bool? isPrimary;

  final int? displayOrder;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class CreateManyProductImageAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductImageAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyProductImageAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductImageAndReturnOutputTypeSelect({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.product,
  });

  final bool? id;

  final bool? productId;

  final bool? imageUrl;

  final bool? isPrimary;

  final bool? displayOrder;

  final bool? createdAt;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductImageAndReturnOutputTypeProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        'product': product,
      };
}

class CreateManyProductImageAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductImageAndReturnOutputTypeInclude({this.product});

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductImageAndReturnOutputTypeProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {'product': product};
}

class ProductUpdateWithoutImagesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateWithoutImagesInput({
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUpdateManyWithoutProductNestedInput? categories;

  final _i2.CartItemUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUpdateManyWithoutProductNestedInput? wishlistItems;

  final _i2.ProductDiscountUpdateManyWithoutProductNestedInput? discounts;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUncheckedUpdateWithoutImagesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedUpdateWithoutImagesInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
    this.discounts,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutProductNestedInput?
      categories;

  final _i2.CartItemUncheckedUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUncheckedUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUncheckedUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUncheckedUpdateManyWithoutProductNestedInput?
      wishlistItems;

  final _i2.ProductDiscountUncheckedUpdateManyWithoutProductNestedInput?
      discounts;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
        'discounts': discounts,
      };
}

class ProductUpsertWithoutImagesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpsertWithoutImagesInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutImagesInput,
      _i2.ProductUncheckedUpdateWithoutImagesInput> update;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutImagesInput,
      _i2.ProductUncheckedCreateWithoutImagesInput> create;

  final _i2.ProductWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ProductUpdateToOneWithWhereWithoutImagesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateToOneWithWhereWithoutImagesInput({
    this.where,
    required this.data,
  });

  final _i2.ProductWhereInput? where;

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutImagesInput,
      _i2.ProductUncheckedUpdateWithoutImagesInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductUpdateOneRequiredWithoutImagesNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateOneRequiredWithoutImagesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutImagesInput,
      _i2.ProductUncheckedCreateWithoutImagesInput>? create;

  final _i2.ProductCreateOrConnectWithoutImagesInput? connectOrCreate;

  final _i2.ProductUpsertWithoutImagesInput? upsert;

  final _i2.ProductWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ProductUpdateToOneWithWhereWithoutImagesInput,
      _i1.PrismaUnion<_i2.ProductUpdateWithoutImagesInput,
          _i2.ProductUncheckedUpdateWithoutImagesInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ProductImageUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUpdateInput({
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.product,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? imageUrl;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isPrimary;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? displayOrder;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i2.ProductUpdateOneRequiredWithoutImagesNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        'product': product,
      };
}

class ProductImageUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUncheckedUpdateInput({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? imageUrl;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isPrimary;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? displayOrder;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageUncheckedUpdateManyInput({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? imageUrl;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isPrimary;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? displayOrder;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class UpdateManyProductImageAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductImageAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyProductImageAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductImageAndReturnOutputTypeSelect({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.product,
  });

  final bool? id;

  final bool? productId;

  final bool? imageUrl;

  final bool? isPrimary;

  final bool? displayOrder;

  final bool? createdAt;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductImageAndReturnOutputTypeProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        'product': product,
      };
}

class UpdateManyProductImageAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductImageAndReturnOutputTypeInclude({this.product});

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductImageAndReturnOutputTypeProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {'product': product};
}

class ProductImageCountAggregateOutputType {
  const ProductImageCountAggregateOutputType({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.$all,
  });

  factory ProductImageCountAggregateOutputType.fromJson(Map json) =>
      ProductImageCountAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        imageUrl: json['imageUrl'],
        isPrimary: json['isPrimary'],
        displayOrder: json['displayOrder'],
        createdAt: json['createdAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? productId;

  final int? imageUrl;

  final int? isPrimary;

  final int? displayOrder;

  final int? createdAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        '_all': $all,
      };
}

class ProductImageAvgAggregateOutputType {
  const ProductImageAvgAggregateOutputType({
    this.id,
    this.productId,
    this.displayOrder,
  });

  factory ProductImageAvgAggregateOutputType.fromJson(Map json) =>
      ProductImageAvgAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        displayOrder: json['displayOrder'],
      );

  final double? id;

  final double? productId;

  final double? displayOrder;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'displayOrder': displayOrder,
      };
}

class ProductImageSumAggregateOutputType {
  const ProductImageSumAggregateOutputType({
    this.id,
    this.productId,
    this.displayOrder,
  });

  factory ProductImageSumAggregateOutputType.fromJson(Map json) =>
      ProductImageSumAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        displayOrder: json['displayOrder'],
      );

  final int? id;

  final int? productId;

  final int? displayOrder;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'displayOrder': displayOrder,
      };
}

class ProductImageMinAggregateOutputType {
  const ProductImageMinAggregateOutputType({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  factory ProductImageMinAggregateOutputType.fromJson(Map json) =>
      ProductImageMinAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        imageUrl: json['imageUrl'],
        isPrimary: json['isPrimary'],
        displayOrder: json['displayOrder'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
      );

  final int? id;

  final int? productId;

  final String? imageUrl;

  final bool? isPrimary;

  final int? displayOrder;

  final DateTime? createdAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt?.toIso8601String(),
      };
}

class ProductImageMaxAggregateOutputType {
  const ProductImageMaxAggregateOutputType({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  factory ProductImageMaxAggregateOutputType.fromJson(Map json) =>
      ProductImageMaxAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        imageUrl: json['imageUrl'],
        isPrimary: json['isPrimary'],
        displayOrder: json['displayOrder'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
      );

  final int? id;

  final int? productId;

  final String? imageUrl;

  final bool? isPrimary;

  final int? displayOrder;

  final DateTime? createdAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt?.toIso8601String(),
      };
}

class ProductImageGroupByOutputType {
  const ProductImageGroupByOutputType({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ProductImageGroupByOutputType.fromJson(Map json) =>
      ProductImageGroupByOutputType(
        id: json['id'],
        productId: json['productId'],
        imageUrl: json['imageUrl'],
        isPrimary: json['isPrimary'],
        displayOrder: json['displayOrder'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        $count: json['_count'] is Map
            ? _i2.ProductImageCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductImageAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductImageSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductImageMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductImageMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? productId;

  final String? imageUrl;

  final bool? isPrimary;

  final int? displayOrder;

  final DateTime? createdAt;

  final _i2.ProductImageCountAggregateOutputType? $count;

  final _i2.ProductImageAvgAggregateOutputType? $avg;

  final _i2.ProductImageSumAggregateOutputType? $sum;

  final _i2.ProductImageMinAggregateOutputType? $min;

  final _i2.ProductImageMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class ProductImageCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageCountOrderByAggregateInput({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? imageUrl;

  final _i2.SortOrder? isPrimary;

  final _i2.SortOrder? displayOrder;

  final _i2.SortOrder? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageAvgOrderByAggregateInput({
    this.id,
    this.productId,
    this.displayOrder,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? displayOrder;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'displayOrder': displayOrder,
      };
}

class ProductImageMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageMaxOrderByAggregateInput({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? imageUrl;

  final _i2.SortOrder? isPrimary;

  final _i2.SortOrder? displayOrder;

  final _i2.SortOrder? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageMinOrderByAggregateInput({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? imageUrl;

  final _i2.SortOrder? isPrimary;

  final _i2.SortOrder? displayOrder;

  final _i2.SortOrder? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageSumOrderByAggregateInput({
    this.id,
    this.productId,
    this.displayOrder,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? displayOrder;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'displayOrder': displayOrder,
      };
}

class ProductImageOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageOrderByWithAggregationInput({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? imageUrl;

  final _i2.SortOrder? isPrimary;

  final _i2.SortOrder? displayOrder;

  final _i2.SortOrder? createdAt;

  final _i2.ProductImageCountOrderByAggregateInput? $count;

  final _i2.ProductImageAvgOrderByAggregateInput? $avg;

  final _i2.ProductImageMaxOrderByAggregateInput? $max;

  final _i2.ProductImageMinOrderByAggregateInput? $min;

  final _i2.ProductImageSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ProductImageScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final _i1.PrismaUnion<_i2.ProductImageScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductImageScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ProductImageScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ProductImageScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductImageScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? productId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? imageUrl;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? isPrimary;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? displayOrder;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageCountAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.$all,
  });

  final bool? id;

  final bool? productId;

  final bool? imageUrl;

  final bool? isPrimary;

  final bool? displayOrder;

  final bool? createdAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        '_all': $all,
      };
}

class ProductImageGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageGroupByOutputTypeCountArgs({this.select});

  final _i2.ProductImageCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductImageAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageAvgAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.displayOrder,
  });

  final bool? id;

  final bool? productId;

  final bool? displayOrder;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'displayOrder': displayOrder,
      };
}

class ProductImageGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageGroupByOutputTypeAvgArgs({this.select});

  final _i2.ProductImageAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductImageSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageSumAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.displayOrder,
  });

  final bool? id;

  final bool? productId;

  final bool? displayOrder;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'displayOrder': displayOrder,
      };
}

class ProductImageGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageGroupByOutputTypeSumArgs({this.select});

  final _i2.ProductImageSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductImageMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageMinAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final bool? id;

  final bool? productId;

  final bool? imageUrl;

  final bool? isPrimary;

  final bool? displayOrder;

  final bool? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageGroupByOutputTypeMinArgs({this.select});

  final _i2.ProductImageMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductImageMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageMaxAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
  });

  final bool? id;

  final bool? productId;

  final bool? imageUrl;

  final bool? isPrimary;

  final bool? displayOrder;

  final bool? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
      };
}

class ProductImageGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageGroupByOutputTypeMaxArgs({this.select});

  final _i2.ProductImageMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductImageGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductImageGroupByOutputTypeSelect({
    this.id,
    this.productId,
    this.imageUrl,
    this.isPrimary,
    this.displayOrder,
    this.createdAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? productId;

  final bool? imageUrl;

  final bool? isPrimary;

  final bool? displayOrder;

  final bool? createdAt;

  final _i1.PrismaUnion<bool, _i2.ProductImageGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ProductImageGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ProductImageGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ProductImageGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ProductImageGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'imageUrl': imageUrl,
        'isPrimary': isPrimary,
        'displayOrder': displayOrder,
        'createdAt': createdAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateProductImage {
  const AggregateProductImage({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateProductImage.fromJson(Map json) => AggregateProductImage(
        $count: json['_count'] is Map
            ? _i2.ProductImageCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductImageAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductImageSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductImageMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductImageMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ProductImageCountAggregateOutputType? $count;

  final _i2.ProductImageAvgAggregateOutputType? $avg;

  final _i2.ProductImageSumAggregateOutputType? $sum;

  final _i2.ProductImageMinAggregateOutputType? $min;

  final _i2.ProductImageMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateProductImageCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductImageCountArgs({this.select});

  final _i2.ProductImageCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductImageAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductImageAvgArgs({this.select});

  final _i2.ProductImageAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductImageSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductImageSumArgs({this.select});

  final _i2.ProductImageSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductImageMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductImageMinArgs({this.select});

  final _i2.ProductImageMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductImageMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductImageMaxArgs({this.select});

  final _i2.ProductImageMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductImageSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductImageSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateProductImageCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateProductImageAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateProductImageSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateProductImageMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateProductImageMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class CartCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateInput({
    this.createdAt,
    this.updatedAt,
    required this.user,
    this.items,
  });

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutCartsInput user;

  final _i2.CartItemCreateNestedManyWithoutCartInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

class CartUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedCreateInput({
    this.id,
    required this.userId,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final int? id;

  final int userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CartItemUncheckedCreateNestedManyWithoutCartInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class CartCreateManyInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCreateManyInput({
    this.id,
    required this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CreateManyCartAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCartAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyCartAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCartAndReturnOutputTypeSelect({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final bool? id;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.CreateManyCartAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class CreateManyCartAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCartAndReturnOutputTypeInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.CreateManyCartAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class CartUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUpdateInput({
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
  });

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutCartsNestedInput? user;

  final _i2.CartItemUpdateManyWithoutCartNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

class CartUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedUpdateInput({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.CartItemUncheckedUpdateManyWithoutCartNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class CartUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UpdateManyCartAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCartAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyCartAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCartAndReturnOutputTypeSelect({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final bool? id;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.UpdateManyCartAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class UpdateManyCartAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCartAndReturnOutputTypeInclude({this.user});

  final _i1.PrismaUnion<bool, _i2.UpdateManyCartAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class CartCountAggregateOutputType {
  const CartCountAggregateOutputType({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory CartCountAggregateOutputType.fromJson(Map json) =>
      CartCountAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class CartAvgAggregateOutputType {
  const CartAvgAggregateOutputType({
    this.id,
    this.userId,
  });

  factory CartAvgAggregateOutputType.fromJson(Map json) =>
      CartAvgAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
      );

  final double? id;

  final double? userId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class CartSumAggregateOutputType {
  const CartSumAggregateOutputType({
    this.id,
    this.userId,
  });

  factory CartSumAggregateOutputType.fromJson(Map json) =>
      CartSumAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
      );

  final int? id;

  final int? userId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class CartMinAggregateOutputType {
  const CartMinAggregateOutputType({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory CartMinAggregateOutputType.fromJson(Map json) =>
      CartMinAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class CartMaxAggregateOutputType {
  const CartMaxAggregateOutputType({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  factory CartMaxAggregateOutputType.fromJson(Map json) =>
      CartMaxAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class CartGroupByOutputType {
  const CartGroupByOutputType({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory CartGroupByOutputType.fromJson(Map json) => CartGroupByOutputType(
        id: json['id'],
        userId: json['userId'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
        $count: json['_count'] is Map
            ? _i2.CartCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.CartAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.CartSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.CartMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CartMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? userId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CartCountAggregateOutputType? $count;

  final _i2.CartAvgAggregateOutputType? $avg;

  final _i2.CartSumAggregateOutputType? $sum;

  final _i2.CartMinAggregateOutputType? $min;

  final _i2.CartMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class CartCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartAvgOrderByAggregateInput({
    this.id,
    this.userId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class CartMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartSumOrderByAggregateInput({
    this.id,
    this.userId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class CartOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.CartCountOrderByAggregateInput? $count;

  final _i2.CartAvgOrderByAggregateInput? $avg;

  final _i2.CartMaxOrderByAggregateInput? $max;

  final _i2.CartMinOrderByAggregateInput? $min;

  final _i2.CartSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class CartScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.CartScalarWhereWithAggregatesInput,
      Iterable<_i2.CartScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.CartScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.CartScalarWhereWithAggregatesInput,
      Iterable<_i2.CartScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? userId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class CartGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartGroupByOutputTypeCountArgs({this.select});

  final _i2.CartCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
  });

  final bool? id;

  final bool? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class CartGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartGroupByOutputTypeAvgArgs({this.select});

  final _i2.CartAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
  });

  final bool? id;

  final bool? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class CartGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartGroupByOutputTypeSumArgs({this.select});

  final _i2.CartSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartGroupByOutputTypeMinArgs({this.select});

  final _i2.CartMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CartGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartGroupByOutputTypeMaxArgs({this.select});

  final _i2.CartMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.CartGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.CartGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.CartGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.CartGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.CartGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateCart {
  const AggregateCart({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateCart.fromJson(Map json) => AggregateCart(
        $count: json['_count'] is Map
            ? _i2.CartCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.CartAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.CartSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.CartMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CartMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.CartCountAggregateOutputType? $count;

  final _i2.CartAvgAggregateOutputType? $avg;

  final _i2.CartSumAggregateOutputType? $sum;

  final _i2.CartMinAggregateOutputType? $min;

  final _i2.CartMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateCartCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartCountArgs({this.select});

  final _i2.CartCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartAvgArgs({this.select});

  final _i2.CartAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartSumArgs({this.select});

  final _i2.CartSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartMinArgs({this.select});

  final _i2.CartMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartMaxArgs({this.select});

  final _i2.CartMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateCartCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateCartAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateCartSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateCartMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateCartMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class CartItemCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateInput({
    this.quantity,
    required this.priceAtAddition,
    this.addedAt,
    required this.cart,
    required this.product,
  });

  final int? quantity;

  final _i1.Decimal priceAtAddition;

  final DateTime? addedAt;

  final _i2.CartCreateNestedOneWithoutItemsInput cart;

  final _i2.ProductCreateNestedOneWithoutCartItemsInput product;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
        'product': product,
      };
}

class CartItemUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedCreateInput({
    this.id,
    required this.cartId,
    required this.productId,
    this.quantity,
    required this.priceAtAddition,
    this.addedAt,
  });

  final int? id;

  final int cartId;

  final int productId;

  final int? quantity;

  final _i1.Decimal priceAtAddition;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCreateManyInput({
    this.id,
    required this.cartId,
    required this.productId,
    this.quantity,
    required this.priceAtAddition,
    this.addedAt,
  });

  final int? id;

  final int cartId;

  final int productId;

  final int? quantity;

  final _i1.Decimal priceAtAddition;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CreateManyCartItemAndReturnOutputTypeCartArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCartItemAndReturnOutputTypeCartArgs({
    this.select,
    this.include,
  });

  final _i2.CartSelect? select;

  final _i2.CartInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyCartItemAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCartItemAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyCartItemAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCartItemAndReturnOutputTypeSelect({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.cart,
    this.product,
  });

  final bool? id;

  final bool? cartId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtAddition;

  final bool? addedAt;

  final _i1
      .PrismaUnion<bool, _i2.CreateManyCartItemAndReturnOutputTypeCartArgs>?
      cart;

  final _i1
      .PrismaUnion<bool, _i2.CreateManyCartItemAndReturnOutputTypeProductArgs>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
        'product': product,
      };
}

class CreateManyCartItemAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyCartItemAndReturnOutputTypeInclude({
    this.cart,
    this.product,
  });

  final _i1
      .PrismaUnion<bool, _i2.CreateManyCartItemAndReturnOutputTypeCartArgs>?
      cart;

  final _i1
      .PrismaUnion<bool, _i2.CreateManyCartItemAndReturnOutputTypeProductArgs>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'cart': cart,
        'product': product,
      };
}

class CartItemUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUpdateInput({
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.cart,
    this.product,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  final _i2.CartUpdateOneRequiredWithoutItemsNestedInput? cart;

  final _i2.ProductUpdateOneRequiredWithoutCartItemsNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
        'product': product,
      };
}

class CartItemUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedUpdateInput({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? cartId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemUncheckedUpdateManyInput({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? cartId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtAddition;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class UpdateManyCartItemAndReturnOutputTypeCartArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCartItemAndReturnOutputTypeCartArgs({
    this.select,
    this.include,
  });

  final _i2.CartSelect? select;

  final _i2.CartInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyCartItemAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCartItemAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyCartItemAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCartItemAndReturnOutputTypeSelect({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.cart,
    this.product,
  });

  final bool? id;

  final bool? cartId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtAddition;

  final bool? addedAt;

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyCartItemAndReturnOutputTypeCartArgs>?
      cart;

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyCartItemAndReturnOutputTypeProductArgs>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        'cart': cart,
        'product': product,
      };
}

class UpdateManyCartItemAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyCartItemAndReturnOutputTypeInclude({
    this.cart,
    this.product,
  });

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyCartItemAndReturnOutputTypeCartArgs>?
      cart;

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyCartItemAndReturnOutputTypeProductArgs>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'cart': cart,
        'product': product,
      };
}

class CartItemCountAggregateOutputType {
  const CartItemCountAggregateOutputType({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.$all,
  });

  factory CartItemCountAggregateOutputType.fromJson(Map json) =>
      CartItemCountAggregateOutputType(
        id: json['id'],
        cartId: json['cartId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtAddition: json['priceAtAddition'],
        addedAt: json['addedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? cartId;

  final int? productId;

  final int? quantity;

  final int? priceAtAddition;

  final int? addedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        '_all': $all,
      };
}

class CartItemAvgAggregateOutputType {
  const CartItemAvgAggregateOutputType({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
  });

  factory CartItemAvgAggregateOutputType.fromJson(Map json) =>
      CartItemAvgAggregateOutputType(
        id: json['id'],
        cartId: json['cartId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtAddition: json['priceAtAddition'],
      );

  final double? id;

  final double? cartId;

  final double? productId;

  final double? quantity;

  final _i1.Decimal? priceAtAddition;

  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
      };
}

class CartItemSumAggregateOutputType {
  const CartItemSumAggregateOutputType({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
  });

  factory CartItemSumAggregateOutputType.fromJson(Map json) =>
      CartItemSumAggregateOutputType(
        id: json['id'],
        cartId: json['cartId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtAddition: json['priceAtAddition'],
      );

  final int? id;

  final int? cartId;

  final int? productId;

  final int? quantity;

  final _i1.Decimal? priceAtAddition;

  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
      };
}

class CartItemMinAggregateOutputType {
  const CartItemMinAggregateOutputType({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  factory CartItemMinAggregateOutputType.fromJson(Map json) =>
      CartItemMinAggregateOutputType(
        id: json['id'],
        cartId: json['cartId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtAddition: json['priceAtAddition'],
        addedAt: switch (json['addedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['addedAt']
        },
      );

  final int? id;

  final int? cartId;

  final int? productId;

  final int? quantity;

  final _i1.Decimal? priceAtAddition;

  final DateTime? addedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt?.toIso8601String(),
      };
}

class CartItemMaxAggregateOutputType {
  const CartItemMaxAggregateOutputType({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  factory CartItemMaxAggregateOutputType.fromJson(Map json) =>
      CartItemMaxAggregateOutputType(
        id: json['id'],
        cartId: json['cartId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtAddition: json['priceAtAddition'],
        addedAt: switch (json['addedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['addedAt']
        },
      );

  final int? id;

  final int? cartId;

  final int? productId;

  final int? quantity;

  final _i1.Decimal? priceAtAddition;

  final DateTime? addedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt?.toIso8601String(),
      };
}

class CartItemGroupByOutputType {
  const CartItemGroupByOutputType({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory CartItemGroupByOutputType.fromJson(Map json) =>
      CartItemGroupByOutputType(
        id: json['id'],
        cartId: json['cartId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtAddition: json['priceAtAddition'],
        addedAt: switch (json['addedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['addedAt']
        },
        $count: json['_count'] is Map
            ? _i2.CartItemCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.CartItemAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.CartItemSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.CartItemMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CartItemMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? cartId;

  final int? productId;

  final int? quantity;

  final _i1.Decimal? priceAtAddition;

  final DateTime? addedAt;

  final _i2.CartItemCountAggregateOutputType? $count;

  final _i2.CartItemAvgAggregateOutputType? $avg;

  final _i2.CartItemSumAggregateOutputType? $sum;

  final _i2.CartItemMinAggregateOutputType? $min;

  final _i2.CartItemMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class CartItemCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCountOrderByAggregateInput({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? cartId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtAddition;

  final _i2.SortOrder? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemAvgOrderByAggregateInput({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? cartId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtAddition;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
      };
}

class CartItemMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemMaxOrderByAggregateInput({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? cartId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtAddition;

  final _i2.SortOrder? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemMinOrderByAggregateInput({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? cartId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtAddition;

  final _i2.SortOrder? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemSumOrderByAggregateInput({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? cartId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtAddition;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
      };
}

class CartItemOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemOrderByWithAggregationInput({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? cartId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtAddition;

  final _i2.SortOrder? addedAt;

  final _i2.CartItemCountOrderByAggregateInput? $count;

  final _i2.CartItemAvgOrderByAggregateInput? $avg;

  final _i2.CartItemMaxOrderByAggregateInput? $max;

  final _i2.CartItemMinOrderByAggregateInput? $min;

  final _i2.CartItemSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class CartItemScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final _i1.PrismaUnion<_i2.CartItemScalarWhereWithAggregatesInput,
      Iterable<_i2.CartItemScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.CartItemScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.CartItemScalarWhereWithAggregatesInput,
      Iterable<_i2.CartItemScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? cartId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? quantity;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>?
      priceAtAddition;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemCountAggregateOutputTypeSelect({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.$all,
  });

  final bool? id;

  final bool? cartId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtAddition;

  final bool? addedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        '_all': $all,
      };
}

class CartItemGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemGroupByOutputTypeCountArgs({this.select});

  final _i2.CartItemCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartItemAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemAvgAggregateOutputTypeSelect({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
  });

  final bool? id;

  final bool? cartId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtAddition;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
      };
}

class CartItemGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemGroupByOutputTypeAvgArgs({this.select});

  final _i2.CartItemAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartItemSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemSumAggregateOutputTypeSelect({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
  });

  final bool? id;

  final bool? cartId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtAddition;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
      };
}

class CartItemGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemGroupByOutputTypeSumArgs({this.select});

  final _i2.CartItemSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartItemMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemMinAggregateOutputTypeSelect({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final bool? id;

  final bool? cartId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtAddition;

  final bool? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemGroupByOutputTypeMinArgs({this.select});

  final _i2.CartItemMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartItemMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemMaxAggregateOutputTypeSelect({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
  });

  final bool? id;

  final bool? cartId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtAddition;

  final bool? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
      };
}

class CartItemGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemGroupByOutputTypeMaxArgs({this.select});

  final _i2.CartItemMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CartItemGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CartItemGroupByOutputTypeSelect({
    this.id,
    this.cartId,
    this.productId,
    this.quantity,
    this.priceAtAddition,
    this.addedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? cartId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtAddition;

  final bool? addedAt;

  final _i1.PrismaUnion<bool, _i2.CartItemGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.CartItemGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.CartItemGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.CartItemGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.CartItemGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'cartId': cartId,
        'productId': productId,
        'quantity': quantity,
        'priceAtAddition': priceAtAddition,
        'addedAt': addedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateCartItem {
  const AggregateCartItem({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateCartItem.fromJson(Map json) => AggregateCartItem(
        $count: json['_count'] is Map
            ? _i2.CartItemCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.CartItemAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.CartItemSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.CartItemMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CartItemMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.CartItemCountAggregateOutputType? $count;

  final _i2.CartItemAvgAggregateOutputType? $avg;

  final _i2.CartItemSumAggregateOutputType? $sum;

  final _i2.CartItemMinAggregateOutputType? $min;

  final _i2.CartItemMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateCartItemCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartItemCountArgs({this.select});

  final _i2.CartItemCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartItemAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartItemAvgArgs({this.select});

  final _i2.CartItemAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartItemSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartItemSumArgs({this.select});

  final _i2.CartItemSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartItemMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartItemMinArgs({this.select});

  final _i2.CartItemMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartItemMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartItemMaxArgs({this.select});

  final _i2.CartItemMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCartItemSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCartItemSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateCartItemCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateCartItemAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateCartItemSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateCartItemMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateCartItemMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class OrderCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateInput({
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    required this.user,
    required this.shippingAddress,
    required this.billingAddress,
    this.items,
    this.payments,
  });

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutOrdersInput user;

  final _i2.AddressCreateNestedOneWithoutShippingOrdersInput shippingAddress;

  final _i2.AddressCreateNestedOneWithoutBillingOrdersInput billingAddress;

  final _i2.OrderItemCreateNestedManyWithoutOrderInput? items;

  final _i2.PaymentCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
      };
}

class OrderUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedCreateInput({
    this.id,
    required this.userId,
    required this.shippingAddressId,
    required this.billingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
    this.payments,
  });

  final int? id;

  final int userId;

  final int shippingAddressId;

  final int billingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutOrderInput? items;

  final _i2.PaymentUncheckedCreateNestedManyWithoutOrderInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
        'payments': payments,
      };
}

class OrderCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateManyInput({
    this.id,
    required this.userId,
    required this.shippingAddressId,
    required this.billingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final int shippingAddressId;

  final int billingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CreateManyOrderAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyOrderAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyOrderAndReturnOutputTypeShippingAddressArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyOrderAndReturnOutputTypeShippingAddressArgs({
    this.select,
    this.include,
  });

  final _i2.AddressSelect? select;

  final _i2.AddressInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyOrderAndReturnOutputTypeBillingAddressArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyOrderAndReturnOutputTypeBillingAddressArgs({
    this.select,
    this.include,
  });

  final _i2.AddressSelect? select;

  final _i2.AddressInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyOrderAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyOrderAndReturnOutputTypeSelect({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.billingAddress,
  });

  final bool? id;

  final bool? userId;

  final bool? shippingAddressId;

  final bool? billingAddressId;

  final bool? subtotal;

  final bool? tax;

  final bool? shippingCost;

  final bool? totalAmount;

  final bool? status;

  final bool? paymentStatus;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.CreateManyOrderAndReturnOutputTypeUserArgs>?
      user;

  final _i1.PrismaUnion<bool,
          _i2.CreateManyOrderAndReturnOutputTypeShippingAddressArgs>?
      shippingAddress;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyOrderAndReturnOutputTypeBillingAddressArgs>? billingAddress;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
      };
}

class CreateManyOrderAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyOrderAndReturnOutputTypeInclude({
    this.user,
    this.shippingAddress,
    this.billingAddress,
  });

  final _i1.PrismaUnion<bool, _i2.CreateManyOrderAndReturnOutputTypeUserArgs>?
      user;

  final _i1.PrismaUnion<bool,
          _i2.CreateManyOrderAndReturnOutputTypeShippingAddressArgs>?
      shippingAddress;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyOrderAndReturnOutputTypeBillingAddressArgs>? billingAddress;

  @override
  Map<String, dynamic> toJson() => {
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
      };
}

class OrderUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateInput({
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.billingAddress,
    this.items,
    this.payments,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutOrdersNestedInput? user;

  final _i2.AddressUpdateOneRequiredWithoutShippingOrdersNestedInput?
      shippingAddress;

  final _i2.AddressUpdateOneRequiredWithoutBillingOrdersNestedInput?
      billingAddress;

  final _i2.OrderItemUpdateManyWithoutOrderNestedInput? items;

  final _i2.PaymentUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
        'payments': payments,
      };
}

class OrderUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
    this.payments,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      shippingAddressId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      billingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderItemUncheckedUpdateManyWithoutOrderNestedInput? items;

  final _i2.PaymentUncheckedUpdateManyWithoutOrderNestedInput? payments;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
        'payments': payments,
      };
}

class OrderUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      shippingAddressId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      billingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UpdateManyOrderAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyOrderAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyOrderAndReturnOutputTypeShippingAddressArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyOrderAndReturnOutputTypeShippingAddressArgs({
    this.select,
    this.include,
  });

  final _i2.AddressSelect? select;

  final _i2.AddressInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyOrderAndReturnOutputTypeBillingAddressArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyOrderAndReturnOutputTypeBillingAddressArgs({
    this.select,
    this.include,
  });

  final _i2.AddressSelect? select;

  final _i2.AddressInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyOrderAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyOrderAndReturnOutputTypeSelect({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.billingAddress,
  });

  final bool? id;

  final bool? userId;

  final bool? shippingAddressId;

  final bool? billingAddressId;

  final bool? subtotal;

  final bool? tax;

  final bool? shippingCost;

  final bool? totalAmount;

  final bool? status;

  final bool? paymentStatus;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.UpdateManyOrderAndReturnOutputTypeUserArgs>?
      user;

  final _i1.PrismaUnion<bool,
          _i2.UpdateManyOrderAndReturnOutputTypeShippingAddressArgs>?
      shippingAddress;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyOrderAndReturnOutputTypeBillingAddressArgs>? billingAddress;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
      };
}

class UpdateManyOrderAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyOrderAndReturnOutputTypeInclude({
    this.user,
    this.shippingAddress,
    this.billingAddress,
  });

  final _i1.PrismaUnion<bool, _i2.UpdateManyOrderAndReturnOutputTypeUserArgs>?
      user;

  final _i1.PrismaUnion<bool,
          _i2.UpdateManyOrderAndReturnOutputTypeShippingAddressArgs>?
      shippingAddress;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyOrderAndReturnOutputTypeBillingAddressArgs>? billingAddress;

  @override
  Map<String, dynamic> toJson() => {
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
      };
}

class OrderCountAggregateOutputType {
  const OrderCountAggregateOutputType({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory OrderCountAggregateOutputType.fromJson(Map json) =>
      OrderCountAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        shippingAddressId: json['shippingAddressId'],
        billingAddressId: json['billingAddressId'],
        subtotal: json['subtotal'],
        tax: json['tax'],
        shippingCost: json['shippingCost'],
        totalAmount: json['totalAmount'],
        status: json['status'],
        paymentStatus: json['paymentStatus'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? shippingAddressId;

  final int? billingAddressId;

  final int? subtotal;

  final int? tax;

  final int? shippingCost;

  final int? totalAmount;

  final int? status;

  final int? paymentStatus;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class OrderAvgAggregateOutputType {
  const OrderAvgAggregateOutputType({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
  });

  factory OrderAvgAggregateOutputType.fromJson(Map json) =>
      OrderAvgAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        shippingAddressId: json['shippingAddressId'],
        billingAddressId: json['billingAddressId'],
        subtotal: json['subtotal'],
        tax: json['tax'],
        shippingCost: json['shippingCost'],
        totalAmount: json['totalAmount'],
      );

  final double? id;

  final double? userId;

  final double? shippingAddressId;

  final double? billingAddressId;

  final _i1.Decimal? subtotal;

  final _i1.Decimal? tax;

  final _i1.Decimal? shippingCost;

  final _i1.Decimal? totalAmount;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
      };
}

class OrderSumAggregateOutputType {
  const OrderSumAggregateOutputType({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
  });

  factory OrderSumAggregateOutputType.fromJson(Map json) =>
      OrderSumAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        shippingAddressId: json['shippingAddressId'],
        billingAddressId: json['billingAddressId'],
        subtotal: json['subtotal'],
        tax: json['tax'],
        shippingCost: json['shippingCost'],
        totalAmount: json['totalAmount'],
      );

  final int? id;

  final int? userId;

  final int? shippingAddressId;

  final int? billingAddressId;

  final _i1.Decimal? subtotal;

  final _i1.Decimal? tax;

  final _i1.Decimal? shippingCost;

  final _i1.Decimal? totalAmount;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
      };
}

class OrderMinAggregateOutputType {
  const OrderMinAggregateOutputType({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  factory OrderMinAggregateOutputType.fromJson(Map json) =>
      OrderMinAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        shippingAddressId: json['shippingAddressId'],
        billingAddressId: json['billingAddressId'],
        subtotal: json['subtotal'],
        tax: json['tax'],
        shippingCost: json['shippingCost'],
        totalAmount: json['totalAmount'],
        status: json['status'],
        paymentStatus: json['paymentStatus'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? userId;

  final int? shippingAddressId;

  final int? billingAddressId;

  final _i1.Decimal? subtotal;

  final _i1.Decimal? tax;

  final _i1.Decimal? shippingCost;

  final _i1.Decimal? totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class OrderMaxAggregateOutputType {
  const OrderMaxAggregateOutputType({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  factory OrderMaxAggregateOutputType.fromJson(Map json) =>
      OrderMaxAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        shippingAddressId: json['shippingAddressId'],
        billingAddressId: json['billingAddressId'],
        subtotal: json['subtotal'],
        tax: json['tax'],
        shippingCost: json['shippingCost'],
        totalAmount: json['totalAmount'],
        status: json['status'],
        paymentStatus: json['paymentStatus'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? userId;

  final int? shippingAddressId;

  final int? billingAddressId;

  final _i1.Decimal? subtotal;

  final _i1.Decimal? tax;

  final _i1.Decimal? shippingCost;

  final _i1.Decimal? totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class OrderGroupByOutputType {
  const OrderGroupByOutputType({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory OrderGroupByOutputType.fromJson(Map json) => OrderGroupByOutputType(
        id: json['id'],
        userId: json['userId'],
        shippingAddressId: json['shippingAddressId'],
        billingAddressId: json['billingAddressId'],
        subtotal: json['subtotal'],
        tax: json['tax'],
        shippingCost: json['shippingCost'],
        totalAmount: json['totalAmount'],
        status: json['status'],
        paymentStatus: json['paymentStatus'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
        $count: json['_count'] is Map
            ? _i2.OrderCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OrderAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OrderSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OrderMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OrderMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? userId;

  final int? shippingAddressId;

  final int? billingAddressId;

  final _i1.Decimal? subtotal;

  final _i1.Decimal? tax;

  final _i1.Decimal? shippingCost;

  final _i1.Decimal? totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderCountAggregateOutputType? $count;

  final _i2.OrderAvgAggregateOutputType? $avg;

  final _i2.OrderSumAggregateOutputType? $sum;

  final _i2.OrderMinAggregateOutputType? $min;

  final _i2.OrderMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class OrderCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? shippingAddressId;

  final _i2.SortOrder? billingAddressId;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? shippingCost;

  final _i2.SortOrder? totalAmount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentStatus;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderAvgOrderByAggregateInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? shippingAddressId;

  final _i2.SortOrder? billingAddressId;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? shippingCost;

  final _i2.SortOrder? totalAmount;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
      };
}

class OrderMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? shippingAddressId;

  final _i2.SortOrder? billingAddressId;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? shippingCost;

  final _i2.SortOrder? totalAmount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentStatus;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? shippingAddressId;

  final _i2.SortOrder? billingAddressId;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? shippingCost;

  final _i2.SortOrder? totalAmount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentStatus;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderSumOrderByAggregateInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? shippingAddressId;

  final _i2.SortOrder? billingAddressId;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? shippingCost;

  final _i2.SortOrder? totalAmount;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
      };
}

class OrderOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? shippingAddressId;

  final _i2.SortOrder? billingAddressId;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? shippingCost;

  final _i2.SortOrder? totalAmount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentStatus;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.OrderCountOrderByAggregateInput? $count;

  final _i2.OrderAvgOrderByAggregateInput? $avg;

  final _i2.OrderMaxOrderByAggregateInput? $max;

  final _i2.OrderMinOrderByAggregateInput? $min;

  final _i2.OrderSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class OrderScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.OrderScalarWhereWithAggregatesInput,
      Iterable<_i2.OrderScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.OrderScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.OrderScalarWhereWithAggregatesInput,
      Iterable<_i2.OrderScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? userId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? shippingAddressId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? billingAddressId;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>? subtotal;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>? tax;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>?
      shippingCost;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>?
      totalAmount;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? status;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? paymentStatus;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? shippingAddressId;

  final bool? billingAddressId;

  final bool? subtotal;

  final bool? tax;

  final bool? shippingCost;

  final bool? totalAmount;

  final bool? status;

  final bool? paymentStatus;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class OrderGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderGroupByOutputTypeCountArgs({this.select});

  final _i2.OrderCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
  });

  final bool? id;

  final bool? userId;

  final bool? shippingAddressId;

  final bool? billingAddressId;

  final bool? subtotal;

  final bool? tax;

  final bool? shippingCost;

  final bool? totalAmount;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
      };
}

class OrderGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderGroupByOutputTypeAvgArgs({this.select});

  final _i2.OrderAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
  });

  final bool? id;

  final bool? userId;

  final bool? shippingAddressId;

  final bool? billingAddressId;

  final bool? subtotal;

  final bool? tax;

  final bool? shippingCost;

  final bool? totalAmount;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
      };
}

class OrderGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderGroupByOutputTypeSumArgs({this.select});

  final _i2.OrderSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? shippingAddressId;

  final bool? billingAddressId;

  final bool? subtotal;

  final bool? tax;

  final bool? shippingCost;

  final bool? totalAmount;

  final bool? status;

  final bool? paymentStatus;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderGroupByOutputTypeMinArgs({this.select});

  final _i2.OrderMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? shippingAddressId;

  final bool? billingAddressId;

  final bool? subtotal;

  final bool? tax;

  final bool? shippingCost;

  final bool? totalAmount;

  final bool? status;

  final bool? paymentStatus;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class OrderGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderGroupByOutputTypeMaxArgs({this.select});

  final _i2.OrderMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? shippingAddressId;

  final bool? billingAddressId;

  final bool? subtotal;

  final bool? tax;

  final bool? shippingCost;

  final bool? totalAmount;

  final bool? status;

  final bool? paymentStatus;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.OrderGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.OrderGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.OrderGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.OrderGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.OrderGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateOrder {
  const AggregateOrder({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateOrder.fromJson(Map json) => AggregateOrder(
        $count: json['_count'] is Map
            ? _i2.OrderCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OrderAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OrderSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OrderMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OrderMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.OrderCountAggregateOutputType? $count;

  final _i2.OrderAvgAggregateOutputType? $avg;

  final _i2.OrderSumAggregateOutputType? $sum;

  final _i2.OrderMinAggregateOutputType? $min;

  final _i2.OrderMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateOrderCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderCountArgs({this.select});

  final _i2.OrderCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderAvgArgs({this.select});

  final _i2.OrderAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderSumArgs({this.select});

  final _i2.OrderSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderMinArgs({this.select});

  final _i2.OrderMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderMaxArgs({this.select});

  final _i2.OrderMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateOrderCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateOrderAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateOrderSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateOrderMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateOrderMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class OrderItemCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateInput({
    required this.quantity,
    required this.priceAtPurchase,
    required this.subtotal,
    this.createdAt,
    required this.order,
    required this.product,
  });

  final int quantity;

  final _i1.Decimal priceAtPurchase;

  final _i1.Decimal subtotal;

  final DateTime? createdAt;

  final _i2.OrderCreateNestedOneWithoutItemsInput order;

  final _i2.ProductCreateNestedOneWithoutOrderItemsInput product;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
        'product': product,
      };
}

class OrderItemUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedCreateInput({
    this.id,
    required this.orderId,
    required this.productId,
    required this.quantity,
    required this.priceAtPurchase,
    required this.subtotal,
    this.createdAt,
  });

  final int? id;

  final int orderId;

  final int productId;

  final int quantity;

  final _i1.Decimal priceAtPurchase;

  final _i1.Decimal subtotal;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCreateManyInput({
    this.id,
    required this.orderId,
    required this.productId,
    required this.quantity,
    required this.priceAtPurchase,
    required this.subtotal,
    this.createdAt,
  });

  final int? id;

  final int orderId;

  final int productId;

  final int quantity;

  final _i1.Decimal priceAtPurchase;

  final _i1.Decimal subtotal;

  final DateTime? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class CreateManyOrderItemAndReturnOutputTypeOrderArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyOrderItemAndReturnOutputTypeOrderArgs({
    this.select,
    this.include,
  });

  final _i2.OrderSelect? select;

  final _i2.OrderInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyOrderItemAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyOrderItemAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyOrderItemAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyOrderItemAndReturnOutputTypeSelect({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.order,
    this.product,
  });

  final bool? id;

  final bool? orderId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtPurchase;

  final bool? subtotal;

  final bool? createdAt;

  final _i1
      .PrismaUnion<bool, _i2.CreateManyOrderItemAndReturnOutputTypeOrderArgs>?
      order;

  final _i1
      .PrismaUnion<bool, _i2.CreateManyOrderItemAndReturnOutputTypeProductArgs>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
        'product': product,
      };
}

class CreateManyOrderItemAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyOrderItemAndReturnOutputTypeInclude({
    this.order,
    this.product,
  });

  final _i1
      .PrismaUnion<bool, _i2.CreateManyOrderItemAndReturnOutputTypeOrderArgs>?
      order;

  final _i1
      .PrismaUnion<bool, _i2.CreateManyOrderItemAndReturnOutputTypeProductArgs>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'order': order,
        'product': product,
      };
}

class OrderItemUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUpdateInput({
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.order,
    this.product,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i2.OrderUpdateOneRequiredWithoutItemsNestedInput? order;

  final _i2.ProductUpdateOneRequiredWithoutOrderItemsNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
        'product': product,
      };
}

class OrderItemUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedUpdateInput({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? orderId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemUncheckedUpdateManyInput({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? orderId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? quantity;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class UpdateManyOrderItemAndReturnOutputTypeOrderArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyOrderItemAndReturnOutputTypeOrderArgs({
    this.select,
    this.include,
  });

  final _i2.OrderSelect? select;

  final _i2.OrderInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyOrderItemAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyOrderItemAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyOrderItemAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyOrderItemAndReturnOutputTypeSelect({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.order,
    this.product,
  });

  final bool? id;

  final bool? orderId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtPurchase;

  final bool? subtotal;

  final bool? createdAt;

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyOrderItemAndReturnOutputTypeOrderArgs>?
      order;

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyOrderItemAndReturnOutputTypeProductArgs>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        'order': order,
        'product': product,
      };
}

class UpdateManyOrderItemAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyOrderItemAndReturnOutputTypeInclude({
    this.order,
    this.product,
  });

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyOrderItemAndReturnOutputTypeOrderArgs>?
      order;

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyOrderItemAndReturnOutputTypeProductArgs>?
      product;

  @override
  Map<String, dynamic> toJson() => {
        'order': order,
        'product': product,
      };
}

class OrderItemCountAggregateOutputType {
  const OrderItemCountAggregateOutputType({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.$all,
  });

  factory OrderItemCountAggregateOutputType.fromJson(Map json) =>
      OrderItemCountAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtPurchase: json['priceAtPurchase'],
        subtotal: json['subtotal'],
        createdAt: json['createdAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? orderId;

  final int? productId;

  final int? quantity;

  final int? priceAtPurchase;

  final int? subtotal;

  final int? createdAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        '_all': $all,
      };
}

class OrderItemAvgAggregateOutputType {
  const OrderItemAvgAggregateOutputType({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
  });

  factory OrderItemAvgAggregateOutputType.fromJson(Map json) =>
      OrderItemAvgAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtPurchase: json['priceAtPurchase'],
        subtotal: json['subtotal'],
      );

  final double? id;

  final double? orderId;

  final double? productId;

  final double? quantity;

  final _i1.Decimal? priceAtPurchase;

  final _i1.Decimal? subtotal;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
      };
}

class OrderItemSumAggregateOutputType {
  const OrderItemSumAggregateOutputType({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
  });

  factory OrderItemSumAggregateOutputType.fromJson(Map json) =>
      OrderItemSumAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtPurchase: json['priceAtPurchase'],
        subtotal: json['subtotal'],
      );

  final int? id;

  final int? orderId;

  final int? productId;

  final int? quantity;

  final _i1.Decimal? priceAtPurchase;

  final _i1.Decimal? subtotal;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
      };
}

class OrderItemMinAggregateOutputType {
  const OrderItemMinAggregateOutputType({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  factory OrderItemMinAggregateOutputType.fromJson(Map json) =>
      OrderItemMinAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtPurchase: json['priceAtPurchase'],
        subtotal: json['subtotal'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
      );

  final int? id;

  final int? orderId;

  final int? productId;

  final int? quantity;

  final _i1.Decimal? priceAtPurchase;

  final _i1.Decimal? subtotal;

  final DateTime? createdAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt?.toIso8601String(),
      };
}

class OrderItemMaxAggregateOutputType {
  const OrderItemMaxAggregateOutputType({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  factory OrderItemMaxAggregateOutputType.fromJson(Map json) =>
      OrderItemMaxAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtPurchase: json['priceAtPurchase'],
        subtotal: json['subtotal'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
      );

  final int? id;

  final int? orderId;

  final int? productId;

  final int? quantity;

  final _i1.Decimal? priceAtPurchase;

  final _i1.Decimal? subtotal;

  final DateTime? createdAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt?.toIso8601String(),
      };
}

class OrderItemGroupByOutputType {
  const OrderItemGroupByOutputType({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory OrderItemGroupByOutputType.fromJson(Map json) =>
      OrderItemGroupByOutputType(
        id: json['id'],
        orderId: json['orderId'],
        productId: json['productId'],
        quantity: json['quantity'],
        priceAtPurchase: json['priceAtPurchase'],
        subtotal: json['subtotal'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        $count: json['_count'] is Map
            ? _i2.OrderItemCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OrderItemAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OrderItemSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OrderItemMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OrderItemMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? orderId;

  final int? productId;

  final int? quantity;

  final _i1.Decimal? priceAtPurchase;

  final _i1.Decimal? subtotal;

  final DateTime? createdAt;

  final _i2.OrderItemCountAggregateOutputType? $count;

  final _i2.OrderItemAvgAggregateOutputType? $avg;

  final _i2.OrderItemSumAggregateOutputType? $sum;

  final _i2.OrderItemMinAggregateOutputType? $min;

  final _i2.OrderItemMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class OrderItemCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCountOrderByAggregateInput({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtPurchase;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemAvgOrderByAggregateInput({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtPurchase;

  final _i2.SortOrder? subtotal;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
      };
}

class OrderItemMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemMaxOrderByAggregateInput({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtPurchase;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemMinOrderByAggregateInput({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtPurchase;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemSumOrderByAggregateInput({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtPurchase;

  final _i2.SortOrder? subtotal;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
      };
}

class OrderItemOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemOrderByWithAggregationInput({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? quantity;

  final _i2.SortOrder? priceAtPurchase;

  final _i2.SortOrder? subtotal;

  final _i2.SortOrder? createdAt;

  final _i2.OrderItemCountOrderByAggregateInput? $count;

  final _i2.OrderItemAvgOrderByAggregateInput? $avg;

  final _i2.OrderItemMaxOrderByAggregateInput? $max;

  final _i2.OrderItemMinOrderByAggregateInput? $min;

  final _i2.OrderItemSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class OrderItemScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final _i1.PrismaUnion<_i2.OrderItemScalarWhereWithAggregatesInput,
      Iterable<_i2.OrderItemScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.OrderItemScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.OrderItemScalarWhereWithAggregatesInput,
      Iterable<_i2.OrderItemScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? orderId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? quantity;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>?
      priceAtPurchase;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>? subtotal;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemCountAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.$all,
  });

  final bool? id;

  final bool? orderId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtPurchase;

  final bool? subtotal;

  final bool? createdAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        '_all': $all,
      };
}

class OrderItemGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemGroupByOutputTypeCountArgs({this.select});

  final _i2.OrderItemCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderItemAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemAvgAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
  });

  final bool? id;

  final bool? orderId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtPurchase;

  final bool? subtotal;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
      };
}

class OrderItemGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemGroupByOutputTypeAvgArgs({this.select});

  final _i2.OrderItemAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderItemSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemSumAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
  });

  final bool? id;

  final bool? orderId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtPurchase;

  final bool? subtotal;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
      };
}

class OrderItemGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemGroupByOutputTypeSumArgs({this.select});

  final _i2.OrderItemSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderItemMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemMinAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final bool? id;

  final bool? orderId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtPurchase;

  final bool? subtotal;

  final bool? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemGroupByOutputTypeMinArgs({this.select});

  final _i2.OrderItemMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderItemMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemMaxAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
  });

  final bool? id;

  final bool? orderId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtPurchase;

  final bool? subtotal;

  final bool? createdAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
      };
}

class OrderItemGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemGroupByOutputTypeMaxArgs({this.select});

  final _i2.OrderItemMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrderItemGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderItemGroupByOutputTypeSelect({
    this.id,
    this.orderId,
    this.productId,
    this.quantity,
    this.priceAtPurchase,
    this.subtotal,
    this.createdAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? orderId;

  final bool? productId;

  final bool? quantity;

  final bool? priceAtPurchase;

  final bool? subtotal;

  final bool? createdAt;

  final _i1.PrismaUnion<bool, _i2.OrderItemGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.OrderItemGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.OrderItemGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.OrderItemGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.OrderItemGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'productId': productId,
        'quantity': quantity,
        'priceAtPurchase': priceAtPurchase,
        'subtotal': subtotal,
        'createdAt': createdAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateOrderItem {
  const AggregateOrderItem({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateOrderItem.fromJson(Map json) => AggregateOrderItem(
        $count: json['_count'] is Map
            ? _i2.OrderItemCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OrderItemAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OrderItemSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OrderItemMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OrderItemMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.OrderItemCountAggregateOutputType? $count;

  final _i2.OrderItemAvgAggregateOutputType? $avg;

  final _i2.OrderItemSumAggregateOutputType? $sum;

  final _i2.OrderItemMinAggregateOutputType? $min;

  final _i2.OrderItemMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateOrderItemCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderItemCountArgs({this.select});

  final _i2.OrderItemCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderItemAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderItemAvgArgs({this.select});

  final _i2.OrderItemAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderItemSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderItemSumArgs({this.select});

  final _i2.OrderItemSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderItemMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderItemMinArgs({this.select});

  final _i2.OrderItemMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderItemMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderItemMaxArgs({this.select});

  final _i2.OrderItemMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrderItemSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrderItemSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateOrderItemCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateOrderItemAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateOrderItemSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateOrderItemMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateOrderItemMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class OrderCreateWithoutPaymentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateWithoutPaymentsInput({
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    required this.user,
    required this.shippingAddress,
    required this.billingAddress,
    this.items,
  });

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutOrdersInput user;

  final _i2.AddressCreateNestedOneWithoutShippingOrdersInput shippingAddress;

  final _i2.AddressCreateNestedOneWithoutBillingOrdersInput billingAddress;

  final _i2.OrderItemCreateNestedManyWithoutOrderInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
      };
}

class OrderUncheckedCreateWithoutPaymentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedCreateWithoutPaymentsInput({
    this.id,
    required this.userId,
    required this.shippingAddressId,
    required this.billingAddressId,
    required this.subtotal,
    required this.tax,
    required this.shippingCost,
    required this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final int? id;

  final int userId;

  final int shippingAddressId;

  final int billingAddressId;

  final _i1.Decimal subtotal;

  final _i1.Decimal tax;

  final _i1.Decimal shippingCost;

  final _i1.Decimal totalAmount;

  final String? status;

  final String? paymentStatus;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutOrderInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class OrderCreateOrConnectWithoutPaymentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateOrConnectWithoutPaymentsInput({
    required this.where,
    required this.create,
  });

  final _i2.OrderWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutPaymentsInput,
      _i2.OrderUncheckedCreateWithoutPaymentsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrderCreateNestedOneWithoutPaymentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderCreateNestedOneWithoutPaymentsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.OrderCreateWithoutPaymentsInput,
      _i2.OrderUncheckedCreateWithoutPaymentsInput>? create;

  final _i2.OrderCreateOrConnectWithoutPaymentsInput? connectOrCreate;

  final _i2.OrderWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class PaymentCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateInput({
    required this.paymentMethod,
    this.transactionId,
    required this.amount,
    required this.status,
    this.paymentDate,
    required this.order,
  });

  final String paymentMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? transactionId;

  final _i1.Decimal amount;

  final String status;

  final DateTime? paymentDate;

  final _i2.OrderCreateNestedOneWithoutPaymentsInput order;

  @override
  Map<String, dynamic> toJson() => {
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        'order': order,
      };
}

class PaymentUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedCreateInput({
    this.id,
    required this.orderId,
    required this.paymentMethod,
    this.transactionId,
    required this.amount,
    required this.status,
    this.paymentDate,
  });

  final int? id;

  final int orderId;

  final String paymentMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? transactionId;

  final _i1.Decimal amount;

  final String status;

  final DateTime? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCreateManyInput({
    this.id,
    required this.orderId,
    required this.paymentMethod,
    this.transactionId,
    required this.amount,
    required this.status,
    this.paymentDate,
  });

  final int? id;

  final int orderId;

  final String paymentMethod;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? transactionId;

  final _i1.Decimal amount;

  final String status;

  final DateTime? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class CreateManyPaymentAndReturnOutputTypeOrderArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyPaymentAndReturnOutputTypeOrderArgs({
    this.select,
    this.include,
  });

  final _i2.OrderSelect? select;

  final _i2.OrderInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyPaymentAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyPaymentAndReturnOutputTypeSelect({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.order,
  });

  final bool? id;

  final bool? orderId;

  final bool? paymentMethod;

  final bool? transactionId;

  final bool? amount;

  final bool? status;

  final bool? paymentDate;

  final _i1
      .PrismaUnion<bool, _i2.CreateManyPaymentAndReturnOutputTypeOrderArgs>?
      order;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        'order': order,
      };
}

class CreateManyPaymentAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyPaymentAndReturnOutputTypeInclude({this.order});

  final _i1
      .PrismaUnion<bool, _i2.CreateManyPaymentAndReturnOutputTypeOrderArgs>?
      order;

  @override
  Map<String, dynamic> toJson() => {'order': order};
}

class OrderUpdateWithoutPaymentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateWithoutPaymentsInput({
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.shippingAddress,
    this.billingAddress,
    this.items,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutOrdersNestedInput? user;

  final _i2.AddressUpdateOneRequiredWithoutShippingOrdersNestedInput?
      shippingAddress;

  final _i2.AddressUpdateOneRequiredWithoutBillingOrdersNestedInput?
      billingAddress;

  final _i2.OrderItemUpdateManyWithoutOrderNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'shippingAddress': shippingAddress,
        'billingAddress': billingAddress,
        'items': items,
      };
}

class OrderUncheckedUpdateWithoutPaymentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUncheckedUpdateWithoutPaymentsInput({
    this.id,
    this.userId,
    this.shippingAddressId,
    this.billingAddressId,
    this.subtotal,
    this.tax,
    this.shippingCost,
    this.totalAmount,
    this.status,
    this.paymentStatus,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      shippingAddressId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      billingAddressId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      subtotal;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      tax;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      shippingCost;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalAmount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentStatus;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.OrderItemUncheckedUpdateManyWithoutOrderNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'shippingAddressId': shippingAddressId,
        'billingAddressId': billingAddressId,
        'subtotal': subtotal,
        'tax': tax,
        'shippingCost': shippingCost,
        'totalAmount': totalAmount,
        'status': status,
        'paymentStatus': paymentStatus,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class OrderUpsertWithoutPaymentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpsertWithoutPaymentsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutPaymentsInput,
      _i2.OrderUncheckedUpdateWithoutPaymentsInput> update;

  final _i1.PrismaUnion<_i2.OrderCreateWithoutPaymentsInput,
      _i2.OrderUncheckedCreateWithoutPaymentsInput> create;

  final _i2.OrderWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class OrderUpdateToOneWithWhereWithoutPaymentsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateToOneWithWhereWithoutPaymentsInput({
    this.where,
    required this.data,
  });

  final _i2.OrderWhereInput? where;

  final _i1.PrismaUnion<_i2.OrderUpdateWithoutPaymentsInput,
      _i2.OrderUncheckedUpdateWithoutPaymentsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrderUpdateOneRequiredWithoutPaymentsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrderUpdateOneRequiredWithoutPaymentsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.OrderCreateWithoutPaymentsInput,
      _i2.OrderUncheckedCreateWithoutPaymentsInput>? create;

  final _i2.OrderCreateOrConnectWithoutPaymentsInput? connectOrCreate;

  final _i2.OrderUpsertWithoutPaymentsInput? upsert;

  final _i2.OrderWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.OrderUpdateToOneWithWhereWithoutPaymentsInput,
      _i1.PrismaUnion<_i2.OrderUpdateWithoutPaymentsInput,
          _i2.OrderUncheckedUpdateWithoutPaymentsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class PaymentUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUpdateInput({
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.order,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentMethod;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      paymentDate;

  final _i2.OrderUpdateOneRequiredWithoutPaymentsNestedInput? order;

  @override
  Map<String, dynamic> toJson() => {
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        'order': order,
      };
}

class PaymentUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateInput({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? orderId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentMethod;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentUncheckedUpdateManyInput({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? orderId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      paymentMethod;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? status;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class UpdateManyPaymentAndReturnOutputTypeOrderArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyPaymentAndReturnOutputTypeOrderArgs({
    this.select,
    this.include,
  });

  final _i2.OrderSelect? select;

  final _i2.OrderInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyPaymentAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyPaymentAndReturnOutputTypeSelect({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.order,
  });

  final bool? id;

  final bool? orderId;

  final bool? paymentMethod;

  final bool? transactionId;

  final bool? amount;

  final bool? status;

  final bool? paymentDate;

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyPaymentAndReturnOutputTypeOrderArgs>?
      order;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        'order': order,
      };
}

class UpdateManyPaymentAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyPaymentAndReturnOutputTypeInclude({this.order});

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyPaymentAndReturnOutputTypeOrderArgs>?
      order;

  @override
  Map<String, dynamic> toJson() => {'order': order};
}

class PaymentCountAggregateOutputType {
  const PaymentCountAggregateOutputType({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.$all,
  });

  factory PaymentCountAggregateOutputType.fromJson(Map json) =>
      PaymentCountAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        paymentMethod: json['paymentMethod'],
        transactionId: json['transactionId'],
        amount: json['amount'],
        status: json['status'],
        paymentDate: json['paymentDate'],
        $all: json['_all'],
      );

  final int? id;

  final int? orderId;

  final int? paymentMethod;

  final int? transactionId;

  final int? amount;

  final int? status;

  final int? paymentDate;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        '_all': $all,
      };
}

class PaymentAvgAggregateOutputType {
  const PaymentAvgAggregateOutputType({
    this.id,
    this.orderId,
    this.amount,
  });

  factory PaymentAvgAggregateOutputType.fromJson(Map json) =>
      PaymentAvgAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        amount: json['amount'],
      );

  final double? id;

  final double? orderId;

  final _i1.Decimal? amount;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'amount': amount,
      };
}

class PaymentSumAggregateOutputType {
  const PaymentSumAggregateOutputType({
    this.id,
    this.orderId,
    this.amount,
  });

  factory PaymentSumAggregateOutputType.fromJson(Map json) =>
      PaymentSumAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        amount: json['amount'],
      );

  final int? id;

  final int? orderId;

  final _i1.Decimal? amount;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'amount': amount,
      };
}

class PaymentMinAggregateOutputType {
  const PaymentMinAggregateOutputType({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  factory PaymentMinAggregateOutputType.fromJson(Map json) =>
      PaymentMinAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        paymentMethod: json['paymentMethod'],
        transactionId: json['transactionId'],
        amount: json['amount'],
        status: json['status'],
        paymentDate: switch (json['paymentDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['paymentDate']
        },
      );

  final int? id;

  final int? orderId;

  final String? paymentMethod;

  final String? transactionId;

  final _i1.Decimal? amount;

  final String? status;

  final DateTime? paymentDate;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate?.toIso8601String(),
      };
}

class PaymentMaxAggregateOutputType {
  const PaymentMaxAggregateOutputType({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  factory PaymentMaxAggregateOutputType.fromJson(Map json) =>
      PaymentMaxAggregateOutputType(
        id: json['id'],
        orderId: json['orderId'],
        paymentMethod: json['paymentMethod'],
        transactionId: json['transactionId'],
        amount: json['amount'],
        status: json['status'],
        paymentDate: switch (json['paymentDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['paymentDate']
        },
      );

  final int? id;

  final int? orderId;

  final String? paymentMethod;

  final String? transactionId;

  final _i1.Decimal? amount;

  final String? status;

  final DateTime? paymentDate;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate?.toIso8601String(),
      };
}

class PaymentGroupByOutputType {
  const PaymentGroupByOutputType({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory PaymentGroupByOutputType.fromJson(Map json) =>
      PaymentGroupByOutputType(
        id: json['id'],
        orderId: json['orderId'],
        paymentMethod: json['paymentMethod'],
        transactionId: json['transactionId'],
        amount: json['amount'],
        status: json['status'],
        paymentDate: switch (json['paymentDate']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['paymentDate']
        },
        $count: json['_count'] is Map
            ? _i2.PaymentCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.PaymentAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.PaymentSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.PaymentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.PaymentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? orderId;

  final String? paymentMethod;

  final String? transactionId;

  final _i1.Decimal? amount;

  final String? status;

  final DateTime? paymentDate;

  final _i2.PaymentCountAggregateOutputType? $count;

  final _i2.PaymentAvgAggregateOutputType? $avg;

  final _i2.PaymentSumAggregateOutputType? $sum;

  final _i2.PaymentMinAggregateOutputType? $min;

  final _i2.PaymentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class PaymentCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCountOrderByAggregateInput({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? paymentMethod;

  final _i2.SortOrder? transactionId;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentAvgOrderByAggregateInput({
    this.id,
    this.orderId,
    this.amount,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? amount;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'amount': amount,
      };
}

class PaymentMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentMaxOrderByAggregateInput({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? paymentMethod;

  final _i2.SortOrder? transactionId;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentMinOrderByAggregateInput({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? paymentMethod;

  final _i2.SortOrder? transactionId;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentSumOrderByAggregateInput({
    this.id,
    this.orderId,
    this.amount,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? amount;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'amount': amount,
      };
}

class PaymentOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentOrderByWithAggregationInput({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? orderId;

  final _i2.SortOrder? paymentMethod;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? transactionId;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? status;

  final _i2.SortOrder? paymentDate;

  final _i2.PaymentCountOrderByAggregateInput? $count;

  final _i2.PaymentAvgOrderByAggregateInput? $avg;

  final _i2.PaymentMaxOrderByAggregateInput? $max;

  final _i2.PaymentMinOrderByAggregateInput? $min;

  final _i2.PaymentSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class PaymentScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final _i1.PrismaUnion<_i2.PaymentScalarWhereWithAggregatesInput,
      Iterable<_i2.PaymentScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.PaymentScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.PaymentScalarWhereWithAggregatesInput,
      Iterable<_i2.PaymentScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? orderId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? paymentMethod;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? transactionId;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>? amount;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? status;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
      paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentCountAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.$all,
  });

  final bool? id;

  final bool? orderId;

  final bool? paymentMethod;

  final bool? transactionId;

  final bool? amount;

  final bool? status;

  final bool? paymentDate;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        '_all': $all,
      };
}

class PaymentGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeCountArgs({this.select});

  final _i2.PaymentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentAvgAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.amount,
  });

  final bool? id;

  final bool? orderId;

  final bool? amount;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'amount': amount,
      };
}

class PaymentGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeAvgArgs({this.select});

  final _i2.PaymentAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentSumAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.amount,
  });

  final bool? id;

  final bool? orderId;

  final bool? amount;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'amount': amount,
      };
}

class PaymentGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeSumArgs({this.select});

  final _i2.PaymentSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentMinAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final bool? id;

  final bool? orderId;

  final bool? paymentMethod;

  final bool? transactionId;

  final bool? amount;

  final bool? status;

  final bool? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeMinArgs({this.select});

  final _i2.PaymentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentMaxAggregateOutputTypeSelect({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
  });

  final bool? id;

  final bool? orderId;

  final bool? paymentMethod;

  final bool? transactionId;

  final bool? amount;

  final bool? status;

  final bool? paymentDate;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
      };
}

class PaymentGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeMaxArgs({this.select});

  final _i2.PaymentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PaymentGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PaymentGroupByOutputTypeSelect({
    this.id,
    this.orderId,
    this.paymentMethod,
    this.transactionId,
    this.amount,
    this.status,
    this.paymentDate,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? orderId;

  final bool? paymentMethod;

  final bool? transactionId;

  final bool? amount;

  final bool? status;

  final bool? paymentDate;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.PaymentGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'orderId': orderId,
        'paymentMethod': paymentMethod,
        'transactionId': transactionId,
        'amount': amount,
        'status': status,
        'paymentDate': paymentDate,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregatePayment {
  const AggregatePayment({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregatePayment.fromJson(Map json) => AggregatePayment(
        $count: json['_count'] is Map
            ? _i2.PaymentCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.PaymentAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.PaymentSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.PaymentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.PaymentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.PaymentCountAggregateOutputType? $count;

  final _i2.PaymentAvgAggregateOutputType? $avg;

  final _i2.PaymentSumAggregateOutputType? $sum;

  final _i2.PaymentMinAggregateOutputType? $min;

  final _i2.PaymentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregatePaymentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentCountArgs({this.select});

  final _i2.PaymentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentAvgArgs({this.select});

  final _i2.PaymentAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentSumArgs({this.select});

  final _i2.PaymentSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentMinArgs({this.select});

  final _i2.PaymentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentMaxArgs({this.select});

  final _i2.PaymentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePaymentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePaymentSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregatePaymentMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ReviewCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateInput({
    required this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    required this.product,
    required this.user,
  });

  final int rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCreateNestedOneWithoutReviewsInput product;

  final _i2.UserCreateNestedOneWithoutReviewsInput user;

  @override
  Map<String, dynamic> toJson() => {
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
        'user': user,
      };
}

class ReviewUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedCreateInput({
    this.id,
    required this.productId,
    required this.userId,
    required this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int productId;

  final int userId;

  final int rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCreateManyInput({
    this.id,
    required this.productId,
    required this.userId,
    required this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int productId;

  final int userId;

  final int rating;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CreateManyReviewAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyReviewAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyReviewAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyReviewAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyReviewAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyReviewAndReturnOutputTypeSelect({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.product,
    this.user,
  });

  final bool? id;

  final bool? productId;

  final bool? userId;

  final bool? rating;

  final bool? comment;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1
      .PrismaUnion<bool, _i2.CreateManyReviewAndReturnOutputTypeProductArgs>?
      product;

  final _i1.PrismaUnion<bool, _i2.CreateManyReviewAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
        'user': user,
      };
}

class CreateManyReviewAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyReviewAndReturnOutputTypeInclude({
    this.product,
    this.user,
  });

  final _i1
      .PrismaUnion<bool, _i2.CreateManyReviewAndReturnOutputTypeProductArgs>?
      product;

  final _i1.PrismaUnion<bool, _i2.CreateManyReviewAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'user': user,
      };
}

class ReviewUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUpdateInput({
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.product,
    this.user,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductUpdateOneRequiredWithoutReviewsNestedInput? product;

  final _i2.UserUpdateOneRequiredWithoutReviewsNestedInput? user;

  @override
  Map<String, dynamic> toJson() => {
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
        'user': user,
      };
}

class ReviewUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedUpdateInput({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewUncheckedUpdateManyInput({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? rating;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UpdateManyReviewAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyReviewAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyReviewAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyReviewAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyReviewAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyReviewAndReturnOutputTypeSelect({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.product,
    this.user,
  });

  final bool? id;

  final bool? productId;

  final bool? userId;

  final bool? rating;

  final bool? comment;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyReviewAndReturnOutputTypeProductArgs>?
      product;

  final _i1.PrismaUnion<bool, _i2.UpdateManyReviewAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'product': product,
        'user': user,
      };
}

class UpdateManyReviewAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyReviewAndReturnOutputTypeInclude({
    this.product,
    this.user,
  });

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyReviewAndReturnOutputTypeProductArgs>?
      product;

  final _i1.PrismaUnion<bool, _i2.UpdateManyReviewAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'user': user,
      };
}

class ReviewCountAggregateOutputType {
  const ReviewCountAggregateOutputType({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ReviewCountAggregateOutputType.fromJson(Map json) =>
      ReviewCountAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        userId: json['userId'],
        rating: json['rating'],
        comment: json['comment'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? productId;

  final int? userId;

  final int? rating;

  final int? comment;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class ReviewAvgAggregateOutputType {
  const ReviewAvgAggregateOutputType({
    this.id,
    this.productId,
    this.userId,
    this.rating,
  });

  factory ReviewAvgAggregateOutputType.fromJson(Map json) =>
      ReviewAvgAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        userId: json['userId'],
        rating: json['rating'],
      );

  final double? id;

  final double? productId;

  final double? userId;

  final double? rating;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
      };
}

class ReviewSumAggregateOutputType {
  const ReviewSumAggregateOutputType({
    this.id,
    this.productId,
    this.userId,
    this.rating,
  });

  factory ReviewSumAggregateOutputType.fromJson(Map json) =>
      ReviewSumAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        userId: json['userId'],
        rating: json['rating'],
      );

  final int? id;

  final int? productId;

  final int? userId;

  final int? rating;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
      };
}

class ReviewMinAggregateOutputType {
  const ReviewMinAggregateOutputType({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  factory ReviewMinAggregateOutputType.fromJson(Map json) =>
      ReviewMinAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        userId: json['userId'],
        rating: json['rating'],
        comment: json['comment'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? productId;

  final int? userId;

  final int? rating;

  final String? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class ReviewMaxAggregateOutputType {
  const ReviewMaxAggregateOutputType({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  factory ReviewMaxAggregateOutputType.fromJson(Map json) =>
      ReviewMaxAggregateOutputType(
        id: json['id'],
        productId: json['productId'],
        userId: json['userId'],
        rating: json['rating'],
        comment: json['comment'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? productId;

  final int? userId;

  final int? rating;

  final String? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class ReviewGroupByOutputType {
  const ReviewGroupByOutputType({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ReviewGroupByOutputType.fromJson(Map json) => ReviewGroupByOutputType(
        id: json['id'],
        productId: json['productId'],
        userId: json['userId'],
        rating: json['rating'],
        comment: json['comment'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
        $count: json['_count'] is Map
            ? _i2.ReviewCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ReviewAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ReviewSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ReviewMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ReviewMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? productId;

  final int? userId;

  final int? rating;

  final String? comment;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ReviewCountAggregateOutputType? $count;

  final _i2.ReviewAvgAggregateOutputType? $avg;

  final _i2.ReviewSumAggregateOutputType? $sum;

  final _i2.ReviewMinAggregateOutputType? $min;

  final _i2.ReviewMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class ReviewCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCountOrderByAggregateInput({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? comment;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewAvgOrderByAggregateInput({
    this.id,
    this.productId,
    this.userId,
    this.rating,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
      };
}

class ReviewMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewMaxOrderByAggregateInput({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? comment;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewMinOrderByAggregateInput({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? rating;

  final _i2.SortOrder? comment;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewSumOrderByAggregateInput({
    this.id,
    this.productId,
    this.userId,
    this.rating,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? rating;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
      };
}

class ReviewOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewOrderByWithAggregationInput({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? rating;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? comment;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.ReviewCountOrderByAggregateInput? $count;

  final _i2.ReviewAvgOrderByAggregateInput? $avg;

  final _i2.ReviewMaxOrderByAggregateInput? $max;

  final _i2.ReviewMinOrderByAggregateInput? $min;

  final _i2.ReviewSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ReviewScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.ReviewScalarWhereWithAggregatesInput,
      Iterable<_i2.ReviewScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ReviewScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ReviewScalarWhereWithAggregatesInput,
      Iterable<_i2.ReviewScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? userId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? rating;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewCountAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? productId;

  final bool? userId;

  final bool? rating;

  final bool? comment;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class ReviewGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewGroupByOutputTypeCountArgs({this.select});

  final _i2.ReviewCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ReviewAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewAvgAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.userId,
    this.rating,
  });

  final bool? id;

  final bool? productId;

  final bool? userId;

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
      };
}

class ReviewGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewGroupByOutputTypeAvgArgs({this.select});

  final _i2.ReviewAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ReviewSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewSumAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.userId,
    this.rating,
  });

  final bool? id;

  final bool? productId;

  final bool? userId;

  final bool? rating;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
      };
}

class ReviewGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewGroupByOutputTypeSumArgs({this.select});

  final _i2.ReviewSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ReviewMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewMinAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? productId;

  final bool? userId;

  final bool? rating;

  final bool? comment;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewGroupByOutputTypeMinArgs({this.select});

  final _i2.ReviewMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ReviewMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewMaxAggregateOutputTypeSelect({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? productId;

  final bool? userId;

  final bool? rating;

  final bool? comment;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ReviewGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewGroupByOutputTypeMaxArgs({this.select});

  final _i2.ReviewMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ReviewGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReviewGroupByOutputTypeSelect({
    this.id,
    this.productId,
    this.userId,
    this.rating,
    this.comment,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? productId;

  final bool? userId;

  final bool? rating;

  final bool? comment;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ReviewGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ReviewGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ReviewGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ReviewGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ReviewGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'productId': productId,
        'userId': userId,
        'rating': rating,
        'comment': comment,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateReview {
  const AggregateReview({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateReview.fromJson(Map json) => AggregateReview(
        $count: json['_count'] is Map
            ? _i2.ReviewCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ReviewAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ReviewSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ReviewMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ReviewMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ReviewCountAggregateOutputType? $count;

  final _i2.ReviewAvgAggregateOutputType? $avg;

  final _i2.ReviewSumAggregateOutputType? $sum;

  final _i2.ReviewMinAggregateOutputType? $min;

  final _i2.ReviewMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateReviewCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReviewCountArgs({this.select});

  final _i2.ReviewCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateReviewAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReviewAvgArgs({this.select});

  final _i2.ReviewAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateReviewSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReviewSumArgs({this.select});

  final _i2.ReviewSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateReviewMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReviewMinArgs({this.select});

  final _i2.ReviewMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateReviewMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReviewMaxArgs({this.select});

  final _i2.ReviewMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateReviewSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReviewSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateReviewCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateReviewAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateReviewSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateReviewMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateReviewMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class WishlistCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateInput({
    this.name,
    this.createdAt,
    this.updatedAt,
    required this.user,
    this.items,
  });

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCreateNestedOneWithoutWishlistsInput user;

  final _i2.WishlistItemCreateNestedManyWithoutWishlistInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

class WishlistUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedCreateInput({
    this.id,
    required this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final int? id;

  final int userId;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WishlistItemUncheckedCreateNestedManyWithoutWishlistInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class WishlistCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCreateManyInput({
    this.id,
    required this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CreateManyWishlistAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyWishlistAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyWishlistAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyWishlistAndReturnOutputTypeSelect({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final bool? id;

  final bool? userId;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1
      .PrismaUnion<bool, _i2.CreateManyWishlistAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class CreateManyWishlistAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyWishlistAndReturnOutputTypeInclude({this.user});

  final _i1
      .PrismaUnion<bool, _i2.CreateManyWishlistAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class WishlistUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUpdateInput({
    this.name,
    this.createdAt,
    this.updatedAt,
    this.user,
    this.items,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.UserUpdateOneRequiredWithoutWishlistsNestedInput? user;

  final _i2.WishlistItemUpdateManyWithoutWishlistNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
        'items': items,
      };
}

class WishlistUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedUpdateInput({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.items,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput? items;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'items': items,
      };
}

class WishlistUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UpdateManyWishlistAndReturnOutputTypeUserArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyWishlistAndReturnOutputTypeUserArgs({
    this.select,
    this.include,
  });

  final _i2.UserSelect? select;

  final _i2.UserInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyWishlistAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyWishlistAndReturnOutputTypeSelect({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.user,
  });

  final bool? id;

  final bool? userId;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyWishlistAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'user': user,
      };
}

class UpdateManyWishlistAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyWishlistAndReturnOutputTypeInclude({this.user});

  final _i1
      .PrismaUnion<bool, _i2.UpdateManyWishlistAndReturnOutputTypeUserArgs>?
      user;

  @override
  Map<String, dynamic> toJson() => {'user': user};
}

class WishlistCountAggregateOutputType {
  const WishlistCountAggregateOutputType({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory WishlistCountAggregateOutputType.fromJson(Map json) =>
      WishlistCountAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        name: json['name'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? name;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class WishlistAvgAggregateOutputType {
  const WishlistAvgAggregateOutputType({
    this.id,
    this.userId,
  });

  factory WishlistAvgAggregateOutputType.fromJson(Map json) =>
      WishlistAvgAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
      );

  final double? id;

  final double? userId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class WishlistSumAggregateOutputType {
  const WishlistSumAggregateOutputType({
    this.id,
    this.userId,
  });

  factory WishlistSumAggregateOutputType.fromJson(Map json) =>
      WishlistSumAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
      );

  final int? id;

  final int? userId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class WishlistMinAggregateOutputType {
  const WishlistMinAggregateOutputType({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  factory WishlistMinAggregateOutputType.fromJson(Map json) =>
      WishlistMinAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        name: json['name'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? userId;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class WishlistMaxAggregateOutputType {
  const WishlistMaxAggregateOutputType({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  factory WishlistMaxAggregateOutputType.fromJson(Map json) =>
      WishlistMaxAggregateOutputType(
        id: json['id'],
        userId: json['userId'],
        name: json['name'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final int? userId;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class WishlistGroupByOutputType {
  const WishlistGroupByOutputType({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory WishlistGroupByOutputType.fromJson(Map json) =>
      WishlistGroupByOutputType(
        id: json['id'],
        userId: json['userId'],
        name: json['name'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
        $count: json['_count'] is Map
            ? _i2.WishlistCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WishlistAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WishlistSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WishlistMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WishlistMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? userId;

  final String? name;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.WishlistCountAggregateOutputType? $count;

  final _i2.WishlistAvgAggregateOutputType? $avg;

  final _i2.WishlistSumAggregateOutputType? $sum;

  final _i2.WishlistMinAggregateOutputType? $min;

  final _i2.WishlistMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class WishlistCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistAvgOrderByAggregateInput({
    this.id,
    this.userId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class WishlistMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistSumOrderByAggregateInput({
    this.id,
    this.userId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class WishlistOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? name;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.WishlistCountOrderByAggregateInput? $count;

  final _i2.WishlistAvgOrderByAggregateInput? $avg;

  final _i2.WishlistMaxOrderByAggregateInput? $max;

  final _i2.WishlistMinOrderByAggregateInput? $min;

  final _i2.WishlistSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class WishlistScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.WishlistScalarWhereWithAggregatesInput,
      Iterable<_i2.WishlistScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.WishlistScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.WishlistScalarWhereWithAggregatesInput,
      Iterable<_i2.WishlistScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? userId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? name;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class WishlistGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistGroupByOutputTypeCountArgs({this.select});

  final _i2.WishlistCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
  });

  final bool? id;

  final bool? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class WishlistGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistGroupByOutputTypeAvgArgs({this.select});

  final _i2.WishlistAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
  });

  final bool? id;

  final bool? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
      };
}

class WishlistGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistGroupByOutputTypeSumArgs({this.select});

  final _i2.WishlistSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistGroupByOutputTypeMinArgs({this.select});

  final _i2.WishlistMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class WishlistGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistGroupByOutputTypeMaxArgs({this.select});

  final _i2.WishlistMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.name,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? name;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.WishlistGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.WishlistGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.WishlistGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.WishlistGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.WishlistGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'name': name,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateWishlist {
  const AggregateWishlist({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateWishlist.fromJson(Map json) => AggregateWishlist(
        $count: json['_count'] is Map
            ? _i2.WishlistCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WishlistAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WishlistSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WishlistMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WishlistMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.WishlistCountAggregateOutputType? $count;

  final _i2.WishlistAvgAggregateOutputType? $avg;

  final _i2.WishlistSumAggregateOutputType? $sum;

  final _i2.WishlistMinAggregateOutputType? $min;

  final _i2.WishlistMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateWishlistCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistCountArgs({this.select});

  final _i2.WishlistCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistAvgArgs({this.select});

  final _i2.WishlistAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistSumArgs({this.select});

  final _i2.WishlistSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistMinArgs({this.select});

  final _i2.WishlistMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistMaxArgs({this.select});

  final _i2.WishlistMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class WishlistItemCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateInput({
    this.addedAt,
    required this.wishlist,
    required this.product,
  });

  final DateTime? addedAt;

  final _i2.WishlistCreateNestedOneWithoutItemsInput wishlist;

  final _i2.ProductCreateNestedOneWithoutWishlistItemsInput product;

  @override
  Map<String, dynamic> toJson() => {
        'addedAt': addedAt,
        'wishlist': wishlist,
        'product': product,
      };
}

class WishlistItemUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedCreateInput({
    required this.wishlistId,
    required this.productId,
    this.addedAt,
  });

  final int wishlistId;

  final int productId;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCreateManyInput({
    required this.wishlistId,
    required this.productId,
    this.addedAt,
  });

  final int wishlistId;

  final int productId;

  final DateTime? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class CreateManyWishlistItemAndReturnOutputTypeWishlistArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyWishlistItemAndReturnOutputTypeWishlistArgs({
    this.select,
    this.include,
  });

  final _i2.WishlistSelect? select;

  final _i2.WishlistInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyWishlistItemAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyWishlistItemAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyWishlistItemAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyWishlistItemAndReturnOutputTypeSelect({
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.wishlist,
    this.product,
  });

  final bool? wishlistId;

  final bool? productId;

  final bool? addedAt;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyWishlistItemAndReturnOutputTypeWishlistArgs>? wishlist;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyWishlistItemAndReturnOutputTypeProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        'wishlist': wishlist,
        'product': product,
      };
}

class CreateManyWishlistItemAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyWishlistItemAndReturnOutputTypeInclude({
    this.wishlist,
    this.product,
  });

  final _i1.PrismaUnion<bool,
      _i2.CreateManyWishlistItemAndReturnOutputTypeWishlistArgs>? wishlist;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyWishlistItemAndReturnOutputTypeProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'wishlist': wishlist,
        'product': product,
      };
}

class WishlistItemUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUpdateInput({
    this.addedAt,
    this.wishlist,
    this.product,
  });

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  final _i2.WishlistUpdateOneRequiredWithoutItemsNestedInput? wishlist;

  final _i2.ProductUpdateOneRequiredWithoutWishlistItemsNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {
        'addedAt': addedAt,
        'wishlist': wishlist,
        'product': product,
      };
}

class WishlistItemUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedUpdateInput({
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? wishlistId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemUncheckedUpdateManyInput({
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? wishlistId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class UpdateManyWishlistItemAndReturnOutputTypeWishlistArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyWishlistItemAndReturnOutputTypeWishlistArgs({
    this.select,
    this.include,
  });

  final _i2.WishlistSelect? select;

  final _i2.WishlistInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyWishlistItemAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyWishlistItemAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyWishlistItemAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyWishlistItemAndReturnOutputTypeSelect({
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.wishlist,
    this.product,
  });

  final bool? wishlistId;

  final bool? productId;

  final bool? addedAt;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyWishlistItemAndReturnOutputTypeWishlistArgs>? wishlist;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyWishlistItemAndReturnOutputTypeProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        'wishlist': wishlist,
        'product': product,
      };
}

class UpdateManyWishlistItemAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyWishlistItemAndReturnOutputTypeInclude({
    this.wishlist,
    this.product,
  });

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyWishlistItemAndReturnOutputTypeWishlistArgs>? wishlist;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyWishlistItemAndReturnOutputTypeProductArgs>? product;

  @override
  Map<String, dynamic> toJson() => {
        'wishlist': wishlist,
        'product': product,
      };
}

class WishlistItemCountAggregateOutputType {
  const WishlistItemCountAggregateOutputType({
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.$all,
  });

  factory WishlistItemCountAggregateOutputType.fromJson(Map json) =>
      WishlistItemCountAggregateOutputType(
        wishlistId: json['wishlistId'],
        productId: json['productId'],
        addedAt: json['addedAt'],
        $all: json['_all'],
      );

  final int? wishlistId;

  final int? productId;

  final int? addedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        '_all': $all,
      };
}

class WishlistItemAvgAggregateOutputType {
  const WishlistItemAvgAggregateOutputType({
    this.wishlistId,
    this.productId,
  });

  factory WishlistItemAvgAggregateOutputType.fromJson(Map json) =>
      WishlistItemAvgAggregateOutputType(
        wishlistId: json['wishlistId'],
        productId: json['productId'],
      );

  final double? wishlistId;

  final double? productId;

  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
      };
}

class WishlistItemSumAggregateOutputType {
  const WishlistItemSumAggregateOutputType({
    this.wishlistId,
    this.productId,
  });

  factory WishlistItemSumAggregateOutputType.fromJson(Map json) =>
      WishlistItemSumAggregateOutputType(
        wishlistId: json['wishlistId'],
        productId: json['productId'],
      );

  final int? wishlistId;

  final int? productId;

  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
      };
}

class WishlistItemMinAggregateOutputType {
  const WishlistItemMinAggregateOutputType({
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  factory WishlistItemMinAggregateOutputType.fromJson(Map json) =>
      WishlistItemMinAggregateOutputType(
        wishlistId: json['wishlistId'],
        productId: json['productId'],
        addedAt: switch (json['addedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['addedAt']
        },
      );

  final int? wishlistId;

  final int? productId;

  final DateTime? addedAt;

  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt?.toIso8601String(),
      };
}

class WishlistItemMaxAggregateOutputType {
  const WishlistItemMaxAggregateOutputType({
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  factory WishlistItemMaxAggregateOutputType.fromJson(Map json) =>
      WishlistItemMaxAggregateOutputType(
        wishlistId: json['wishlistId'],
        productId: json['productId'],
        addedAt: switch (json['addedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['addedAt']
        },
      );

  final int? wishlistId;

  final int? productId;

  final DateTime? addedAt;

  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt?.toIso8601String(),
      };
}

class WishlistItemGroupByOutputType {
  const WishlistItemGroupByOutputType({
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory WishlistItemGroupByOutputType.fromJson(Map json) =>
      WishlistItemGroupByOutputType(
        wishlistId: json['wishlistId'],
        productId: json['productId'],
        addedAt: switch (json['addedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['addedAt']
        },
        $count: json['_count'] is Map
            ? _i2.WishlistItemCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WishlistItemAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WishlistItemSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WishlistItemMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WishlistItemMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? wishlistId;

  final int? productId;

  final DateTime? addedAt;

  final _i2.WishlistItemCountAggregateOutputType? $count;

  final _i2.WishlistItemAvgAggregateOutputType? $avg;

  final _i2.WishlistItemSumAggregateOutputType? $sum;

  final _i2.WishlistItemMinAggregateOutputType? $min;

  final _i2.WishlistItemMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class WishlistItemCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCountOrderByAggregateInput({
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  final _i2.SortOrder? wishlistId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemAvgOrderByAggregateInput({
    this.wishlistId,
    this.productId,
  });

  final _i2.SortOrder? wishlistId;

  final _i2.SortOrder? productId;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
      };
}

class WishlistItemMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemMaxOrderByAggregateInput({
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  final _i2.SortOrder? wishlistId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemMinOrderByAggregateInput({
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  final _i2.SortOrder? wishlistId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemSumOrderByAggregateInput({
    this.wishlistId,
    this.productId,
  });

  final _i2.SortOrder? wishlistId;

  final _i2.SortOrder? productId;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
      };
}

class WishlistItemOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemOrderByWithAggregationInput({
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? wishlistId;

  final _i2.SortOrder? productId;

  final _i2.SortOrder? addedAt;

  final _i2.WishlistItemCountOrderByAggregateInput? $count;

  final _i2.WishlistItemAvgOrderByAggregateInput? $avg;

  final _i2.WishlistItemMaxOrderByAggregateInput? $max;

  final _i2.WishlistItemMinOrderByAggregateInput? $min;

  final _i2.WishlistItemSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class WishlistItemScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  final _i1.PrismaUnion<_i2.WishlistItemScalarWhereWithAggregatesInput,
      Iterable<_i2.WishlistItemScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.WishlistItemScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.WishlistItemScalarWhereWithAggregatesInput,
      Iterable<_i2.WishlistItemScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? wishlistId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? productId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemCountAggregateOutputTypeSelect({
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.$all,
  });

  final bool? wishlistId;

  final bool? productId;

  final bool? addedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        '_all': $all,
      };
}

class WishlistItemGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemGroupByOutputTypeCountArgs({this.select});

  final _i2.WishlistItemCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistItemAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemAvgAggregateOutputTypeSelect({
    this.wishlistId,
    this.productId,
  });

  final bool? wishlistId;

  final bool? productId;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
      };
}

class WishlistItemGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemGroupByOutputTypeAvgArgs({this.select});

  final _i2.WishlistItemAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistItemSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemSumAggregateOutputTypeSelect({
    this.wishlistId,
    this.productId,
  });

  final bool? wishlistId;

  final bool? productId;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
      };
}

class WishlistItemGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemGroupByOutputTypeSumArgs({this.select});

  final _i2.WishlistItemSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistItemMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemMinAggregateOutputTypeSelect({
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  final bool? wishlistId;

  final bool? productId;

  final bool? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemGroupByOutputTypeMinArgs({this.select});

  final _i2.WishlistItemMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistItemMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemMaxAggregateOutputTypeSelect({
    this.wishlistId,
    this.productId,
    this.addedAt,
  });

  final bool? wishlistId;

  final bool? productId;

  final bool? addedAt;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
      };
}

class WishlistItemGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemGroupByOutputTypeMaxArgs({this.select});

  final _i2.WishlistItemMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WishlistItemGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WishlistItemGroupByOutputTypeSelect({
    this.wishlistId,
    this.productId,
    this.addedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? wishlistId;

  final bool? productId;

  final bool? addedAt;

  final _i1.PrismaUnion<bool, _i2.WishlistItemGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.WishlistItemGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.WishlistItemGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.WishlistItemGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.WishlistItemGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'wishlistId': wishlistId,
        'productId': productId,
        'addedAt': addedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateWishlistItem {
  const AggregateWishlistItem({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateWishlistItem.fromJson(Map json) => AggregateWishlistItem(
        $count: json['_count'] is Map
            ? _i2.WishlistItemCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WishlistItemAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WishlistItemSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WishlistItemMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WishlistItemMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.WishlistItemCountAggregateOutputType? $count;

  final _i2.WishlistItemAvgAggregateOutputType? $avg;

  final _i2.WishlistItemSumAggregateOutputType? $sum;

  final _i2.WishlistItemMinAggregateOutputType? $min;

  final _i2.WishlistItemMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateWishlistItemCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistItemCountArgs({this.select});

  final _i2.WishlistItemCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistItemAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistItemAvgArgs({this.select});

  final _i2.WishlistItemAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistItemSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistItemSumArgs({this.select});

  final _i2.WishlistItemSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistItemMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistItemMinArgs({this.select});

  final _i2.WishlistItemMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistItemMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistItemMaxArgs({this.select});

  final _i2.WishlistItemMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWishlistItemSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWishlistItemSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistItemCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistItemAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistItemSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistItemMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateWishlistItemMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

enum DiscountScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Discount'),
  code<String>('code', 'Discount'),
  description<String>('description', 'Discount'),
  amount<_i1.Decimal>('amount', 'Discount'),
  discountType<String>('discountType', 'Discount'),
  usageLimit<int>('usageLimit', 'Discount'),
  timesUsed<int>('timesUsed', 'Discount'),
  validFrom<DateTime>('validFrom', 'Discount'),
  validTo<DateTime>('validTo', 'Discount'),
  isActive<bool>('isActive', 'Discount'),
  createdAt<DateTime>('createdAt', 'Discount'),
  updatedAt<DateTime>('updatedAt', 'Discount');

  const DiscountScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProductCreateWithoutDiscountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateWithoutDiscountsInput({
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
  });

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryCreateNestedManyWithoutProductInput? categories;

  final _i2.ProductImageCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemCreateNestedManyWithoutProductInput? wishlistItems;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
      };
}

class ProductUncheckedCreateWithoutDiscountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedCreateWithoutDiscountsInput({
    this.id,
    required this.name,
    this.description,
    required this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
  });

  final int? id;

  final String name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal price;

  final int? stockQuantity;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sku;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductCategoryUncheckedCreateNestedManyWithoutProductInput?
      categories;

  final _i2.ProductImageUncheckedCreateNestedManyWithoutProductInput? images;

  final _i2.CartItemUncheckedCreateNestedManyWithoutProductInput? cartItems;

  final _i2.OrderItemUncheckedCreateNestedManyWithoutProductInput? orderItems;

  final _i2.ReviewUncheckedCreateNestedManyWithoutProductInput? reviews;

  final _i2.WishlistItemUncheckedCreateNestedManyWithoutProductInput?
      wishlistItems;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
      };
}

class ProductCreateOrConnectWithoutDiscountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateOrConnectWithoutDiscountsInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutDiscountsInput,
      _i2.ProductUncheckedCreateWithoutDiscountsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductCreateNestedOneWithoutDiscountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductCreateNestedOneWithoutDiscountsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutDiscountsInput,
      _i2.ProductUncheckedCreateWithoutDiscountsInput>? create;

  final _i2.ProductCreateOrConnectWithoutDiscountsInput? connectOrCreate;

  final _i2.ProductWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ProductDiscountCreateWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateWithoutDiscountInput({required this.product});

  final _i2.ProductCreateNestedOneWithoutDiscountsInput product;

  @override
  Map<String, dynamic> toJson() => {'product': product};
}

class ProductDiscountUncheckedCreateWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedCreateWithoutDiscountInput(
      {required this.productId});

  final int productId;

  @override
  Map<String, dynamic> toJson() => {'productId': productId};
}

class ProductDiscountCreateOrConnectWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateOrConnectWithoutDiscountInput({
    required this.where,
    required this.create,
  });

  final _i2.ProductDiscountWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateWithoutDiscountInput,
      _i2.ProductDiscountUncheckedCreateWithoutDiscountInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProductDiscountCreateManyDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateManyDiscountInput({required this.productId});

  final int productId;

  @override
  Map<String, dynamic> toJson() => {'productId': productId};
}

class ProductDiscountCreateManyDiscountInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateManyDiscountInputEnvelope({required this.data});

  final _i1.PrismaUnion<_i2.ProductDiscountCreateManyDiscountInput,
      Iterable<_i2.ProductDiscountCreateManyDiscountInput>> data;

  @override
  Map<String, dynamic> toJson() => {'data': data};
}

class ProductDiscountCreateNestedManyWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateNestedManyWithoutDiscountInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductDiscountCreateWithoutDiscountInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductDiscountCreateWithoutDiscountInput>,
              _i1.PrismaUnion<
                  _i2.ProductDiscountUncheckedCreateWithoutDiscountInput,
                  Iterable<
                      _i2
                      .ProductDiscountUncheckedCreateWithoutDiscountInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateOrConnectWithoutDiscountInput,
          Iterable<_i2.ProductDiscountCreateOrConnectWithoutDiscountInput>>?
      connectOrCreate;

  final _i2.ProductDiscountCreateManyDiscountInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class DiscountCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCreateInput({
    this.code,
    this.description,
    required this.amount,
    required this.discountType,
    this.usageLimit,
    this.timesUsed,
    required this.validFrom,
    required this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.products,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? code;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal amount;

  final String discountType;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? usageLimit;

  final int? timesUsed;

  final DateTime validFrom;

  final DateTime validTo;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductDiscountCreateNestedManyWithoutDiscountInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
      };
}

class ProductDiscountUncheckedCreateNestedManyWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedCreateNestedManyWithoutDiscountInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProductDiscountCreateWithoutDiscountInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductDiscountCreateWithoutDiscountInput>,
              _i1.PrismaUnion<
                  _i2.ProductDiscountUncheckedCreateWithoutDiscountInput,
                  Iterable<
                      _i2
                      .ProductDiscountUncheckedCreateWithoutDiscountInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateOrConnectWithoutDiscountInput,
          Iterable<_i2.ProductDiscountCreateOrConnectWithoutDiscountInput>>?
      connectOrCreate;

  final _i2.ProductDiscountCreateManyDiscountInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class DiscountUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUncheckedCreateInput({
    this.id,
    this.code,
    this.description,
    required this.amount,
    required this.discountType,
    this.usageLimit,
    this.timesUsed,
    required this.validFrom,
    required this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.products,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? code;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal amount;

  final String discountType;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? usageLimit;

  final int? timesUsed;

  final DateTime validFrom;

  final DateTime validTo;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ProductDiscountUncheckedCreateNestedManyWithoutDiscountInput?
      products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
      };
}

class DiscountCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCreateManyInput({
    this.id,
    this.code,
    this.description,
    required this.amount,
    required this.discountType,
    this.usageLimit,
    this.timesUsed,
    required this.validFrom,
    required this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? code;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.Decimal amount;

  final String discountType;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? usageLimit;

  final int? timesUsed;

  final DateTime validFrom;

  final DateTime validTo;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class CreateManyDiscountAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyDiscountAndReturnOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? amount;

  final bool? discountType;

  final bool? usageLimit;

  final bool? timesUsed;

  final bool? validFrom;

  final bool? validTo;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class ProductUpdateWithoutDiscountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateWithoutDiscountsInput({
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUpdateManyWithoutProductNestedInput? categories;

  final _i2.ProductImageUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUpdateManyWithoutProductNestedInput? wishlistItems;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
      };
}

class ProductUncheckedUpdateWithoutDiscountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUncheckedUpdateWithoutDiscountsInput({
    this.id,
    this.name,
    this.description,
    this.price,
    this.stockQuantity,
    this.sku,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.categories,
    this.images,
    this.cartItems,
    this.orderItems,
    this.reviews,
    this.wishlistItems,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      price;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? stockQuantity;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sku;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductCategoryUncheckedUpdateManyWithoutProductNestedInput?
      categories;

  final _i2.ProductImageUncheckedUpdateManyWithoutProductNestedInput? images;

  final _i2.CartItemUncheckedUpdateManyWithoutProductNestedInput? cartItems;

  final _i2.OrderItemUncheckedUpdateManyWithoutProductNestedInput? orderItems;

  final _i2.ReviewUncheckedUpdateManyWithoutProductNestedInput? reviews;

  final _i2.WishlistItemUncheckedUpdateManyWithoutProductNestedInput?
      wishlistItems;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'description': description,
        'price': price,
        'stockQuantity': stockQuantity,
        'sku': sku,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'categories': categories,
        'images': images,
        'cartItems': cartItems,
        'orderItems': orderItems,
        'reviews': reviews,
        'wishlistItems': wishlistItems,
      };
}

class ProductUpsertWithoutDiscountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpsertWithoutDiscountsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutDiscountsInput,
      _i2.ProductUncheckedUpdateWithoutDiscountsInput> update;

  final _i1.PrismaUnion<_i2.ProductCreateWithoutDiscountsInput,
      _i2.ProductUncheckedCreateWithoutDiscountsInput> create;

  final _i2.ProductWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ProductUpdateToOneWithWhereWithoutDiscountsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateToOneWithWhereWithoutDiscountsInput({
    this.where,
    required this.data,
  });

  final _i2.ProductWhereInput? where;

  final _i1.PrismaUnion<_i2.ProductUpdateWithoutDiscountsInput,
      _i2.ProductUncheckedUpdateWithoutDiscountsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductUpdateOneRequiredWithoutDiscountsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductUpdateOneRequiredWithoutDiscountsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ProductCreateWithoutDiscountsInput,
      _i2.ProductUncheckedCreateWithoutDiscountsInput>? create;

  final _i2.ProductCreateOrConnectWithoutDiscountsInput? connectOrCreate;

  final _i2.ProductUpsertWithoutDiscountsInput? upsert;

  final _i2.ProductWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ProductUpdateToOneWithWhereWithoutDiscountsInput,
      _i1.PrismaUnion<_i2.ProductUpdateWithoutDiscountsInput,
          _i2.ProductUncheckedUpdateWithoutDiscountsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ProductDiscountUpdateWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateWithoutDiscountInput({this.product});

  final _i2.ProductUpdateOneRequiredWithoutDiscountsNestedInput? product;

  @override
  Map<String, dynamic> toJson() => {'product': product};
}

class ProductDiscountUncheckedUpdateWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedUpdateWithoutDiscountInput({this.productId});

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  @override
  Map<String, dynamic> toJson() => {'productId': productId};
}

class ProductDiscountUpsertWithWhereUniqueWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpsertWithWhereUniqueWithoutDiscountInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ProductDiscountWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductDiscountUpdateWithoutDiscountInput,
      _i2.ProductDiscountUncheckedUpdateWithoutDiscountInput> update;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateWithoutDiscountInput,
      _i2.ProductDiscountUncheckedCreateWithoutDiscountInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ProductDiscountUpdateWithWhereUniqueWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateWithWhereUniqueWithoutDiscountInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductDiscountWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProductDiscountUpdateWithoutDiscountInput,
      _i2.ProductDiscountUncheckedUpdateWithoutDiscountInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductDiscountUncheckedUpdateManyWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedUpdateManyWithoutDiscountInput(
      {this.productId});

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  @override
  Map<String, dynamic> toJson() => {'productId': productId};
}

class ProductDiscountUpdateManyWithWhereWithoutDiscountInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateManyWithWhereWithoutDiscountInput({
    required this.where,
    required this.data,
  });

  final _i2.ProductDiscountScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ProductDiscountUpdateManyMutationInput,
      _i2.ProductDiscountUncheckedUpdateManyWithoutDiscountInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProductDiscountUpdateManyWithoutDiscountNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateManyWithoutDiscountNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductDiscountCreateWithoutDiscountInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductDiscountCreateWithoutDiscountInput>,
              _i1.PrismaUnion<
                  _i2.ProductDiscountUncheckedCreateWithoutDiscountInput,
                  Iterable<
                      _i2
                      .ProductDiscountUncheckedCreateWithoutDiscountInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateOrConnectWithoutDiscountInput,
          Iterable<_i2.ProductDiscountCreateOrConnectWithoutDiscountInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProductDiscountUpsertWithWhereUniqueWithoutDiscountInput,
          Iterable<
              _i2.ProductDiscountUpsertWithWhereUniqueWithoutDiscountInput>>?
      upsert;

  final _i2.ProductDiscountCreateManyDiscountInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProductDiscountUpdateWithWhereUniqueWithoutDiscountInput,
          Iterable<
              _i2.ProductDiscountUpdateWithWhereUniqueWithoutDiscountInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ProductDiscountUpdateManyWithWhereWithoutDiscountInput,
          Iterable<_i2.ProductDiscountUpdateManyWithWhereWithoutDiscountInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductDiscountScalarWhereInput,
      Iterable<_i2.ProductDiscountScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class DiscountUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUpdateInput({
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.products,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      discountType;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? usageLimit;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? timesUsed;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validFrom;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validTo;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductDiscountUpdateManyWithoutDiscountNestedInput? products;

  @override
  Map<String, dynamic> toJson() => {
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
      };
}

class ProductDiscountUncheckedUpdateManyWithoutDiscountNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedUpdateManyWithoutDiscountNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProductDiscountCreateWithoutDiscountInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProductDiscountCreateWithoutDiscountInput>,
              _i1.PrismaUnion<
                  _i2.ProductDiscountUncheckedCreateWithoutDiscountInput,
                  Iterable<
                      _i2
                      .ProductDiscountUncheckedCreateWithoutDiscountInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProductDiscountCreateOrConnectWithoutDiscountInput,
          Iterable<_i2.ProductDiscountCreateOrConnectWithoutDiscountInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProductDiscountUpsertWithWhereUniqueWithoutDiscountInput,
          Iterable<
              _i2.ProductDiscountUpsertWithWhereUniqueWithoutDiscountInput>>?
      upsert;

  final _i2.ProductDiscountCreateManyDiscountInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProductDiscountWhereUniqueInput,
      Iterable<_i2.ProductDiscountWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProductDiscountUpdateWithWhereUniqueWithoutDiscountInput,
          Iterable<
              _i2.ProductDiscountUpdateWithWhereUniqueWithoutDiscountInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ProductDiscountUpdateManyWithWhereWithoutDiscountInput,
          Iterable<_i2.ProductDiscountUpdateManyWithWhereWithoutDiscountInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProductDiscountScalarWhereInput,
      Iterable<_i2.ProductDiscountScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class DiscountUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUncheckedUpdateInput({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.products,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      discountType;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? usageLimit;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? timesUsed;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validFrom;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validTo;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  final _i2.ProductDiscountUncheckedUpdateManyWithoutDiscountNestedInput?
      products;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        'products': products,
      };
}

class DiscountUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUpdateManyMutationInput({
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      discountType;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? usageLimit;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? timesUsed;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validFrom;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validTo;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountUncheckedUpdateManyInput({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      amount;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      discountType;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? usageLimit;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? timesUsed;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validFrom;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      validTo;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? isActive;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class UpdateManyDiscountAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyDiscountAndReturnOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? amount;

  final bool? discountType;

  final bool? usageLimit;

  final bool? timesUsed;

  final bool? validFrom;

  final bool? validTo;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountCountAggregateOutputType {
  const DiscountCountAggregateOutputType({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory DiscountCountAggregateOutputType.fromJson(Map json) =>
      DiscountCountAggregateOutputType(
        id: json['id'],
        code: json['code'],
        description: json['description'],
        amount: json['amount'],
        discountType: json['discountType'],
        usageLimit: json['usageLimit'],
        timesUsed: json['timesUsed'],
        validFrom: json['validFrom'],
        validTo: json['validTo'],
        isActive: json['isActive'],
        createdAt: json['createdAt'],
        updatedAt: json['updatedAt'],
        $all: json['_all'],
      );

  final int? id;

  final int? code;

  final int? description;

  final int? amount;

  final int? discountType;

  final int? usageLimit;

  final int? timesUsed;

  final int? validFrom;

  final int? validTo;

  final int? isActive;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class DiscountAvgAggregateOutputType {
  const DiscountAvgAggregateOutputType({
    this.id,
    this.amount,
    this.usageLimit,
    this.timesUsed,
  });

  factory DiscountAvgAggregateOutputType.fromJson(Map json) =>
      DiscountAvgAggregateOutputType(
        id: json['id'],
        amount: json['amount'],
        usageLimit: json['usageLimit'],
        timesUsed: json['timesUsed'],
      );

  final double? id;

  final _i1.Decimal? amount;

  final double? usageLimit;

  final double? timesUsed;

  Map<String, dynamic> toJson() => {
        'id': id,
        'amount': amount,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
      };
}

class DiscountSumAggregateOutputType {
  const DiscountSumAggregateOutputType({
    this.id,
    this.amount,
    this.usageLimit,
    this.timesUsed,
  });

  factory DiscountSumAggregateOutputType.fromJson(Map json) =>
      DiscountSumAggregateOutputType(
        id: json['id'],
        amount: json['amount'],
        usageLimit: json['usageLimit'],
        timesUsed: json['timesUsed'],
      );

  final int? id;

  final _i1.Decimal? amount;

  final int? usageLimit;

  final int? timesUsed;

  Map<String, dynamic> toJson() => {
        'id': id,
        'amount': amount,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
      };
}

class DiscountMinAggregateOutputType {
  const DiscountMinAggregateOutputType({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  factory DiscountMinAggregateOutputType.fromJson(Map json) =>
      DiscountMinAggregateOutputType(
        id: json['id'],
        code: json['code'],
        description: json['description'],
        amount: json['amount'],
        discountType: json['discountType'],
        usageLimit: json['usageLimit'],
        timesUsed: json['timesUsed'],
        validFrom: switch (json['validFrom']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['validFrom']
        },
        validTo: switch (json['validTo']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['validTo']
        },
        isActive: json['isActive'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final String? code;

  final String? description;

  final _i1.Decimal? amount;

  final String? discountType;

  final int? usageLimit;

  final int? timesUsed;

  final DateTime? validFrom;

  final DateTime? validTo;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom?.toIso8601String(),
        'validTo': validTo?.toIso8601String(),
        'isActive': isActive,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class DiscountMaxAggregateOutputType {
  const DiscountMaxAggregateOutputType({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  factory DiscountMaxAggregateOutputType.fromJson(Map json) =>
      DiscountMaxAggregateOutputType(
        id: json['id'],
        code: json['code'],
        description: json['description'],
        amount: json['amount'],
        discountType: json['discountType'],
        usageLimit: json['usageLimit'],
        timesUsed: json['timesUsed'],
        validFrom: switch (json['validFrom']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['validFrom']
        },
        validTo: switch (json['validTo']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['validTo']
        },
        isActive: json['isActive'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
      );

  final int? id;

  final String? code;

  final String? description;

  final _i1.Decimal? amount;

  final String? discountType;

  final int? usageLimit;

  final int? timesUsed;

  final DateTime? validFrom;

  final DateTime? validTo;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom?.toIso8601String(),
        'validTo': validTo?.toIso8601String(),
        'isActive': isActive,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
      };
}

class DiscountGroupByOutputType {
  const DiscountGroupByOutputType({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory DiscountGroupByOutputType.fromJson(Map json) =>
      DiscountGroupByOutputType(
        id: json['id'],
        code: json['code'],
        description: json['description'],
        amount: json['amount'],
        discountType: json['discountType'],
        usageLimit: json['usageLimit'],
        timesUsed: json['timesUsed'],
        validFrom: switch (json['validFrom']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['validFrom']
        },
        validTo: switch (json['validTo']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['validTo']
        },
        isActive: json['isActive'],
        createdAt: switch (json['createdAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['createdAt']
        },
        updatedAt: switch (json['updatedAt']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updatedAt']
        },
        $count: json['_count'] is Map
            ? _i2.DiscountCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.DiscountAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.DiscountSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.DiscountMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.DiscountMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? code;

  final String? description;

  final _i1.Decimal? amount;

  final String? discountType;

  final int? usageLimit;

  final int? timesUsed;

  final DateTime? validFrom;

  final DateTime? validTo;

  final bool? isActive;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.DiscountCountAggregateOutputType? $count;

  final _i2.DiscountAvgAggregateOutputType? $avg;

  final _i2.DiscountSumAggregateOutputType? $sum;

  final _i2.DiscountMinAggregateOutputType? $min;

  final _i2.DiscountMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom?.toIso8601String(),
        'validTo': validTo?.toIso8601String(),
        'isActive': isActive,
        'createdAt': createdAt?.toIso8601String(),
        'updatedAt': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class DiscountCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCountOrderByAggregateInput({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? code;

  final _i2.SortOrder? description;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? discountType;

  final _i2.SortOrder? usageLimit;

  final _i2.SortOrder? timesUsed;

  final _i2.SortOrder? validFrom;

  final _i2.SortOrder? validTo;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountAvgOrderByAggregateInput({
    this.id,
    this.amount,
    this.usageLimit,
    this.timesUsed,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? usageLimit;

  final _i2.SortOrder? timesUsed;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'amount': amount,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
      };
}

class DiscountMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountMaxOrderByAggregateInput({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? code;

  final _i2.SortOrder? description;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? discountType;

  final _i2.SortOrder? usageLimit;

  final _i2.SortOrder? timesUsed;

  final _i2.SortOrder? validFrom;

  final _i2.SortOrder? validTo;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountMinOrderByAggregateInput({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? code;

  final _i2.SortOrder? description;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? discountType;

  final _i2.SortOrder? usageLimit;

  final _i2.SortOrder? timesUsed;

  final _i2.SortOrder? validFrom;

  final _i2.SortOrder? validTo;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountSumOrderByAggregateInput({
    this.id,
    this.amount,
    this.usageLimit,
    this.timesUsed,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? usageLimit;

  final _i2.SortOrder? timesUsed;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'amount': amount,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
      };
}

class DiscountOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountOrderByWithAggregationInput({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? code;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i2.SortOrder? amount;

  final _i2.SortOrder? discountType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? usageLimit;

  final _i2.SortOrder? timesUsed;

  final _i2.SortOrder? validFrom;

  final _i2.SortOrder? validTo;

  final _i2.SortOrder? isActive;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.DiscountCountOrderByAggregateInput? $count;

  final _i2.DiscountAvgOrderByAggregateInput? $avg;

  final _i2.DiscountMaxOrderByAggregateInput? $max;

  final _i2.DiscountMinOrderByAggregateInput? $min;

  final _i2.DiscountSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class DiscountScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.DiscountScalarWhereWithAggregatesInput,
      Iterable<_i2.DiscountScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.DiscountScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.DiscountScalarWhereWithAggregatesInput,
      Iterable<_i2.DiscountScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>? amount;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? discountType;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? usageLimit;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? timesUsed;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? validFrom;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? validTo;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? isActive;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountCountAggregateOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? amount;

  final bool? discountType;

  final bool? usageLimit;

  final bool? timesUsed;

  final bool? validFrom;

  final bool? validTo;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_all': $all,
      };
}

class DiscountGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountGroupByOutputTypeCountArgs({this.select});

  final _i2.DiscountCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountAvgAggregateOutputTypeSelect({
    this.id,
    this.amount,
    this.usageLimit,
    this.timesUsed,
  });

  final bool? id;

  final bool? amount;

  final bool? usageLimit;

  final bool? timesUsed;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'amount': amount,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
      };
}

class DiscountGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountGroupByOutputTypeAvgArgs({this.select});

  final _i2.DiscountAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountSumAggregateOutputTypeSelect({
    this.id,
    this.amount,
    this.usageLimit,
    this.timesUsed,
  });

  final bool? id;

  final bool? amount;

  final bool? usageLimit;

  final bool? timesUsed;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'amount': amount,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
      };
}

class DiscountGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountGroupByOutputTypeSumArgs({this.select});

  final _i2.DiscountSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountMinAggregateOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? amount;

  final bool? discountType;

  final bool? usageLimit;

  final bool? timesUsed;

  final bool? validFrom;

  final bool? validTo;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountGroupByOutputTypeMinArgs({this.select});

  final _i2.DiscountMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountMaxAggregateOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? amount;

  final bool? discountType;

  final bool? usageLimit;

  final bool? timesUsed;

  final bool? validFrom;

  final bool? validTo;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
      };
}

class DiscountGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountGroupByOutputTypeMaxArgs({this.select});

  final _i2.DiscountMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DiscountGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DiscountGroupByOutputTypeSelect({
    this.id,
    this.code,
    this.description,
    this.amount,
    this.discountType,
    this.usageLimit,
    this.timesUsed,
    this.validFrom,
    this.validTo,
    this.isActive,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? code;

  final bool? description;

  final bool? amount;

  final bool? discountType;

  final bool? usageLimit;

  final bool? timesUsed;

  final bool? validFrom;

  final bool? validTo;

  final bool? isActive;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.DiscountGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.DiscountGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.DiscountGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.DiscountGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.DiscountGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'code': code,
        'description': description,
        'amount': amount,
        'discountType': discountType,
        'usageLimit': usageLimit,
        'timesUsed': timesUsed,
        'validFrom': validFrom,
        'validTo': validTo,
        'isActive': isActive,
        'createdAt': createdAt,
        'updatedAt': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateDiscount {
  const AggregateDiscount({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateDiscount.fromJson(Map json) => AggregateDiscount(
        $count: json['_count'] is Map
            ? _i2.DiscountCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.DiscountAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.DiscountSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.DiscountMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.DiscountMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.DiscountCountAggregateOutputType? $count;

  final _i2.DiscountAvgAggregateOutputType? $avg;

  final _i2.DiscountSumAggregateOutputType? $sum;

  final _i2.DiscountMinAggregateOutputType? $min;

  final _i2.DiscountMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateDiscountCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountCountArgs({this.select});

  final _i2.DiscountCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountAvgArgs({this.select});

  final _i2.DiscountAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountSumArgs({this.select});

  final _i2.DiscountSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountMinArgs({this.select});

  final _i2.DiscountMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountMaxArgs({this.select});

  final _i2.DiscountMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDiscountSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDiscountSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateDiscountMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ProductDiscountCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateInput({
    required this.product,
    required this.discount,
  });

  final _i2.ProductCreateNestedOneWithoutDiscountsInput product;

  final _i2.DiscountCreateNestedOneWithoutProductsInput discount;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'discount': discount,
      };
}

class ProductDiscountUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedCreateInput({
    required this.productId,
    required this.discountId,
  });

  final int productId;

  final int discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCreateManyInput({
    required this.productId,
    required this.discountId,
  });

  final int productId;

  final int discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class CreateManyProductDiscountAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductDiscountAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyProductDiscountAndReturnOutputTypeDiscountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductDiscountAndReturnOutputTypeDiscountArgs({
    this.select,
    this.include,
  });

  final _i2.DiscountSelect? select;

  final _i2.DiscountInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class CreateManyProductDiscountAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductDiscountAndReturnOutputTypeSelect({
    this.productId,
    this.discountId,
    this.product,
    this.discount,
  });

  final bool? productId;

  final bool? discountId;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductDiscountAndReturnOutputTypeProductArgs>? product;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductDiscountAndReturnOutputTypeDiscountArgs>? discount;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
        'product': product,
        'discount': discount,
      };
}

class CreateManyProductDiscountAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CreateManyProductDiscountAndReturnOutputTypeInclude({
    this.product,
    this.discount,
  });

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductDiscountAndReturnOutputTypeProductArgs>? product;

  final _i1.PrismaUnion<bool,
      _i2.CreateManyProductDiscountAndReturnOutputTypeDiscountArgs>? discount;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'discount': discount,
      };
}

class ProductDiscountUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUpdateInput({
    this.product,
    this.discount,
  });

  final _i2.ProductUpdateOneRequiredWithoutDiscountsNestedInput? product;

  final _i2.DiscountUpdateOneRequiredWithoutProductsNestedInput? discount;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'discount': discount,
      };
}

class ProductDiscountUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedUpdateInput({
    this.productId,
    this.discountId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountUncheckedUpdateManyInput({
    this.productId,
    this.discountId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? productId;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class UpdateManyProductDiscountAndReturnOutputTypeProductArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductDiscountAndReturnOutputTypeProductArgs({
    this.select,
    this.include,
  });

  final _i2.ProductSelect? select;

  final _i2.ProductInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyProductDiscountAndReturnOutputTypeDiscountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductDiscountAndReturnOutputTypeDiscountArgs({
    this.select,
    this.include,
  });

  final _i2.DiscountSelect? select;

  final _i2.DiscountInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class UpdateManyProductDiscountAndReturnOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductDiscountAndReturnOutputTypeSelect({
    this.productId,
    this.discountId,
    this.product,
    this.discount,
  });

  final bool? productId;

  final bool? discountId;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductDiscountAndReturnOutputTypeProductArgs>? product;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductDiscountAndReturnOutputTypeDiscountArgs>? discount;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
        'product': product,
        'discount': discount,
      };
}

class UpdateManyProductDiscountAndReturnOutputTypeInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UpdateManyProductDiscountAndReturnOutputTypeInclude({
    this.product,
    this.discount,
  });

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductDiscountAndReturnOutputTypeProductArgs>? product;

  final _i1.PrismaUnion<bool,
      _i2.UpdateManyProductDiscountAndReturnOutputTypeDiscountArgs>? discount;

  @override
  Map<String, dynamic> toJson() => {
        'product': product,
        'discount': discount,
      };
}

class ProductDiscountCountAggregateOutputType {
  const ProductDiscountCountAggregateOutputType({
    this.productId,
    this.discountId,
    this.$all,
  });

  factory ProductDiscountCountAggregateOutputType.fromJson(Map json) =>
      ProductDiscountCountAggregateOutputType(
        productId: json['productId'],
        discountId: json['discountId'],
        $all: json['_all'],
      );

  final int? productId;

  final int? discountId;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
        '_all': $all,
      };
}

class ProductDiscountAvgAggregateOutputType {
  const ProductDiscountAvgAggregateOutputType({
    this.productId,
    this.discountId,
  });

  factory ProductDiscountAvgAggregateOutputType.fromJson(Map json) =>
      ProductDiscountAvgAggregateOutputType(
        productId: json['productId'],
        discountId: json['discountId'],
      );

  final double? productId;

  final double? discountId;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountSumAggregateOutputType {
  const ProductDiscountSumAggregateOutputType({
    this.productId,
    this.discountId,
  });

  factory ProductDiscountSumAggregateOutputType.fromJson(Map json) =>
      ProductDiscountSumAggregateOutputType(
        productId: json['productId'],
        discountId: json['discountId'],
      );

  final int? productId;

  final int? discountId;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountMinAggregateOutputType {
  const ProductDiscountMinAggregateOutputType({
    this.productId,
    this.discountId,
  });

  factory ProductDiscountMinAggregateOutputType.fromJson(Map json) =>
      ProductDiscountMinAggregateOutputType(
        productId: json['productId'],
        discountId: json['discountId'],
      );

  final int? productId;

  final int? discountId;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountMaxAggregateOutputType {
  const ProductDiscountMaxAggregateOutputType({
    this.productId,
    this.discountId,
  });

  factory ProductDiscountMaxAggregateOutputType.fromJson(Map json) =>
      ProductDiscountMaxAggregateOutputType(
        productId: json['productId'],
        discountId: json['discountId'],
      );

  final int? productId;

  final int? discountId;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountGroupByOutputType {
  const ProductDiscountGroupByOutputType({
    this.productId,
    this.discountId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ProductDiscountGroupByOutputType.fromJson(Map json) =>
      ProductDiscountGroupByOutputType(
        productId: json['productId'],
        discountId: json['discountId'],
        $count: json['_count'] is Map
            ? _i2.ProductDiscountCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductDiscountAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductDiscountSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductDiscountMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductDiscountMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? productId;

  final int? discountId;

  final _i2.ProductDiscountCountAggregateOutputType? $count;

  final _i2.ProductDiscountAvgAggregateOutputType? $avg;

  final _i2.ProductDiscountSumAggregateOutputType? $sum;

  final _i2.ProductDiscountMinAggregateOutputType? $min;

  final _i2.ProductDiscountMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class ProductDiscountCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCountOrderByAggregateInput({
    this.productId,
    this.discountId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountAvgOrderByAggregateInput({
    this.productId,
    this.discountId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountMaxOrderByAggregateInput({
    this.productId,
    this.discountId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountMinOrderByAggregateInput({
    this.productId,
    this.discountId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountSumOrderByAggregateInput({
    this.productId,
    this.discountId,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountOrderByWithAggregationInput({
    this.productId,
    this.discountId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? productId;

  final _i2.SortOrder? discountId;

  final _i2.ProductDiscountCountOrderByAggregateInput? $count;

  final _i2.ProductDiscountAvgOrderByAggregateInput? $avg;

  final _i2.ProductDiscountMaxOrderByAggregateInput? $max;

  final _i2.ProductDiscountMinOrderByAggregateInput? $min;

  final _i2.ProductDiscountSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ProductDiscountScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.productId,
    this.discountId,
  });

  final _i1.PrismaUnion<_i2.ProductDiscountScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductDiscountScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ProductDiscountScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ProductDiscountScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductDiscountScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? productId;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountCountAggregateOutputTypeSelect({
    this.productId,
    this.discountId,
    this.$all,
  });

  final bool? productId;

  final bool? discountId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
        '_all': $all,
      };
}

class ProductDiscountGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountGroupByOutputTypeCountArgs({this.select});

  final _i2.ProductDiscountCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductDiscountAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountAvgAggregateOutputTypeSelect({
    this.productId,
    this.discountId,
  });

  final bool? productId;

  final bool? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountGroupByOutputTypeAvgArgs({this.select});

  final _i2.ProductDiscountAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductDiscountSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountSumAggregateOutputTypeSelect({
    this.productId,
    this.discountId,
  });

  final bool? productId;

  final bool? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountGroupByOutputTypeSumArgs({this.select});

  final _i2.ProductDiscountSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductDiscountMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountMinAggregateOutputTypeSelect({
    this.productId,
    this.discountId,
  });

  final bool? productId;

  final bool? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountGroupByOutputTypeMinArgs({this.select});

  final _i2.ProductDiscountMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductDiscountMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountMaxAggregateOutputTypeSelect({
    this.productId,
    this.discountId,
  });

  final bool? productId;

  final bool? discountId;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
      };
}

class ProductDiscountGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountGroupByOutputTypeMaxArgs({this.select});

  final _i2.ProductDiscountMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductDiscountGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductDiscountGroupByOutputTypeSelect({
    this.productId,
    this.discountId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? productId;

  final bool? discountId;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.ProductDiscountGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'productId': productId,
        'discountId': discountId,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateProductDiscount {
  const AggregateProductDiscount({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateProductDiscount.fromJson(Map json) =>
      AggregateProductDiscount(
        $count: json['_count'] is Map
            ? _i2.ProductDiscountCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductDiscountAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductDiscountSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductDiscountMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductDiscountMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ProductDiscountCountAggregateOutputType? $count;

  final _i2.ProductDiscountAvgAggregateOutputType? $avg;

  final _i2.ProductDiscountSumAggregateOutputType? $sum;

  final _i2.ProductDiscountMinAggregateOutputType? $min;

  final _i2.ProductDiscountMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateProductDiscountCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductDiscountCountArgs({this.select});

  final _i2.ProductDiscountCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductDiscountAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductDiscountAvgArgs({this.select});

  final _i2.ProductDiscountAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductDiscountSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductDiscountSumArgs({this.select});

  final _i2.ProductDiscountSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductDiscountMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductDiscountMinArgs({this.select});

  final _i2.ProductDiscountMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductDiscountMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductDiscountMaxArgs({this.select});

  final _i2.ProductDiscountMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductDiscountSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductDiscountSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateProductDiscountCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateProductDiscountAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateProductDiscountSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateProductDiscountMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateProductDiscountMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}
